{
  "success": true,
  "error": null,
  "results": {
    "printers": [
      {
        "elements": [],
        "description": "Contract GPv2SafeERC20\n\tFunction GPv2SafeERC20.safeTransfer(IERC20,address,uint256) (*)\n\t\tExpression: selector_ = token.transfer.selector\n\t\tIRs:\n\t\t\tREF_1(bytes4) (->None) := 2835717307(bytes4)\n\t\t\tselector_(bytes4) := REF_1(bytes4)\n\t\tExpression: freeMemoryPointer_safeTransfer_asm_0 = mload(uint256)(0x40)\n\t\tIRs:\n\t\t\tTMP_0(uint256) = SOLIDITY_CALL mload(uint256)(64)\n\t\t\tfreeMemoryPointer_safeTransfer_asm_0(uint256) := TMP_0(uint256)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransfer_asm_0,selector_)\n\t\tIRs:\n\t\t\tTMP_1(None) = SOLIDITY_CALL mstore(uint256,uint256)(freeMemoryPointer_safeTransfer_asm_0,selector_)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransfer_asm_0 + 4,to & 0xffffffffffffffffffffffffffffffffffffffff)\n\t\tIRs:\n\t\t\tTMP_2(uint256) = freeMemoryPointer_safeTransfer_asm_0 + 4\n\t\t\tTMP_3(address) = to & 1461501637330902918203684832716283019655932542975\n\t\t\tTMP_4(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2,TMP_3)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransfer_asm_0 + 36,value)\n\t\tIRs:\n\t\t\tTMP_5(uint256) = freeMemoryPointer_safeTransfer_asm_0 + 36\n\t\t\tTMP_6(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_5,value)\n\t\tExpression: ! call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,freeMemoryPointer_safeTransfer_asm_0,68,0,0)\n\t\tIRs:\n\t\t\tTMP_7(uint256) = SOLIDITY_CALL gas()()\n\t\t\tTMP_8(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_7,token,0,freeMemoryPointer_safeTransfer_asm_0,68,0,0)\n\t\t\tTMP_9 = UnaryType.BANG TMP_8 \n\t\t\tCONDITION TMP_9\n\t\tExpression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_10(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_11(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_10)\n\t\tExpression: revert(uint256,uint256)(0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_12(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_13(None) = SOLIDITY_CALL revert(uint256,uint256)(0,TMP_12)\n\t\tExpression: require(bool,string)(getLastTransferResult(token),GPv2: failed transfer)\n\t\tIRs:\n\t\t\tTMP_14(bool) = INTERNAL_CALL, GPv2SafeERC20.getLastTransferResult(IERC20)(token)\n\t\t\tTMP_15(None) = SOLIDITY_CALL require(bool,string)(TMP_14,GPv2: failed transfer)\n\tFunction GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256) (*)\n\t\tExpression: selector_ = token.transferFrom.selector\n\t\tIRs:\n\t\t\tREF_3(bytes4) (->None) := 599290589(bytes4)\n\t\t\tselector_(bytes4) := REF_3(bytes4)\n\t\tExpression: freeMemoryPointer_safeTransferFrom_asm_0 = mload(uint256)(0x40)\n\t\tIRs:\n\t\t\tTMP_16(uint256) = SOLIDITY_CALL mload(uint256)(64)\n\t\t\tfreeMemoryPointer_safeTransferFrom_asm_0(uint256) := TMP_16(uint256)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0,selector_)\n\t\tIRs:\n\t\t\tTMP_17(None) = SOLIDITY_CALL mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0,selector_)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0 + 4,from & 0xffffffffffffffffffffffffffffffffffffffff)\n\t\tIRs:\n\t\t\tTMP_18(uint256) = freeMemoryPointer_safeTransferFrom_asm_0 + 4\n\t\t\tTMP_19(address) = from & 1461501637330902918203684832716283019655932542975\n\t\t\tTMP_20(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_18,TMP_19)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0 + 36,to & 0xffffffffffffffffffffffffffffffffffffffff)\n\t\tIRs:\n\t\t\tTMP_21(uint256) = freeMemoryPointer_safeTransferFrom_asm_0 + 36\n\t\t\tTMP_22(address) = to & 1461501637330902918203684832716283019655932542975\n\t\t\tTMP_23(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_21,TMP_22)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0 + 68,value)\n\t\tIRs:\n\t\t\tTMP_24(uint256) = freeMemoryPointer_safeTransferFrom_asm_0 + 68\n\t\t\tTMP_25(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_24,value)\n\t\tExpression: ! call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,freeMemoryPointer_safeTransferFrom_asm_0,100,0,0)\n\t\tIRs:\n\t\t\tTMP_26(uint256) = SOLIDITY_CALL gas()()\n\t\t\tTMP_27(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_26,token,0,freeMemoryPointer_safeTransferFrom_asm_0,100,0,0)\n\t\t\tTMP_28 = UnaryType.BANG TMP_27 \n\t\t\tCONDITION TMP_28\n\t\tExpression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_29(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_30(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_29)\n\t\tExpression: revert(uint256,uint256)(0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_31(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_32(None) = SOLIDITY_CALL revert(uint256,uint256)(0,TMP_31)\n\t\tExpression: require(bool,string)(getLastTransferResult(token),GPv2: failed transferFrom)\n\t\tIRs:\n\t\t\tTMP_33(bool) = INTERNAL_CALL, GPv2SafeERC20.getLastTransferResult(IERC20)(token)\n\t\t\tTMP_34(None) = SOLIDITY_CALL require(bool,string)(TMP_33,GPv2: failed transferFrom)\n\tFunction GPv2SafeERC20.getLastTransferResult(IERC20) (*)\n\t\tExpression: switch_expr_3538_1174_0_getLastTransferResult_asm_0 = returndatasize()()\n\t\tIRs:\n\t\t\tTMP_35(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tswitch_expr_3538_1174_0_getLastTransferResult_asm_0(uint256) := TMP_35(uint256)\n\t\tExpression: switch_expr_3538_1174_0_getLastTransferResult_asm_0 == 0\n\t\tIRs:\n\t\t\tTMP_36(bool) = switch_expr_3538_1174_0_getLastTransferResult_asm_0 == 0\n\t\t\tCONDITION TMP_36\n\t\tExpression: ! extcodesize(uint256)(token)\n\t\tIRs:\n\t\t\tREF_4(None) -> token.codesize\n\t\t\tTMP_37 = UnaryType.BANG REF_4 \n\t\t\tCONDITION TMP_37\n\t\tExpression: revertWithMessage(20,GPv2: not a contract)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, GPv2SafeERC20.getLastTransferResult.asm_0.revertWithMessage()(20,GPv2: not a contract)\n\t\tExpression: success = 1\n\t\tIRs:\n\t\t\tsuccess(bool) := 1(uint256)\n\t\tExpression: switch_expr_3538_1174_0_getLastTransferResult_asm_0 == 32\n\t\tIRs:\n\t\t\tTMP_39(bool) = switch_expr_3538_1174_0_getLastTransferResult_asm_0 == 32\n\t\t\tCONDITION TMP_39\n\t\tExpression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_40(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_41(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_40)\n\t\tExpression: success = ! ! mload(uint256)(0)\n\t\tIRs:\n\t\t\tTMP_42(uint256) = SOLIDITY_CALL mload(uint256)(0)\n\t\t\tTMP_43 = UnaryType.BANG TMP_42 \n\t\t\tTMP_44 = UnaryType.BANG TMP_43 \n\t\t\tsuccess(bool) := TMP_44(uint256)\n\t\tExpression: revertWithMessage(31,GPv2: malformed transfer result)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, GPv2SafeERC20.getLastTransferResult.asm_0.revertWithMessage()(31,GPv2: malformed transfer result)\n\t\tExpression: success\n\t\tIRs:\n\t\t\tRETURN success\n\tFunction GPv2SafeERC20.getLastTransferResult.asm_0.revertWithMessage() (*)\n\t\tExpression: mstore(uint256,uint256)(0x00,08c379a0)\n\t\tIRs:\n\t\t\tTMP_46(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,08c379a0)\n\t\tExpression: mstore(uint256,uint256)(0x04,0x20)\n\t\tIRs:\n\t\t\tTMP_47(None) = SOLIDITY_CALL mstore(uint256,uint256)(4,32)\n\t\tExpression: mstore(uint256,uint256)(0x24,length_getLastTransferResult_asm_0_revertWithMessage)\n\t\tIRs:\n\t\t\tTMP_48(None) = SOLIDITY_CALL mstore(uint256,uint256)(36,length_getLastTransferResult_asm_0_revertWithMessage)\n\t\tExpression: mstore(uint256,uint256)(0x44,message_getLastTransferResult_asm_0_revertWithMessage)\n\t\tIRs:\n\t\t\tTMP_49(None) = SOLIDITY_CALL mstore(uint256,uint256)(68,message_getLastTransferResult_asm_0_revertWithMessage)\n\t\tExpression: revert(uint256,uint256)(0x00,0x64)\n\t\tIRs:\n\t\t\tTMP_50(None) = SOLIDITY_CALL revert(uint256,uint256)(0,100)\nContract Address\n\tFunction Address.isContract(address) (*)\n\t\tExpression: size = extcodesize(uint256)(account)\n\t\tIRs:\n\t\t\tREF_5 -> CODESIZE account\n\t\t\tsize(uint256) := REF_5(uint256)\n\t\tExpression: size > 0\n\t\tIRs:\n\t\t\tTMP_51(bool) = size > 0\n\t\t\tRETURN TMP_51\n\tFunction Address.sendValue(address,uint256) (*)\n\t\tExpression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)\n\t\tIRs:\n\t\t\tTMP_52 = CONVERT this to address\n\t\t\tTMP_53(uint256) = SOLIDITY_CALL balance(address)(TMP_52)\n\t\t\tTMP_54(bool) = TMP_53 >= amount\n\t\t\tTMP_55(None) = SOLIDITY_CALL require(bool,string)(TMP_54,Address: insufficient balance)\n\t\tExpression: (success,None) = recipient.call{value: amount}()\n\t\tIRs:\n\t\t\tTUPLE_0(bool,bytes) = LOW_LEVEL_CALL, dest:recipient, function:call, arguments:[''] value:amount \n\t\t\tsuccess(bool)= UNPACK TUPLE_0 index: 0 \n\t\tExpression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)\n\t\tIRs:\n\t\t\tTMP_56(None) = SOLIDITY_CALL require(bool,string)(success,Address: unable to send value, recipient may have reverted)\n\tFunction Address.functionCall(address,bytes) (*)\n\t\tExpression: functionCall(target,data,Address: low-level call failed)\n\t\tIRs:\n\t\t\tTMP_57(bytes) = INTERNAL_CALL, Address.functionCall(address,bytes,string)(target,data,Address: low-level call failed)\n\t\t\tRETURN TMP_57\n\tFunction Address.functionCall(address,bytes,string) (*)\n\t\tExpression: functionCallWithValue(target,data,0,errorMessage)\n\t\tIRs:\n\t\t\tTMP_58(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,0,errorMessage)\n\t\t\tRETURN TMP_58\n\tFunction Address.functionCallWithValue(address,bytes,uint256) (*)\n\t\tExpression: functionCallWithValue(target,data,value,Address: low-level call with value failed)\n\t\tIRs:\n\t\t\tTMP_59(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,value,Address: low-level call with value failed)\n\t\t\tRETURN TMP_59\n\tFunction Address.functionCallWithValue(address,bytes,uint256,string) (*)\n\t\tExpression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)\n\t\tIRs:\n\t\t\tTMP_60 = CONVERT this to address\n\t\t\tTMP_61(uint256) = SOLIDITY_CALL balance(address)(TMP_60)\n\t\t\tTMP_62(bool) = TMP_61 >= value\n\t\t\tTMP_63(None) = SOLIDITY_CALL require(bool,string)(TMP_62,Address: insufficient balance for call)\n\t\tExpression: require(bool,string)(isContract(target),Address: call to non-contract)\n\t\tIRs:\n\t\t\tTMP_64(bool) = INTERNAL_CALL, Address.isContract(address)(target)\n\t\t\tTMP_65(None) = SOLIDITY_CALL require(bool,string)(TMP_64,Address: call to non-contract)\n\t\tExpression: (success,returndata) = target.call{value: value}(data)\n\t\tIRs:\n\t\t\tTUPLE_1(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value \n\t\t\tsuccess(bool)= UNPACK TUPLE_1 index: 0 \n\t\t\treturndata(bytes)= UNPACK TUPLE_1 index: 1 \n\t\tExpression: verifyCallResult(success,returndata,errorMessage)\n\t\tIRs:\n\t\t\tTMP_66(bytes) = INTERNAL_CALL, Address.verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)\n\t\t\tRETURN TMP_66\n\tFunction Address.functionStaticCall(address,bytes) (*)\n\t\tExpression: functionStaticCall(target,data,Address: low-level static call failed)\n\t\tIRs:\n\t\t\tTMP_67(bytes) = INTERNAL_CALL, Address.functionStaticCall(address,bytes,string)(target,data,Address: low-level static call failed)\n\t\t\tRETURN TMP_67\n\tFunction Address.functionStaticCall(address,bytes,string) (*)\n\t\tExpression: require(bool,string)(isContract(target),Address: static call to non-contract)\n\t\tIRs:\n\t\t\tTMP_68(bool) = INTERNAL_CALL, Address.isContract(address)(target)\n\t\t\tTMP_69(None) = SOLIDITY_CALL require(bool,string)(TMP_68,Address: static call to non-contract)\n\t\tExpression: (success,returndata) = target.staticcall(data)\n\t\tIRs:\n\t\t\tTUPLE_2(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:staticcall, arguments:['data']  \n\t\t\tsuccess(bool)= UNPACK TUPLE_2 index: 0 \n\t\t\treturndata(bytes)= UNPACK TUPLE_2 index: 1 \n\t\tExpression: verifyCallResult(success,returndata,errorMessage)\n\t\tIRs:\n\t\t\tTMP_70(bytes) = INTERNAL_CALL, Address.verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)\n\t\t\tRETURN TMP_70\n\tFunction Address.functionDelegateCall(address,bytes) (*)\n\t\tExpression: functionDelegateCall(target,data,Address: low-level delegate call failed)\n\t\tIRs:\n\t\t\tTMP_71(bytes) = INTERNAL_CALL, Address.functionDelegateCall(address,bytes,string)(target,data,Address: low-level delegate call failed)\n\t\t\tRETURN TMP_71\n\tFunction Address.functionDelegateCall(address,bytes,string) (*)\n\t\tExpression: require(bool,string)(isContract(target),Address: delegate call to non-contract)\n\t\tIRs:\n\t\t\tTMP_72(bool) = INTERNAL_CALL, Address.isContract(address)(target)\n\t\t\tTMP_73(None) = SOLIDITY_CALL require(bool,string)(TMP_72,Address: delegate call to non-contract)\n\t\tExpression: (success,returndata) = target.delegatecall(data)\n\t\tIRs:\n\t\t\tTUPLE_3(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:delegatecall, arguments:['data']  \n\t\t\tsuccess(bool)= UNPACK TUPLE_3 index: 0 \n\t\t\treturndata(bytes)= UNPACK TUPLE_3 index: 1 \n\t\tExpression: verifyCallResult(success,returndata,errorMessage)\n\t\tIRs:\n\t\t\tTMP_74(bytes) = INTERNAL_CALL, Address.verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)\n\t\t\tRETURN TMP_74\n\tFunction Address.verifyCallResult(bool,bytes,string) (*)\n\t\tExpression: success\n\t\tIRs:\n\t\t\tCONDITION success\n\t\tExpression: returndata\n\t\tIRs:\n\t\t\tRETURN returndata\n\t\tExpression: returndata.length > 0\n\t\tIRs:\n\t\t\tREF_10 -> LENGTH returndata\n\t\t\tTMP_75(bool) = REF_10 > 0\n\t\t\tCONDITION TMP_75\n\t\tExpression: returndata_size_verifyCallResult_asm_0 = mload(uint256)(returndata)\n\t\tIRs:\n\t\t\tTMP_76(uint256) = SOLIDITY_CALL mload(uint256)(returndata)\n\t\t\treturndata_size_verifyCallResult_asm_0(uint256) := TMP_76(uint256)\n\t\tExpression: revert(uint256,uint256)(32 + returndata,returndata_size_verifyCallResult_asm_0)\n\t\tIRs:\n\t\t\tTMP_77(uint256) = 32 + returndata\n\t\t\tTMP_78(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_77,returndata_size_verifyCallResult_asm_0)\n\t\tExpression: revert(string)(errorMessage)\n\t\tIRs:\n\t\t\tTMP_79(None) = SOLIDITY_CALL revert(string)(errorMessage)\nContract Context\n\tFunction Context._msgSender() (*)\n\t\tExpression: address(msg.sender)\n\t\tIRs:\n\t\t\tTMP_80 = CONVERT msg.sender to address\n\t\t\tRETURN TMP_80\n\tFunction Context._msgData() (*)\n\t\tExpression: this\n\t\tIRs:\n\t\tExpression: msg.data\n\t\tIRs:\n\t\t\tRETURN msg.data\nContract IAccessControl\n\tFunction IAccessControl.hasRole(bytes32,address) (*)\n\tFunction IAccessControl.getRoleAdmin(bytes32) (*)\n\tFunction IAccessControl.grantRole(bytes32,address) (*)\n\tFunction IAccessControl.revokeRole(bytes32,address) (*)\n\tFunction IAccessControl.renounceRole(bytes32,address) (*)\nContract IERC20\n\tFunction IERC20.totalSupply() (*)\n\tFunction IERC20.balanceOf(address) (*)\n\tFunction IERC20.transfer(address,uint256) (*)\n\tFunction IERC20.allowance(address,address) (*)\n\tFunction IERC20.approve(address,uint256) (*)\n\tFunction IERC20.transferFrom(address,address,uint256) (*)\nContract IERC20Detailed\n\tFunction IERC20.totalSupply() (*)\n\tFunction IERC20.balanceOf(address) (*)\n\tFunction IERC20.transfer(address,uint256) (*)\n\tFunction IERC20.allowance(address,address) (*)\n\tFunction IERC20.approve(address,uint256) (*)\n\tFunction IERC20.transferFrom(address,address,uint256) (*)\n\tFunction IERC20Detailed.name() (*)\n\tFunction IERC20Detailed.symbol() (*)\n\tFunction IERC20Detailed.decimals() (*)\nContract SafeCast\n\tFunction SafeCast.toUint224(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint224).max,SafeCast: value doesn't fit in 224 bits)\n\t\tIRs:\n\t\t\tTMP_82(uint224) := 26959946667150639794667015087019630673637144422540572481103610249215(uint224)\n\t\t\tTMP_83(bool) = value <= TMP_82\n\t\t\tTMP_84(None) = SOLIDITY_CALL require(bool,string)(TMP_83,SafeCast: value doesn't fit in 224 bits)\n\t\tExpression: uint224(value)\n\t\tIRs:\n\t\t\tTMP_85 = CONVERT value to uint224\n\t\t\tRETURN TMP_85\n\tFunction SafeCast.toUint128(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint128).max,SafeCast: value doesn't fit in 128 bits)\n\t\tIRs:\n\t\t\tTMP_87(uint128) := 340282366920938463463374607431768211455(uint128)\n\t\t\tTMP_88(bool) = value <= TMP_87\n\t\t\tTMP_89(None) = SOLIDITY_CALL require(bool,string)(TMP_88,SafeCast: value doesn't fit in 128 bits)\n\t\tExpression: uint128(value)\n\t\tIRs:\n\t\t\tTMP_90 = CONVERT value to uint128\n\t\t\tRETURN TMP_90\n\tFunction SafeCast.toUint96(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint96).max,SafeCast: value doesn't fit in 96 bits)\n\t\tIRs:\n\t\t\tTMP_92(uint96) := 79228162514264337593543950335(uint96)\n\t\t\tTMP_93(bool) = value <= TMP_92\n\t\t\tTMP_94(None) = SOLIDITY_CALL require(bool,string)(TMP_93,SafeCast: value doesn't fit in 96 bits)\n\t\tExpression: uint96(value)\n\t\tIRs:\n\t\t\tTMP_95 = CONVERT value to uint96\n\t\t\tRETURN TMP_95\n\tFunction SafeCast.toUint64(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint64).max,SafeCast: value doesn't fit in 64 bits)\n\t\tIRs:\n\t\t\tTMP_97(uint64) := 18446744073709551615(uint64)\n\t\t\tTMP_98(bool) = value <= TMP_97\n\t\t\tTMP_99(None) = SOLIDITY_CALL require(bool,string)(TMP_98,SafeCast: value doesn't fit in 64 bits)\n\t\tExpression: uint64(value)\n\t\tIRs:\n\t\t\tTMP_100 = CONVERT value to uint64\n\t\t\tRETURN TMP_100\n\tFunction SafeCast.toUint32(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint32).max,SafeCast: value doesn't fit in 32 bits)\n\t\tIRs:\n\t\t\tTMP_102(uint32) := 4294967295(uint32)\n\t\t\tTMP_103(bool) = value <= TMP_102\n\t\t\tTMP_104(None) = SOLIDITY_CALL require(bool,string)(TMP_103,SafeCast: value doesn't fit in 32 bits)\n\t\tExpression: uint32(value)\n\t\tIRs:\n\t\t\tTMP_105 = CONVERT value to uint32\n\t\t\tRETURN TMP_105\n\tFunction SafeCast.toUint16(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint16).max,SafeCast: value doesn't fit in 16 bits)\n\t\tIRs:\n\t\t\tTMP_107(uint16) := 65535(uint16)\n\t\t\tTMP_108(bool) = value <= TMP_107\n\t\t\tTMP_109(None) = SOLIDITY_CALL require(bool,string)(TMP_108,SafeCast: value doesn't fit in 16 bits)\n\t\tExpression: uint16(value)\n\t\tIRs:\n\t\t\tTMP_110 = CONVERT value to uint16\n\t\t\tRETURN TMP_110\n\tFunction SafeCast.toUint8(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint8).max,SafeCast: value doesn't fit in 8 bits)\n\t\tIRs:\n\t\t\tTMP_112(uint8) := 255(uint8)\n\t\t\tTMP_113(bool) = value <= TMP_112\n\t\t\tTMP_114(None) = SOLIDITY_CALL require(bool,string)(TMP_113,SafeCast: value doesn't fit in 8 bits)\n\t\tExpression: uint8(value)\n\t\tIRs:\n\t\t\tTMP_115 = CONVERT value to uint8\n\t\t\tRETURN TMP_115\n\tFunction SafeCast.toUint256(int256) (*)\n\t\tExpression: require(bool,string)(value >= 0,SafeCast: value must be positive)\n\t\tIRs:\n\t\t\tTMP_116(bool) = value >= 0\n\t\t\tTMP_117(None) = SOLIDITY_CALL require(bool,string)(TMP_116,SafeCast: value must be positive)\n\t\tExpression: uint256(value)\n\t\tIRs:\n\t\t\tTMP_118 = CONVERT value to uint256\n\t\t\tRETURN TMP_118\n\tFunction SafeCast.toInt128(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int128).min && value <= type()(int128).max,SafeCast: value doesn't fit in 128 bits)\n\t\tIRs:\n\t\t\tTMP_120(int128) := -170141183460469231731687303715884105728(int128)\n\t\t\tTMP_121(bool) = value >= TMP_120\n\t\t\tTMP_123(int128) := 170141183460469231731687303715884105727(int128)\n\t\t\tTMP_124(bool) = value <= TMP_123\n\t\t\tTMP_125(bool) = TMP_121 && TMP_124\n\t\t\tTMP_126(None) = SOLIDITY_CALL require(bool,string)(TMP_125,SafeCast: value doesn't fit in 128 bits)\n\t\tExpression: int128(value)\n\t\tIRs:\n\t\t\tTMP_127 = CONVERT value to int128\n\t\t\tRETURN TMP_127\n\tFunction SafeCast.toInt64(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int64).min && value <= type()(int64).max,SafeCast: value doesn't fit in 64 bits)\n\t\tIRs:\n\t\t\tTMP_129(int64) := -9223372036854775808(int64)\n\t\t\tTMP_130(bool) = value >= TMP_129\n\t\t\tTMP_132(int64) := 9223372036854775807(int64)\n\t\t\tTMP_133(bool) = value <= TMP_132\n\t\t\tTMP_134(bool) = TMP_130 && TMP_133\n\t\t\tTMP_135(None) = SOLIDITY_CALL require(bool,string)(TMP_134,SafeCast: value doesn't fit in 64 bits)\n\t\tExpression: int64(value)\n\t\tIRs:\n\t\t\tTMP_136 = CONVERT value to int64\n\t\t\tRETURN TMP_136\n\tFunction SafeCast.toInt32(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int32).min && value <= type()(int32).max,SafeCast: value doesn't fit in 32 bits)\n\t\tIRs:\n\t\t\tTMP_138(int32) := -2147483648(int32)\n\t\t\tTMP_139(bool) = value >= TMP_138\n\t\t\tTMP_141(int32) := 2147483647(int32)\n\t\t\tTMP_142(bool) = value <= TMP_141\n\t\t\tTMP_143(bool) = TMP_139 && TMP_142\n\t\t\tTMP_144(None) = SOLIDITY_CALL require(bool,string)(TMP_143,SafeCast: value doesn't fit in 32 bits)\n\t\tExpression: int32(value)\n\t\tIRs:\n\t\t\tTMP_145 = CONVERT value to int32\n\t\t\tRETURN TMP_145\n\tFunction SafeCast.toInt16(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int16).min && value <= type()(int16).max,SafeCast: value doesn't fit in 16 bits)\n\t\tIRs:\n\t\t\tTMP_147(int16) := -32768(int16)\n\t\t\tTMP_148(bool) = value >= TMP_147\n\t\t\tTMP_150(int16) := 32767(int16)\n\t\t\tTMP_151(bool) = value <= TMP_150\n\t\t\tTMP_152(bool) = TMP_148 && TMP_151\n\t\t\tTMP_153(None) = SOLIDITY_CALL require(bool,string)(TMP_152,SafeCast: value doesn't fit in 16 bits)\n\t\tExpression: int16(value)\n\t\tIRs:\n\t\t\tTMP_154 = CONVERT value to int16\n\t\t\tRETURN TMP_154\n\tFunction SafeCast.toInt8(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int8).min && value <= type()(int8).max,SafeCast: value doesn't fit in 8 bits)\n\t\tIRs:\n\t\t\tTMP_156(int8) := -128(int8)\n\t\t\tTMP_157(bool) = value >= TMP_156\n\t\t\tTMP_159(int8) := 127(int8)\n\t\t\tTMP_160(bool) = value <= TMP_159\n\t\t\tTMP_161(bool) = TMP_157 && TMP_160\n\t\t\tTMP_162(None) = SOLIDITY_CALL require(bool,string)(TMP_161,SafeCast: value doesn't fit in 8 bits)\n\t\tExpression: int8(value)\n\t\tIRs:\n\t\t\tTMP_163 = CONVERT value to int8\n\t\t\tRETURN TMP_163\n\tFunction SafeCast.toInt256(uint256) (*)\n\t\tExpression: require(bool,string)(value <= uint256(type()(int256).max),SafeCast: value doesn't fit in an int256)\n\t\tIRs:\n\t\t\tTMP_165(int256) := 57896044618658097711785492504343953926634992332820282019728792003956564819967(int256)\n\t\t\tTMP_166 = CONVERT TMP_165 to uint256\n\t\t\tTMP_167(bool) = value <= TMP_166\n\t\t\tTMP_168(None) = SOLIDITY_CALL require(bool,string)(TMP_167,SafeCast: value doesn't fit in an int256)\n\t\tExpression: int256(value)\n\t\tIRs:\n\t\t\tTMP_169 = CONVERT value to int256\n\t\t\tRETURN TMP_169\nContract IFlashLoanReceiver\n\tFunction IFlashLoanReceiver.executeOperation(address[],uint256[],uint256[],address,bytes) (*)\n\tFunction IFlashLoanReceiver.ADDRESSES_PROVIDER() (*)\n\tFunction IFlashLoanReceiver.POOL() (*)\nContract IFlashLoanSimpleReceiver\n\tFunction IFlashLoanSimpleReceiver.executeOperation(address,uint256,uint256,address,bytes) (*)\n\tFunction IFlashLoanSimpleReceiver.ADDRESSES_PROVIDER() (*)\n\tFunction IFlashLoanSimpleReceiver.POOL() (*)\nContract IACLManager\n\tFunction IACLManager.ADDRESSES_PROVIDER() (*)\n\tFunction IACLManager.POOL_ADMIN_ROLE() (*)\n\tFunction IACLManager.EMERGENCY_ADMIN_ROLE() (*)\n\tFunction IACLManager.RISK_ADMIN_ROLE() (*)\n\tFunction IACLManager.FLASH_BORROWER_ROLE() (*)\n\tFunction IACLManager.BRIDGE_ROLE() (*)\n\tFunction IACLManager.ASSET_LISTING_ADMIN_ROLE() (*)\n\tFunction IACLManager.setRoleAdmin(bytes32,bytes32) (*)\n\tFunction IACLManager.addPoolAdmin(address) (*)\n\tFunction IACLManager.removePoolAdmin(address) (*)\n\tFunction IACLManager.isPoolAdmin(address) (*)\n\tFunction IACLManager.addEmergencyAdmin(address) (*)\n\tFunction IACLManager.removeEmergencyAdmin(address) (*)\n\tFunction IACLManager.isEmergencyAdmin(address) (*)\n\tFunction IACLManager.addRiskAdmin(address) (*)\n\tFunction IACLManager.removeRiskAdmin(address) (*)\n\tFunction IACLManager.isRiskAdmin(address) (*)\n\tFunction IACLManager.addFlashBorrower(address) (*)\n\tFunction IACLManager.removeFlashBorrower(address) (*)\n\tFunction IACLManager.isFlashBorrower(address) (*)\n\tFunction IACLManager.addBridge(address) (*)\n\tFunction IACLManager.removeBridge(address) (*)\n\tFunction IACLManager.isBridge(address) (*)\n\tFunction IACLManager.addAssetListingAdmin(address) (*)\n\tFunction IACLManager.removeAssetListingAdmin(address) (*)\n\tFunction IACLManager.isAssetListingAdmin(address) (*)\nContract IAToken\n\tFunction IInitializableAToken.initialize(IPool,address,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\n\tFunction IScaledBalanceToken.scaledBalanceOf(address) (*)\n\tFunction IScaledBalanceToken.getScaledUserBalanceAndSupply(address) (*)\n\tFunction IScaledBalanceToken.scaledTotalSupply() (*)\n\tFunction IScaledBalanceToken.getPreviousIndex(address) (*)\n\tFunction IERC20.totalSupply() (*)\n\tFunction IERC20.balanceOf(address) (*)\n\tFunction IERC20.transfer(address,uint256) (*)\n\tFunction IERC20.allowance(address,address) (*)\n\tFunction IERC20.approve(address,uint256) (*)\n\tFunction IERC20.transferFrom(address,address,uint256) (*)\n\tFunction IAToken.mint(address,address,uint256,uint256) (*)\n\tFunction IAToken.burn(address,address,uint256,uint256) (*)\n\tFunction IAToken.mintToTreasury(uint256,uint256) (*)\n\tFunction IAToken.transferOnLiquidation(address,address,uint256) (*)\n\tFunction IAToken.transferUnderlyingTo(address,uint256) (*)\n\tFunction IAToken.handleRepayment(address,address,uint256) (*)\n\tFunction IAToken.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)\n\tFunction IAToken.UNDERLYING_ASSET_ADDRESS() (*)\n\tFunction IAToken.RESERVE_TREASURY_ADDRESS() (*)\n\tFunction IAToken.DOMAIN_SEPARATOR() (*)\n\tFunction IAToken.nonces(address) (*)\n\tFunction IAToken.rescueTokens(address,address,uint256) (*)\nContract IAaveIncentivesController\n\tFunction IAaveIncentivesController.handleAction(address,uint256,uint256) (*)\nContract IERC20WithPermit\n\tFunction IERC20.totalSupply() (*)\n\tFunction IERC20.balanceOf(address) (*)\n\tFunction IERC20.transfer(address,uint256) (*)\n\tFunction IERC20.allowance(address,address) (*)\n\tFunction IERC20.approve(address,uint256) (*)\n\tFunction IERC20.transferFrom(address,address,uint256) (*)\n\tFunction IERC20WithPermit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)\nContract IInitializableAToken\n\tFunction IInitializableAToken.initialize(IPool,address,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\nContract IInitializableDebtToken\n\tFunction IInitializableDebtToken.initialize(IPool,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\nContract IPool\n\tFunction IPool.mintUnbacked(address,uint256,address,uint16) (*)\n\tFunction IPool.backUnbacked(address,uint256,uint256) (*)\n\tFunction IPool.supply(address,uint256,address,uint16) (*)\n\tFunction IPool.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) (*)\n\tFunction IPool.withdraw(address,uint256,address) (*)\n\tFunction IPool.borrow(address,uint256,uint256,uint16,address) (*)\n\tFunction IPool.repay(address,uint256,uint256,address) (*)\n\tFunction IPool.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) (*)\n\tFunction IPool.repayWithATokens(address,uint256,uint256) (*)\n\tFunction IPool.swapBorrowRateMode(address,uint256) (*)\n\tFunction IPool.rebalanceStableBorrowRate(address,address) (*)\n\tFunction IPool.setUserUseReserveAsCollateral(address,bool) (*)\n\tFunction IPool.liquidationCall(address,address,address,uint256,bool) (*)\n\tFunction IPool.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) (*)\n\tFunction IPool.flashLoanSimple(address,address,uint256,bytes,uint16) (*)\n\tFunction IPool.getUserAccountData(address) (*)\n\tFunction IPool.initReserve(address,address,address,address,address) (*)\n\tFunction IPool.dropReserve(address) (*)\n\tFunction IPool.setReserveInterestRateStrategyAddress(address,address) (*)\n\tFunction IPool.setConfiguration(address,DataTypes.ReserveConfigurationMap) (*)\n\tFunction IPool.getConfiguration(address) (*)\n\tFunction IPool.getUserConfiguration(address) (*)\n\tFunction IPool.getReserveNormalizedIncome(address) (*)\n\tFunction IPool.getReserveNormalizedVariableDebt(address) (*)\n\tFunction IPool.getReserveData(address) (*)\n\tFunction IPool.finalizeTransfer(address,address,address,uint256,uint256,uint256) (*)\n\tFunction IPool.getReservesList() (*)\n\tFunction IPool.getReserveAddressById(uint16) (*)\n\tFunction IPool.ADDRESSES_PROVIDER() (*)\n\tFunction IPool.updateBridgeProtocolFee(uint256) (*)\n\tFunction IPool.updateFlashloanPremiums(uint128,uint128) (*)\n\tFunction IPool.configureEModeCategory(uint8,DataTypes.EModeCategory) (*)\n\tFunction IPool.getEModeCategoryData(uint8) (*)\n\tFunction IPool.setUserEMode(uint8) (*)\n\tFunction IPool.getUserEMode(address) (*)\n\tFunction IPool.resetIsolationModeTotalDebt(address) (*)\n\tFunction IPool.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() (*)\n\tFunction IPool.FLASHLOAN_PREMIUM_TOTAL() (*)\n\tFunction IPool.BRIDGE_PROTOCOL_FEE() (*)\n\tFunction IPool.FLASHLOAN_PREMIUM_TO_PROTOCOL() (*)\n\tFunction IPool.MAX_NUMBER_RESERVES() (*)\n\tFunction IPool.mintToTreasury(address[]) (*)\n\tFunction IPool.rescueTokens(address,address,uint256) (*)\n\tFunction IPool.deposit(address,uint256,address,uint16) (*)\nContract IPoolAddressesProvider\n\tFunction IPoolAddressesProvider.getMarketId() (*)\n\tFunction IPoolAddressesProvider.setMarketId(string) (*)\n\tFunction IPoolAddressesProvider.getAddress(bytes32) (*)\n\tFunction IPoolAddressesProvider.setAddressAsProxy(bytes32,address) (*)\n\tFunction IPoolAddressesProvider.setAddress(bytes32,address) (*)\n\tFunction IPoolAddressesProvider.getPool() (*)\n\tFunction IPoolAddressesProvider.setPoolImpl(address) (*)\n\tFunction IPoolAddressesProvider.getPoolConfigurator() (*)\n\tFunction IPoolAddressesProvider.setPoolConfiguratorImpl(address) (*)\n\tFunction IPoolAddressesProvider.getPriceOracle() (*)\n\tFunction IPoolAddressesProvider.setPriceOracle(address) (*)\n\tFunction IPoolAddressesProvider.getACLManager() (*)\n\tFunction IPoolAddressesProvider.setACLManager(address) (*)\n\tFunction IPoolAddressesProvider.getACLAdmin() (*)\n\tFunction IPoolAddressesProvider.setACLAdmin(address) (*)\n\tFunction IPoolAddressesProvider.getPriceOracleSentinel() (*)\n\tFunction IPoolAddressesProvider.setPriceOracleSentinel(address) (*)\n\tFunction IPoolAddressesProvider.getPoolDataProvider() (*)\n\tFunction IPoolAddressesProvider.setPoolDataProvider(address) (*)\nContract IPriceOracleGetter\n\tFunction IPriceOracleGetter.BASE_CURRENCY() (*)\n\tFunction IPriceOracleGetter.BASE_CURRENCY_UNIT() (*)\n\tFunction IPriceOracleGetter.getAssetPrice(address) (*)\nContract IPriceOracleSentinel\n\tFunction IPriceOracleSentinel.ADDRESSES_PROVIDER() (*)\n\tFunction IPriceOracleSentinel.isBorrowAllowed() (*)\n\tFunction IPriceOracleSentinel.isLiquidationAllowed() (*)\n\tFunction IPriceOracleSentinel.setSequencerOracle(address) (*)\n\tFunction IPriceOracleSentinel.setGracePeriod(uint256) (*)\n\tFunction IPriceOracleSentinel.getSequencerOracle() (*)\n\tFunction IPriceOracleSentinel.getGracePeriod() (*)\nContract IReserveInterestRateStrategy\n\tFunction IReserveInterestRateStrategy.calculateInterestRates(DataTypes.CalculateInterestRatesParams) (*)\nContract IScaledBalanceToken\n\tFunction IScaledBalanceToken.scaledBalanceOf(address) (*)\n\tFunction IScaledBalanceToken.getScaledUserBalanceAndSupply(address) (*)\n\tFunction IScaledBalanceToken.scaledTotalSupply() (*)\n\tFunction IScaledBalanceToken.getPreviousIndex(address) (*)\nContract IStableDebtToken\n\tFunction IInitializableDebtToken.initialize(IPool,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\n\tFunction IStableDebtToken.mint(address,address,uint256,uint256) (*)\n\tFunction IStableDebtToken.burn(address,uint256) (*)\n\tFunction IStableDebtToken.getAverageStableRate() (*)\n\tFunction IStableDebtToken.getUserStableRate(address) (*)\n\tFunction IStableDebtToken.getUserLastUpdated(address) (*)\n\tFunction IStableDebtToken.getSupplyData() (*)\n\tFunction IStableDebtToken.getTotalSupplyLastUpdated() (*)\n\tFunction IStableDebtToken.getTotalSupplyAndAvgRate() (*)\n\tFunction IStableDebtToken.principalBalanceOf(address) (*)\n\tFunction IStableDebtToken.UNDERLYING_ASSET_ADDRESS() (*)\nContract IVariableDebtToken\n\tFunction IInitializableDebtToken.initialize(IPool,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\n\tFunction IScaledBalanceToken.scaledBalanceOf(address) (*)\n\tFunction IScaledBalanceToken.getScaledUserBalanceAndSupply(address) (*)\n\tFunction IScaledBalanceToken.scaledTotalSupply() (*)\n\tFunction IScaledBalanceToken.getPreviousIndex(address) (*)\n\tFunction IVariableDebtToken.mint(address,address,uint256,uint256) (*)\n\tFunction IVariableDebtToken.burn(address,uint256,uint256) (*)\n\tFunction IVariableDebtToken.UNDERLYING_ASSET_ADDRESS() (*)\nContract VersionedInitializable\n\tFunction VersionedInitializable.getRevision() (*)\n\tFunction VersionedInitializable.isConstructor() (*)\n\t\tExpression: cs = extcodesize(uint256)(address()())\n\t\tIRs:\n\t\t\tTMP_170 = CONVERT this to address\n\t\t\tREF_11 -> CODESIZE TMP_170\n\t\t\tcs(uint256) := REF_11(uint256)\n\t\tExpression: cs == 0\n\t\tIRs:\n\t\t\tTMP_171(bool) = cs == 0\n\t\t\tRETURN TMP_171\n\tFunction VersionedInitializable.slitherConstructorVariables() (*)\n\t\tExpression: lastInitializedRevision = 0\n\t\tIRs:\n\t\t\tlastInitializedRevision(uint256) := 0(uint256)\n\tModifier VersionedInitializable.initializer()\n\t\tExpression: revision = getRevision()\n\t\tIRs:\n\t\t\tTMP_172(uint256) = INTERNAL_CALL, VersionedInitializable.getRevision()()\n\t\t\trevision(uint256) := TMP_172(uint256)\n\t\tExpression: require(bool,string)(initializing || isConstructor() || revision > lastInitializedRevision,Contract instance has already been initialized)\n\t\tIRs:\n\t\t\tTMP_173(bool) = INTERNAL_CALL, VersionedInitializable.isConstructor()()\n\t\t\tTMP_174(bool) = initializing || TMP_173\n\t\t\tTMP_175(bool) = revision > lastInitializedRevision\n\t\t\tTMP_176(bool) = TMP_174 || TMP_175\n\t\t\tTMP_177(None) = SOLIDITY_CALL require(bool,string)(TMP_176,Contract instance has already been initialized)\n\t\tExpression: isTopLevelCall = ! initializing\n\t\tIRs:\n\t\t\tTMP_178 = UnaryType.BANG initializing \n\t\t\tisTopLevelCall(bool) := TMP_178(bool)\n\t\tExpression: isTopLevelCall\n\t\tIRs:\n\t\t\tCONDITION isTopLevelCall\n\t\tExpression: initializing = true\n\t\tIRs:\n\t\t\tinitializing(bool) := True(bool)\n\t\tExpression: lastInitializedRevision = revision\n\t\tIRs:\n\t\t\tlastInitializedRevision(uint256) := revision(uint256)\n\t\tExpression: isTopLevelCall\n\t\tIRs:\n\t\t\tCONDITION isTopLevelCall\n\t\tExpression: initializing = false\n\t\tIRs:\n\t\t\tinitializing(bool) := False(bool)\nContract ReserveConfiguration\n\tFunction ReserveConfiguration.setLtv(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(ltv <= MAX_VALID_LTV,Errors.INVALID_LTV)\n\t\tIRs:\n\t\t\tTMP_179(bool) = ltv <= MAX_VALID_LTV\n\t\t\tREF_12(string) -> Errors.INVALID_LTV\n\t\t\tTMP_180(None) = SOLIDITY_CALL require(bool,string)(TMP_179,REF_12)\n\t\tExpression: self.data = (self.data & LTV_MASK) | ltv\n\t\tIRs:\n\t\t\tREF_13(uint256) -> self.data\n\t\t\tREF_14(uint256) -> self.data\n\t\t\tTMP_181(uint256) = REF_14 & LTV_MASK\n\t\t\tTMP_182(uint256) = TMP_181 | ltv\n\t\t\tREF_13(uint256) (->self) := TMP_182(uint256)\n\tFunction ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: self.data & ~ LTV_MASK\n\t\tIRs:\n\t\t\tREF_15(uint256) -> self.data\n\t\t\tTMP_183 = UnaryType.TILD LTV_MASK \n\t\t\tTMP_184(uint256) = REF_15 & TMP_183\n\t\t\tRETURN TMP_184\n\tFunction ReserveConfiguration.setLiquidationThreshold(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD,Errors.INVALID_LIQ_THRESHOLD)\n\t\tIRs:\n\t\t\tTMP_185(bool) = threshold <= MAX_VALID_LIQUIDATION_THRESHOLD\n\t\t\tREF_16(string) -> Errors.INVALID_LIQ_THRESHOLD\n\t\t\tTMP_186(None) = SOLIDITY_CALL require(bool,string)(TMP_185,REF_16)\n\t\tExpression: self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_17(uint256) -> self.data\n\t\t\tREF_18(uint256) -> self.data\n\t\t\tTMP_187(uint256) = REF_18 & LIQUIDATION_THRESHOLD_MASK\n\t\t\tTMP_188(uint256) = threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION\n\t\t\tTMP_189(uint256) = TMP_187 | TMP_188\n\t\t\tREF_17(uint256) (->self) := TMP_189(uint256)\n\tFunction ReserveConfiguration.getLiquidationThreshold(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_19(uint256) -> self.data\n\t\t\tTMP_190 = UnaryType.TILD LIQUIDATION_THRESHOLD_MASK \n\t\t\tTMP_191(uint256) = REF_19 & TMP_190\n\t\t\tTMP_192(uint256) = TMP_191 >> LIQUIDATION_THRESHOLD_START_BIT_POSITION\n\t\t\tRETURN TMP_192\n\tFunction ReserveConfiguration.setLiquidationBonus(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(bonus <= MAX_VALID_LIQUIDATION_BONUS,Errors.INVALID_LIQ_BONUS)\n\t\tIRs:\n\t\t\tTMP_193(bool) = bonus <= MAX_VALID_LIQUIDATION_BONUS\n\t\t\tREF_20(string) -> Errors.INVALID_LIQ_BONUS\n\t\t\tTMP_194(None) = SOLIDITY_CALL require(bool,string)(TMP_193,REF_20)\n\t\tExpression: self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_21(uint256) -> self.data\n\t\t\tREF_22(uint256) -> self.data\n\t\t\tTMP_195(uint256) = REF_22 & LIQUIDATION_BONUS_MASK\n\t\t\tTMP_196(uint256) = bonus << LIQUIDATION_BONUS_START_BIT_POSITION\n\t\t\tTMP_197(uint256) = TMP_195 | TMP_196\n\t\t\tREF_21(uint256) (->self) := TMP_197(uint256)\n\tFunction ReserveConfiguration.getLiquidationBonus(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_23(uint256) -> self.data\n\t\t\tTMP_198 = UnaryType.TILD LIQUIDATION_BONUS_MASK \n\t\t\tTMP_199(uint256) = REF_23 & TMP_198\n\t\t\tTMP_200(uint256) = TMP_199 >> LIQUIDATION_BONUS_START_BIT_POSITION\n\t\t\tRETURN TMP_200\n\tFunction ReserveConfiguration.setDecimals(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(decimals <= MAX_VALID_DECIMALS,Errors.INVALID_DECIMALS)\n\t\tIRs:\n\t\t\tTMP_201(bool) = decimals <= MAX_VALID_DECIMALS\n\t\t\tREF_24(string) -> Errors.INVALID_DECIMALS\n\t\t\tTMP_202(None) = SOLIDITY_CALL require(bool,string)(TMP_201,REF_24)\n\t\tExpression: self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_25(uint256) -> self.data\n\t\t\tREF_26(uint256) -> self.data\n\t\t\tTMP_203(uint256) = REF_26 & DECIMALS_MASK\n\t\t\tTMP_204(uint256) = decimals << RESERVE_DECIMALS_START_BIT_POSITION\n\t\t\tTMP_205(uint256) = TMP_203 | TMP_204\n\t\t\tREF_25(uint256) (->self) := TMP_205(uint256)\n\tFunction ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_27(uint256) -> self.data\n\t\t\tTMP_206 = UnaryType.TILD DECIMALS_MASK \n\t\t\tTMP_207(uint256) = REF_27 & TMP_206\n\t\t\tTMP_208(uint256) = TMP_207 >> RESERVE_DECIMALS_START_BIT_POSITION\n\t\t\tRETURN TMP_208\n\tFunction ReserveConfiguration.setActive(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: active\n\t\tIRs:\n\t\t\tCONDITION active\n\t\tExpression: self.data = (self.data & ACTIVE_MASK) | (uint256(1) << IS_ACTIVE_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_28(uint256) -> self.data\n\t\t\tREF_29(uint256) -> self.data\n\t\t\tTMP_209(uint256) = REF_29 & ACTIVE_MASK\n\t\t\tTMP_210 = CONVERT 1 to uint256\n\t\t\tTMP_211(uint256) = TMP_210 << IS_ACTIVE_START_BIT_POSITION\n\t\t\tTMP_212(uint256) = TMP_209 | TMP_211\n\t\t\tREF_28(uint256) (->self) := TMP_212(uint256)\n\t\tExpression: self.data = (self.data & ACTIVE_MASK) | (uint256(0) << IS_ACTIVE_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_30(uint256) -> self.data\n\t\t\tREF_31(uint256) -> self.data\n\t\t\tTMP_213(uint256) = REF_31 & ACTIVE_MASK\n\t\t\tTMP_214 = CONVERT 0 to uint256\n\t\t\tTMP_215(uint256) = TMP_214 << IS_ACTIVE_START_BIT_POSITION\n\t\t\tTMP_216(uint256) = TMP_213 | TMP_215\n\t\t\tREF_30(uint256) (->self) := TMP_216(uint256)\n\tFunction ReserveConfiguration.getActive(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ ACTIVE_MASK) != 0\n\t\tIRs:\n\t\t\tREF_32(uint256) -> self.data\n\t\t\tTMP_217 = UnaryType.TILD ACTIVE_MASK \n\t\t\tTMP_218(uint256) = REF_32 & TMP_217\n\t\t\tTMP_219(bool) = TMP_218 != 0\n\t\t\tRETURN TMP_219\n\tFunction ReserveConfiguration.setFrozen(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: frozen\n\t\tIRs:\n\t\t\tCONDITION frozen\n\t\tExpression: self.data = (self.data & FROZEN_MASK) | (uint256(1) << IS_FROZEN_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_33(uint256) -> self.data\n\t\t\tREF_34(uint256) -> self.data\n\t\t\tTMP_220(uint256) = REF_34 & FROZEN_MASK\n\t\t\tTMP_221 = CONVERT 1 to uint256\n\t\t\tTMP_222(uint256) = TMP_221 << IS_FROZEN_START_BIT_POSITION\n\t\t\tTMP_223(uint256) = TMP_220 | TMP_222\n\t\t\tREF_33(uint256) (->self) := TMP_223(uint256)\n\t\tExpression: self.data = (self.data & FROZEN_MASK) | (uint256(0) << IS_FROZEN_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_35(uint256) -> self.data\n\t\t\tREF_36(uint256) -> self.data\n\t\t\tTMP_224(uint256) = REF_36 & FROZEN_MASK\n\t\t\tTMP_225 = CONVERT 0 to uint256\n\t\t\tTMP_226(uint256) = TMP_225 << IS_FROZEN_START_BIT_POSITION\n\t\t\tTMP_227(uint256) = TMP_224 | TMP_226\n\t\t\tREF_35(uint256) (->self) := TMP_227(uint256)\n\tFunction ReserveConfiguration.getFrozen(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ FROZEN_MASK) != 0\n\t\tIRs:\n\t\t\tREF_37(uint256) -> self.data\n\t\t\tTMP_228 = UnaryType.TILD FROZEN_MASK \n\t\t\tTMP_229(uint256) = REF_37 & TMP_228\n\t\t\tTMP_230(bool) = TMP_229 != 0\n\t\t\tRETURN TMP_230\n\tFunction ReserveConfiguration.setPaused(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: paused\n\t\tIRs:\n\t\t\tCONDITION paused\n\t\tExpression: self.data = (self.data & PAUSED_MASK) | (uint256(1) << IS_PAUSED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_38(uint256) -> self.data\n\t\t\tREF_39(uint256) -> self.data\n\t\t\tTMP_231(uint256) = REF_39 & PAUSED_MASK\n\t\t\tTMP_232 = CONVERT 1 to uint256\n\t\t\tTMP_233(uint256) = TMP_232 << IS_PAUSED_START_BIT_POSITION\n\t\t\tTMP_234(uint256) = TMP_231 | TMP_233\n\t\t\tREF_38(uint256) (->self) := TMP_234(uint256)\n\t\tExpression: self.data = (self.data & PAUSED_MASK) | (uint256(0) << IS_PAUSED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_40(uint256) -> self.data\n\t\t\tREF_41(uint256) -> self.data\n\t\t\tTMP_235(uint256) = REF_41 & PAUSED_MASK\n\t\t\tTMP_236 = CONVERT 0 to uint256\n\t\t\tTMP_237(uint256) = TMP_236 << IS_PAUSED_START_BIT_POSITION\n\t\t\tTMP_238(uint256) = TMP_235 | TMP_237\n\t\t\tREF_40(uint256) (->self) := TMP_238(uint256)\n\tFunction ReserveConfiguration.getPaused(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ PAUSED_MASK) != 0\n\t\tIRs:\n\t\t\tREF_42(uint256) -> self.data\n\t\t\tTMP_239 = UnaryType.TILD PAUSED_MASK \n\t\t\tTMP_240(uint256) = REF_42 & TMP_239\n\t\t\tTMP_241(bool) = TMP_240 != 0\n\t\t\tRETURN TMP_241\n\tFunction ReserveConfiguration.setBorrowableInIsolation(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: borrowable\n\t\tIRs:\n\t\t\tCONDITION borrowable\n\t\tExpression: self.data = (self.data & BORROWABLE_IN_ISOLATION_MASK) | (uint256(1) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_43(uint256) -> self.data\n\t\t\tREF_44(uint256) -> self.data\n\t\t\tTMP_242(uint256) = REF_44 & BORROWABLE_IN_ISOLATION_MASK\n\t\t\tTMP_243 = CONVERT 1 to uint256\n\t\t\tTMP_244(uint256) = TMP_243 << BORROWABLE_IN_ISOLATION_START_BIT_POSITION\n\t\t\tTMP_245(uint256) = TMP_242 | TMP_244\n\t\t\tREF_43(uint256) (->self) := TMP_245(uint256)\n\t\tExpression: self.data = (self.data & BORROWABLE_IN_ISOLATION_MASK) | (uint256(0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_45(uint256) -> self.data\n\t\t\tREF_46(uint256) -> self.data\n\t\t\tTMP_246(uint256) = REF_46 & BORROWABLE_IN_ISOLATION_MASK\n\t\t\tTMP_247 = CONVERT 0 to uint256\n\t\t\tTMP_248(uint256) = TMP_247 << BORROWABLE_IN_ISOLATION_START_BIT_POSITION\n\t\t\tTMP_249(uint256) = TMP_246 | TMP_248\n\t\t\tREF_45(uint256) (->self) := TMP_249(uint256)\n\tFunction ReserveConfiguration.getBorrowableInIsolation(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ BORROWABLE_IN_ISOLATION_MASK) != 0\n\t\tIRs:\n\t\t\tREF_47(uint256) -> self.data\n\t\t\tTMP_250 = UnaryType.TILD BORROWABLE_IN_ISOLATION_MASK \n\t\t\tTMP_251(uint256) = REF_47 & TMP_250\n\t\t\tTMP_252(bool) = TMP_251 != 0\n\t\t\tRETURN TMP_252\n\tFunction ReserveConfiguration.setSiloedBorrowing(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: siloed\n\t\tIRs:\n\t\t\tCONDITION siloed\n\t\tExpression: self.data = (self.data & SILOED_BORROWING_MASK) | (uint256(1) << SILOED_BORROWING_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_48(uint256) -> self.data\n\t\t\tREF_49(uint256) -> self.data\n\t\t\tTMP_253(uint256) = REF_49 & SILOED_BORROWING_MASK\n\t\t\tTMP_254 = CONVERT 1 to uint256\n\t\t\tTMP_255(uint256) = TMP_254 << SILOED_BORROWING_START_BIT_POSITION\n\t\t\tTMP_256(uint256) = TMP_253 | TMP_255\n\t\t\tREF_48(uint256) (->self) := TMP_256(uint256)\n\t\tExpression: self.data = (self.data & SILOED_BORROWING_MASK) | (uint256(0) << SILOED_BORROWING_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_50(uint256) -> self.data\n\t\t\tREF_51(uint256) -> self.data\n\t\t\tTMP_257(uint256) = REF_51 & SILOED_BORROWING_MASK\n\t\t\tTMP_258 = CONVERT 0 to uint256\n\t\t\tTMP_259(uint256) = TMP_258 << SILOED_BORROWING_START_BIT_POSITION\n\t\t\tTMP_260(uint256) = TMP_257 | TMP_259\n\t\t\tREF_50(uint256) (->self) := TMP_260(uint256)\n\tFunction ReserveConfiguration.getSiloedBorrowing(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ SILOED_BORROWING_MASK) != 0\n\t\tIRs:\n\t\t\tREF_52(uint256) -> self.data\n\t\t\tTMP_261 = UnaryType.TILD SILOED_BORROWING_MASK \n\t\t\tTMP_262(uint256) = REF_52 & TMP_261\n\t\t\tTMP_263(bool) = TMP_262 != 0\n\t\t\tRETURN TMP_263\n\tFunction ReserveConfiguration.setBorrowingEnabled(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: enabled\n\t\tIRs:\n\t\t\tCONDITION enabled\n\t\tExpression: self.data = (self.data & BORROWING_MASK) | (uint256(1) << BORROWING_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_53(uint256) -> self.data\n\t\t\tREF_54(uint256) -> self.data\n\t\t\tTMP_264(uint256) = REF_54 & BORROWING_MASK\n\t\t\tTMP_265 = CONVERT 1 to uint256\n\t\t\tTMP_266(uint256) = TMP_265 << BORROWING_ENABLED_START_BIT_POSITION\n\t\t\tTMP_267(uint256) = TMP_264 | TMP_266\n\t\t\tREF_53(uint256) (->self) := TMP_267(uint256)\n\t\tExpression: self.data = (self.data & BORROWING_MASK) | (uint256(0) << BORROWING_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_55(uint256) -> self.data\n\t\t\tREF_56(uint256) -> self.data\n\t\t\tTMP_268(uint256) = REF_56 & BORROWING_MASK\n\t\t\tTMP_269 = CONVERT 0 to uint256\n\t\t\tTMP_270(uint256) = TMP_269 << BORROWING_ENABLED_START_BIT_POSITION\n\t\t\tTMP_271(uint256) = TMP_268 | TMP_270\n\t\t\tREF_55(uint256) (->self) := TMP_271(uint256)\n\tFunction ReserveConfiguration.getBorrowingEnabled(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ BORROWING_MASK) != 0\n\t\tIRs:\n\t\t\tREF_57(uint256) -> self.data\n\t\t\tTMP_272 = UnaryType.TILD BORROWING_MASK \n\t\t\tTMP_273(uint256) = REF_57 & TMP_272\n\t\t\tTMP_274(bool) = TMP_273 != 0\n\t\t\tRETURN TMP_274\n\tFunction ReserveConfiguration.setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: enabled\n\t\tIRs:\n\t\t\tCONDITION enabled\n\t\tExpression: self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(1) << STABLE_BORROWING_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_58(uint256) -> self.data\n\t\t\tREF_59(uint256) -> self.data\n\t\t\tTMP_275(uint256) = REF_59 & STABLE_BORROWING_MASK\n\t\t\tTMP_276 = CONVERT 1 to uint256\n\t\t\tTMP_277(uint256) = TMP_276 << STABLE_BORROWING_ENABLED_START_BIT_POSITION\n\t\t\tTMP_278(uint256) = TMP_275 | TMP_277\n\t\t\tREF_58(uint256) (->self) := TMP_278(uint256)\n\t\tExpression: self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_60(uint256) -> self.data\n\t\t\tREF_61(uint256) -> self.data\n\t\t\tTMP_279(uint256) = REF_61 & STABLE_BORROWING_MASK\n\t\t\tTMP_280 = CONVERT 0 to uint256\n\t\t\tTMP_281(uint256) = TMP_280 << STABLE_BORROWING_ENABLED_START_BIT_POSITION\n\t\t\tTMP_282(uint256) = TMP_279 | TMP_281\n\t\t\tREF_60(uint256) (->self) := TMP_282(uint256)\n\tFunction ReserveConfiguration.getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ STABLE_BORROWING_MASK) != 0\n\t\tIRs:\n\t\t\tREF_62(uint256) -> self.data\n\t\t\tTMP_283 = UnaryType.TILD STABLE_BORROWING_MASK \n\t\t\tTMP_284(uint256) = REF_62 & TMP_283\n\t\t\tTMP_285(bool) = TMP_284 != 0\n\t\t\tRETURN TMP_285\n\tFunction ReserveConfiguration.setReserveFactor(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(reserveFactor <= MAX_VALID_RESERVE_FACTOR,Errors.INVALID_RESERVE_FACTOR)\n\t\tIRs:\n\t\t\tTMP_286(bool) = reserveFactor <= MAX_VALID_RESERVE_FACTOR\n\t\t\tREF_63(string) -> Errors.INVALID_RESERVE_FACTOR\n\t\t\tTMP_287(None) = SOLIDITY_CALL require(bool,string)(TMP_286,REF_63)\n\t\tExpression: self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_64(uint256) -> self.data\n\t\t\tREF_65(uint256) -> self.data\n\t\t\tTMP_288(uint256) = REF_65 & RESERVE_FACTOR_MASK\n\t\t\tTMP_289(uint256) = reserveFactor << RESERVE_FACTOR_START_BIT_POSITION\n\t\t\tTMP_290(uint256) = TMP_288 | TMP_289\n\t\t\tREF_64(uint256) (->self) := TMP_290(uint256)\n\tFunction ReserveConfiguration.getReserveFactor(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_66(uint256) -> self.data\n\t\t\tTMP_291 = UnaryType.TILD RESERVE_FACTOR_MASK \n\t\t\tTMP_292(uint256) = REF_66 & TMP_291\n\t\t\tTMP_293(uint256) = TMP_292 >> RESERVE_FACTOR_START_BIT_POSITION\n\t\t\tRETURN TMP_293\n\tFunction ReserveConfiguration.setBorrowCap(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(borrowCap <= MAX_VALID_BORROW_CAP,Errors.INVALID_BORROW_CAP)\n\t\tIRs:\n\t\t\tTMP_294(bool) = borrowCap <= MAX_VALID_BORROW_CAP\n\t\t\tREF_67(string) -> Errors.INVALID_BORROW_CAP\n\t\t\tTMP_295(None) = SOLIDITY_CALL require(bool,string)(TMP_294,REF_67)\n\t\tExpression: self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_68(uint256) -> self.data\n\t\t\tREF_69(uint256) -> self.data\n\t\t\tTMP_296(uint256) = REF_69 & BORROW_CAP_MASK\n\t\t\tTMP_297(uint256) = borrowCap << BORROW_CAP_START_BIT_POSITION\n\t\t\tTMP_298(uint256) = TMP_296 | TMP_297\n\t\t\tREF_68(uint256) (->self) := TMP_298(uint256)\n\tFunction ReserveConfiguration.getBorrowCap(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_70(uint256) -> self.data\n\t\t\tTMP_299 = UnaryType.TILD BORROW_CAP_MASK \n\t\t\tTMP_300(uint256) = REF_70 & TMP_299\n\t\t\tTMP_301(uint256) = TMP_300 >> BORROW_CAP_START_BIT_POSITION\n\t\t\tRETURN TMP_301\n\tFunction ReserveConfiguration.setSupplyCap(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(supplyCap <= MAX_VALID_SUPPLY_CAP,Errors.INVALID_SUPPLY_CAP)\n\t\tIRs:\n\t\t\tTMP_302(bool) = supplyCap <= MAX_VALID_SUPPLY_CAP\n\t\t\tREF_71(string) -> Errors.INVALID_SUPPLY_CAP\n\t\t\tTMP_303(None) = SOLIDITY_CALL require(bool,string)(TMP_302,REF_71)\n\t\tExpression: self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_72(uint256) -> self.data\n\t\t\tREF_73(uint256) -> self.data\n\t\t\tTMP_304(uint256) = REF_73 & SUPPLY_CAP_MASK\n\t\t\tTMP_305(uint256) = supplyCap << SUPPLY_CAP_START_BIT_POSITION\n\t\t\tTMP_306(uint256) = TMP_304 | TMP_305\n\t\t\tREF_72(uint256) (->self) := TMP_306(uint256)\n\tFunction ReserveConfiguration.getSupplyCap(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_74(uint256) -> self.data\n\t\t\tTMP_307 = UnaryType.TILD SUPPLY_CAP_MASK \n\t\t\tTMP_308(uint256) = REF_74 & TMP_307\n\t\t\tTMP_309(uint256) = TMP_308 >> SUPPLY_CAP_START_BIT_POSITION\n\t\t\tRETURN TMP_309\n\tFunction ReserveConfiguration.setDebtCeiling(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(ceiling <= MAX_VALID_DEBT_CEILING,Errors.INVALID_DEBT_CEILING)\n\t\tIRs:\n\t\t\tTMP_310(bool) = ceiling <= MAX_VALID_DEBT_CEILING\n\t\t\tREF_75(string) -> Errors.INVALID_DEBT_CEILING\n\t\t\tTMP_311(None) = SOLIDITY_CALL require(bool,string)(TMP_310,REF_75)\n\t\tExpression: self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_76(uint256) -> self.data\n\t\t\tREF_77(uint256) -> self.data\n\t\t\tTMP_312(uint256) = REF_77 & DEBT_CEILING_MASK\n\t\t\tTMP_313(uint256) = ceiling << DEBT_CEILING_START_BIT_POSITION\n\t\t\tTMP_314(uint256) = TMP_312 | TMP_313\n\t\t\tREF_76(uint256) (->self) := TMP_314(uint256)\n\tFunction ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_78(uint256) -> self.data\n\t\t\tTMP_315 = UnaryType.TILD DEBT_CEILING_MASK \n\t\t\tTMP_316(uint256) = REF_78 & TMP_315\n\t\t\tTMP_317(uint256) = TMP_316 >> DEBT_CEILING_START_BIT_POSITION\n\t\t\tRETURN TMP_317\n\tFunction ReserveConfiguration.setLiquidationProtocolFee(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,Errors.INVALID_LIQUIDATION_PROTOCOL_FEE)\n\t\tIRs:\n\t\t\tTMP_318(bool) = liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE\n\t\t\tREF_79(string) -> Errors.INVALID_LIQUIDATION_PROTOCOL_FEE\n\t\t\tTMP_319(None) = SOLIDITY_CALL require(bool,string)(TMP_318,REF_79)\n\t\tExpression: self.data = (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) | (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_80(uint256) -> self.data\n\t\t\tREF_81(uint256) -> self.data\n\t\t\tTMP_320(uint256) = REF_81 & LIQUIDATION_PROTOCOL_FEE_MASK\n\t\t\tTMP_321(uint256) = liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION\n\t\t\tTMP_322(uint256) = TMP_320 | TMP_321\n\t\t\tREF_80(uint256) (->self) := TMP_322(uint256)\n\tFunction ReserveConfiguration.getLiquidationProtocolFee(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_82(uint256) -> self.data\n\t\t\tTMP_323 = UnaryType.TILD LIQUIDATION_PROTOCOL_FEE_MASK \n\t\t\tTMP_324(uint256) = REF_82 & TMP_323\n\t\t\tTMP_325(uint256) = TMP_324 >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION\n\t\t\tRETURN TMP_325\n\tFunction ReserveConfiguration.setUnbackedMintCap(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP,Errors.INVALID_UNBACKED_MINT_CAP)\n\t\tIRs:\n\t\t\tTMP_326(bool) = unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP\n\t\t\tREF_83(string) -> Errors.INVALID_UNBACKED_MINT_CAP\n\t\t\tTMP_327(None) = SOLIDITY_CALL require(bool,string)(TMP_326,REF_83)\n\t\tExpression: self.data = (self.data & UNBACKED_MINT_CAP_MASK) | (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_84(uint256) -> self.data\n\t\t\tREF_85(uint256) -> self.data\n\t\t\tTMP_328(uint256) = REF_85 & UNBACKED_MINT_CAP_MASK\n\t\t\tTMP_329(uint256) = unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION\n\t\t\tTMP_330(uint256) = TMP_328 | TMP_329\n\t\t\tREF_84(uint256) (->self) := TMP_330(uint256)\n\tFunction ReserveConfiguration.getUnbackedMintCap(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_86(uint256) -> self.data\n\t\t\tTMP_331 = UnaryType.TILD UNBACKED_MINT_CAP_MASK \n\t\t\tTMP_332(uint256) = REF_86 & TMP_331\n\t\t\tTMP_333(uint256) = TMP_332 >> UNBACKED_MINT_CAP_START_BIT_POSITION\n\t\t\tRETURN TMP_333\n\tFunction ReserveConfiguration.setEModeCategory(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(category <= MAX_VALID_EMODE_CATEGORY,Errors.INVALID_EMODE_CATEGORY)\n\t\tIRs:\n\t\t\tTMP_334(bool) = category <= MAX_VALID_EMODE_CATEGORY\n\t\t\tREF_87(string) -> Errors.INVALID_EMODE_CATEGORY\n\t\t\tTMP_335(None) = SOLIDITY_CALL require(bool,string)(TMP_334,REF_87)\n\t\tExpression: self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_88(uint256) -> self.data\n\t\t\tREF_89(uint256) -> self.data\n\t\t\tTMP_336(uint256) = REF_89 & EMODE_CATEGORY_MASK\n\t\t\tTMP_337(uint256) = category << EMODE_CATEGORY_START_BIT_POSITION\n\t\t\tTMP_338(uint256) = TMP_336 | TMP_337\n\t\t\tREF_88(uint256) (->self) := TMP_338(uint256)\n\tFunction ReserveConfiguration.getEModeCategory(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_90(uint256) -> self.data\n\t\t\tTMP_339 = UnaryType.TILD EMODE_CATEGORY_MASK \n\t\t\tTMP_340(uint256) = REF_90 & TMP_339\n\t\t\tTMP_341(uint256) = TMP_340 >> EMODE_CATEGORY_START_BIT_POSITION\n\t\t\tRETURN TMP_341\n\tFunction ReserveConfiguration.setFlashLoanEnabled(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: flashLoanEnabled\n\t\tIRs:\n\t\t\tCONDITION flashLoanEnabled\n\t\tExpression: self.data = (self.data & FLASHLOAN_ENABLED_MASK) | (uint256(1) << FLASHLOAN_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_91(uint256) -> self.data\n\t\t\tREF_92(uint256) -> self.data\n\t\t\tTMP_342(uint256) = REF_92 & FLASHLOAN_ENABLED_MASK\n\t\t\tTMP_343 = CONVERT 1 to uint256\n\t\t\tTMP_344(uint256) = TMP_343 << FLASHLOAN_ENABLED_START_BIT_POSITION\n\t\t\tTMP_345(uint256) = TMP_342 | TMP_344\n\t\t\tREF_91(uint256) (->self) := TMP_345(uint256)\n\t\tExpression: self.data = (self.data & FLASHLOAN_ENABLED_MASK) | (uint256(0) << FLASHLOAN_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_93(uint256) -> self.data\n\t\t\tREF_94(uint256) -> self.data\n\t\t\tTMP_346(uint256) = REF_94 & FLASHLOAN_ENABLED_MASK\n\t\t\tTMP_347 = CONVERT 0 to uint256\n\t\t\tTMP_348(uint256) = TMP_347 << FLASHLOAN_ENABLED_START_BIT_POSITION\n\t\t\tTMP_349(uint256) = TMP_346 | TMP_348\n\t\t\tREF_93(uint256) (->self) := TMP_349(uint256)\n\tFunction ReserveConfiguration.getFlashLoanEnabled(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ FLASHLOAN_ENABLED_MASK) != 0\n\t\tIRs:\n\t\t\tREF_95(uint256) -> self.data\n\t\t\tTMP_350 = UnaryType.TILD FLASHLOAN_ENABLED_MASK \n\t\t\tTMP_351(uint256) = REF_95 & TMP_350\n\t\t\tTMP_352(bool) = TMP_351 != 0\n\t\t\tRETURN TMP_352\n\tFunction ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: dataLocal = self.data\n\t\tIRs:\n\t\t\tREF_96(uint256) -> self.data\n\t\t\tdataLocal(uint256) := REF_96(uint256)\n\t\tExpression: ((dataLocal & ~ ACTIVE_MASK) != 0,(dataLocal & ~ FROZEN_MASK) != 0,(dataLocal & ~ BORROWING_MASK) != 0,(dataLocal & ~ STABLE_BORROWING_MASK) != 0,(dataLocal & ~ PAUSED_MASK) != 0)\n\t\tIRs:\n\t\t\tTMP_353 = UnaryType.TILD ACTIVE_MASK \n\t\t\tTMP_354(uint256) = dataLocal & TMP_353\n\t\t\tTMP_355(bool) = TMP_354 != 0\n\t\t\tTMP_356 = UnaryType.TILD FROZEN_MASK \n\t\t\tTMP_357(uint256) = dataLocal & TMP_356\n\t\t\tTMP_358(bool) = TMP_357 != 0\n\t\t\tTMP_359 = UnaryType.TILD BORROWING_MASK \n\t\t\tTMP_360(uint256) = dataLocal & TMP_359\n\t\t\tTMP_361(bool) = TMP_360 != 0\n\t\t\tTMP_362 = UnaryType.TILD STABLE_BORROWING_MASK \n\t\t\tTMP_363(uint256) = dataLocal & TMP_362\n\t\t\tTMP_364(bool) = TMP_363 != 0\n\t\t\tTMP_365 = UnaryType.TILD PAUSED_MASK \n\t\t\tTMP_366(uint256) = dataLocal & TMP_365\n\t\t\tTMP_367(bool) = TMP_366 != 0\n\t\t\tRETURN TMP_355,TMP_358,TMP_361,TMP_364,TMP_367\n\tFunction ReserveConfiguration.getParams(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: dataLocal = self.data\n\t\tIRs:\n\t\t\tREF_97(uint256) -> self.data\n\t\t\tdataLocal(uint256) := REF_97(uint256)\n\t\tExpression: (dataLocal & ~ LTV_MASK,(dataLocal & ~ LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,(dataLocal & ~ LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,(dataLocal & ~ DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,(dataLocal & ~ RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,(dataLocal & ~ EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tTMP_368 = UnaryType.TILD LTV_MASK \n\t\t\tTMP_369(uint256) = dataLocal & TMP_368\n\t\t\tTMP_370 = UnaryType.TILD LIQUIDATION_THRESHOLD_MASK \n\t\t\tTMP_371(uint256) = dataLocal & TMP_370\n\t\t\tTMP_372(uint256) = TMP_371 >> LIQUIDATION_THRESHOLD_START_BIT_POSITION\n\t\t\tTMP_373 = UnaryType.TILD LIQUIDATION_BONUS_MASK \n\t\t\tTMP_374(uint256) = dataLocal & TMP_373\n\t\t\tTMP_375(uint256) = TMP_374 >> LIQUIDATION_BONUS_START_BIT_POSITION\n\t\t\tTMP_376 = UnaryType.TILD DECIMALS_MASK \n\t\t\tTMP_377(uint256) = dataLocal & TMP_376\n\t\t\tTMP_378(uint256) = TMP_377 >> RESERVE_DECIMALS_START_BIT_POSITION\n\t\t\tTMP_379 = UnaryType.TILD RESERVE_FACTOR_MASK \n\t\t\tTMP_380(uint256) = dataLocal & TMP_379\n\t\t\tTMP_381(uint256) = TMP_380 >> RESERVE_FACTOR_START_BIT_POSITION\n\t\t\tTMP_382 = UnaryType.TILD EMODE_CATEGORY_MASK \n\t\t\tTMP_383(uint256) = dataLocal & TMP_382\n\t\t\tTMP_384(uint256) = TMP_383 >> EMODE_CATEGORY_START_BIT_POSITION\n\t\t\tRETURN TMP_369,TMP_372,TMP_375,TMP_378,TMP_381,TMP_384\n\tFunction ReserveConfiguration.getCaps(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: dataLocal = self.data\n\t\tIRs:\n\t\t\tREF_98(uint256) -> self.data\n\t\t\tdataLocal(uint256) := REF_98(uint256)\n\t\tExpression: ((dataLocal & ~ BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,(dataLocal & ~ SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tTMP_385 = UnaryType.TILD BORROW_CAP_MASK \n\t\t\tTMP_386(uint256) = dataLocal & TMP_385\n\t\t\tTMP_387(uint256) = TMP_386 >> BORROW_CAP_START_BIT_POSITION\n\t\t\tTMP_388 = UnaryType.TILD SUPPLY_CAP_MASK \n\t\t\tTMP_389(uint256) = dataLocal & TMP_388\n\t\t\tTMP_390(uint256) = TMP_389 >> SUPPLY_CAP_START_BIT_POSITION\n\t\t\tRETURN TMP_387,TMP_390\n\tFunction ReserveConfiguration.slitherConstructorConstantVariables() (*)\n\t\tExpression: LTV_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000\n\t\tIRs:\n\t\t\tLTV_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129574400(uint256)\n\t\tExpression: LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF\n\t\tIRs:\n\t\t\tLIQUIDATION_THRESHOLD_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457584007908834738175(uint256)\n\t\tExpression: LIQUIDATION_BONUS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF\n\t\tIRs:\n\t\t\tLIQUIDATION_BONUS_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457583726442447896575(uint256)\n\t\tExpression: DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF\n\t\tIRs:\n\t\t\tDECIMALS_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457512231794068422655(uint256)\n\t\tExpression: ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tACTIVE_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457511950319091711999(uint256)\n\t\tExpression: FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tFROZEN_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457439892725053784063(uint256)\n\t\tExpression: BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tBORROWING_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457295777536977928191(uint256)\n\t\tExpression: STABLE_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tSTABLE_BORROWING_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457007547160826216447(uint256)\n\t\tExpression: PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tPAUSED_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039456431086408522792959(uint256)\n\t\tExpression: BORROWABLE_IN_ISOLATION_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tBORROWABLE_IN_ISOLATION_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039455278164903915945983(uint256)\n\t\tExpression: SILOED_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tSILOED_BORROWING_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039452972321894702252031(uint256)\n\t\tExpression: FLASHLOAN_ENABLED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tFLASHLOAN_ENABLED_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039448360635876274864127(uint256)\n\t\tExpression: RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tRESERVE_FACTOR_MASK(uint256) := 115792089237316195423570985008687907853269984665640562830550211137357664485375(uint256)\n\t\tExpression: BORROW_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tBORROW_CAP_MASK(uint256) := 115792089237316195423570985008687907853269901588890828691141347134601036824575(uint256)\n\t\tExpression: SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tSUPPLY_CAP_MASK(uint256) := 115792089237316195423570985008682198862499243902866067452821842515308866174975(uint256)\n\t\tExpression: LIQUIDATION_PROTOCOL_FEE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tLIQUIDATION_PROTOCOL_FEE_MASK(uint256) := 115792089237316195423570984634549197687329661445021480007966928956539929624575(uint256)\n\t\tExpression: EMODE_CATEGORY_MASK = 0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tEMODE_CATEGORY_MASK(uint256) := 115792089237316195423570889601861022891927484329094684320502060868636724166655(uint256)\n\t\tExpression: UNBACKED_MINT_CAP_MASK = 0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tUNBACKED_MINT_CAP_MASK(uint256) := 115792089237309613405341795965490592094593402660309829990319025859654871678975(uint256)\n\t\tExpression: DEBT_CEILING_MASK = 0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tDEBT_CEILING_MASK(uint256) := 108555083659990515227827083269813533489170840026057959730454019326871953473535(uint256)\n\t\tExpression: LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16\n\t\tIRs:\n\t\t\tLIQUIDATION_THRESHOLD_START_BIT_POSITION(uint256) := 16(uint256)\n\t\tExpression: LIQUIDATION_BONUS_START_BIT_POSITION = 32\n\t\tIRs:\n\t\t\tLIQUIDATION_BONUS_START_BIT_POSITION(uint256) := 32(uint256)\n\t\tExpression: RESERVE_DECIMALS_START_BIT_POSITION = 48\n\t\tIRs:\n\t\t\tRESERVE_DECIMALS_START_BIT_POSITION(uint256) := 48(uint256)\n\t\tExpression: IS_ACTIVE_START_BIT_POSITION = 56\n\t\tIRs:\n\t\t\tIS_ACTIVE_START_BIT_POSITION(uint256) := 56(uint256)\n\t\tExpression: IS_FROZEN_START_BIT_POSITION = 57\n\t\tIRs:\n\t\t\tIS_FROZEN_START_BIT_POSITION(uint256) := 57(uint256)\n\t\tExpression: BORROWING_ENABLED_START_BIT_POSITION = 58\n\t\tIRs:\n\t\t\tBORROWING_ENABLED_START_BIT_POSITION(uint256) := 58(uint256)\n\t\tExpression: STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59\n\t\tIRs:\n\t\t\tSTABLE_BORROWING_ENABLED_START_BIT_POSITION(uint256) := 59(uint256)\n\t\tExpression: IS_PAUSED_START_BIT_POSITION = 60\n\t\tIRs:\n\t\t\tIS_PAUSED_START_BIT_POSITION(uint256) := 60(uint256)\n\t\tExpression: BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61\n\t\tIRs:\n\t\t\tBORROWABLE_IN_ISOLATION_START_BIT_POSITION(uint256) := 61(uint256)\n\t\tExpression: SILOED_BORROWING_START_BIT_POSITION = 62\n\t\tIRs:\n\t\t\tSILOED_BORROWING_START_BIT_POSITION(uint256) := 62(uint256)\n\t\tExpression: FLASHLOAN_ENABLED_START_BIT_POSITION = 63\n\t\tIRs:\n\t\t\tFLASHLOAN_ENABLED_START_BIT_POSITION(uint256) := 63(uint256)\n\t\tExpression: RESERVE_FACTOR_START_BIT_POSITION = 64\n\t\tIRs:\n\t\t\tRESERVE_FACTOR_START_BIT_POSITION(uint256) := 64(uint256)\n\t\tExpression: BORROW_CAP_START_BIT_POSITION = 80\n\t\tIRs:\n\t\t\tBORROW_CAP_START_BIT_POSITION(uint256) := 80(uint256)\n\t\tExpression: SUPPLY_CAP_START_BIT_POSITION = 116\n\t\tIRs:\n\t\t\tSUPPLY_CAP_START_BIT_POSITION(uint256) := 116(uint256)\n\t\tExpression: LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152\n\t\tIRs:\n\t\t\tLIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION(uint256) := 152(uint256)\n\t\tExpression: EMODE_CATEGORY_START_BIT_POSITION = 168\n\t\tIRs:\n\t\t\tEMODE_CATEGORY_START_BIT_POSITION(uint256) := 168(uint256)\n\t\tExpression: UNBACKED_MINT_CAP_START_BIT_POSITION = 176\n\t\tIRs:\n\t\t\tUNBACKED_MINT_CAP_START_BIT_POSITION(uint256) := 176(uint256)\n\t\tExpression: DEBT_CEILING_START_BIT_POSITION = 212\n\t\tIRs:\n\t\t\tDEBT_CEILING_START_BIT_POSITION(uint256) := 212(uint256)\n\t\tExpression: MAX_VALID_LTV = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_LTV(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_LIQUIDATION_THRESHOLD = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_LIQUIDATION_THRESHOLD(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_LIQUIDATION_BONUS = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_LIQUIDATION_BONUS(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_DECIMALS = 255\n\t\tIRs:\n\t\t\tMAX_VALID_DECIMALS(uint256) := 255(uint256)\n\t\tExpression: MAX_VALID_RESERVE_FACTOR = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_RESERVE_FACTOR(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_BORROW_CAP = 68719476735\n\t\tIRs:\n\t\t\tMAX_VALID_BORROW_CAP(uint256) := 68719476735(uint256)\n\t\tExpression: MAX_VALID_SUPPLY_CAP = 68719476735\n\t\tIRs:\n\t\t\tMAX_VALID_SUPPLY_CAP(uint256) := 68719476735(uint256)\n\t\tExpression: MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_LIQUIDATION_PROTOCOL_FEE(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_EMODE_CATEGORY = 255\n\t\tIRs:\n\t\t\tMAX_VALID_EMODE_CATEGORY(uint256) := 255(uint256)\n\t\tExpression: MAX_VALID_UNBACKED_MINT_CAP = 68719476735\n\t\tIRs:\n\t\t\tMAX_VALID_UNBACKED_MINT_CAP(uint256) := 68719476735(uint256)\n\t\tExpression: MAX_VALID_DEBT_CEILING = 1099511627775\n\t\tIRs:\n\t\t\tMAX_VALID_DEBT_CEILING(uint256) := 1099511627775(uint256)\n\t\tExpression: DEBT_CEILING_DECIMALS = 2\n\t\tIRs:\n\t\t\tDEBT_CEILING_DECIMALS(uint256) := 2(uint256)\n\t\tExpression: MAX_RESERVES_COUNT = 128\n\t\tIRs:\n\t\t\tMAX_RESERVES_COUNT(uint16) := 128(uint256)\nContract UserConfiguration\n\tFunction UserConfiguration.setBorrowing(DataTypes.UserConfigurationMap,uint256,bool) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_99(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_391(bool) = reserveIndex < REF_99\n\t\t\tREF_100(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_392(None) = SOLIDITY_CALL require(bool,string)(TMP_391,REF_100)\n\t\tExpression: bit = 1 << (reserveIndex << 1)\n\t\tIRs:\n\t\t\tTMP_393(uint256) = reserveIndex << 1\n\t\t\tTMP_394(uint256) = 1 << TMP_393\n\t\t\tbit(uint256) := TMP_394(uint256)\n\t\tExpression: borrowing\n\t\tIRs:\n\t\t\tCONDITION borrowing\n\t\tExpression: self.data |= bit\n\t\tIRs:\n\t\t\tREF_101(uint256) -> self.data\n\t\t\tREF_101(-> self) = REF_101 | bit\n\t\tExpression: self.data &= ~ bit\n\t\tIRs:\n\t\t\tREF_102(uint256) -> self.data\n\t\t\tTMP_395 = UnaryType.TILD bit \n\t\t\tREF_102(-> self) = REF_102 & TMP_395\n\tFunction UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_103(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_396(bool) = reserveIndex < REF_103\n\t\t\tREF_104(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_397(None) = SOLIDITY_CALL require(bool,string)(TMP_396,REF_104)\n\t\tExpression: bit = 1 << ((reserveIndex << 1) + 1)\n\t\tIRs:\n\t\t\tTMP_398(uint256) = reserveIndex << 1\n\t\t\tTMP_399(uint256) = TMP_398 + 1\n\t\t\tTMP_400(uint256) = 1 << TMP_399\n\t\t\tbit(uint256) := TMP_400(uint256)\n\t\tExpression: usingAsCollateral\n\t\tIRs:\n\t\t\tCONDITION usingAsCollateral\n\t\tExpression: self.data |= bit\n\t\tIRs:\n\t\t\tREF_105(uint256) -> self.data\n\t\t\tREF_105(-> self) = REF_105 | bit\n\t\tExpression: self.data &= ~ bit\n\t\tIRs:\n\t\t\tREF_106(uint256) -> self.data\n\t\t\tTMP_401 = UnaryType.TILD bit \n\t\t\tREF_106(-> self) = REF_106 & TMP_401\n\tFunction UserConfiguration.isUsingAsCollateralOrBorrowing(DataTypes.UserConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_107(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_402(bool) = reserveIndex < REF_107\n\t\t\tREF_108(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_403(None) = SOLIDITY_CALL require(bool,string)(TMP_402,REF_108)\n\t\tExpression: (self.data >> (reserveIndex << 1)) & 3 != 0\n\t\tIRs:\n\t\t\tREF_109(uint256) -> self.data\n\t\t\tTMP_404(uint256) = reserveIndex << 1\n\t\t\tTMP_405(uint256) = REF_109 >> TMP_404\n\t\t\tTMP_406(uint256) = TMP_405 & 3\n\t\t\tTMP_407(bool) = TMP_406 != 0\n\t\t\tRETURN TMP_407\n\tFunction UserConfiguration.isBorrowing(DataTypes.UserConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_110(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_408(bool) = reserveIndex < REF_110\n\t\t\tREF_111(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_409(None) = SOLIDITY_CALL require(bool,string)(TMP_408,REF_111)\n\t\tExpression: (self.data >> (reserveIndex << 1)) & 1 != 0\n\t\tIRs:\n\t\t\tREF_112(uint256) -> self.data\n\t\t\tTMP_410(uint256) = reserveIndex << 1\n\t\t\tTMP_411(uint256) = REF_112 >> TMP_410\n\t\t\tTMP_412(uint256) = TMP_411 & 1\n\t\t\tTMP_413(bool) = TMP_412 != 0\n\t\t\tRETURN TMP_413\n\tFunction UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_113(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_414(bool) = reserveIndex < REF_113\n\t\t\tREF_114(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_415(None) = SOLIDITY_CALL require(bool,string)(TMP_414,REF_114)\n\t\tExpression: (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0\n\t\tIRs:\n\t\t\tREF_115(uint256) -> self.data\n\t\t\tTMP_416(uint256) = reserveIndex << 1\n\t\t\tTMP_417(uint256) = TMP_416 + 1\n\t\t\tTMP_418(uint256) = REF_115 >> TMP_417\n\t\t\tTMP_419(uint256) = TMP_418 & 1\n\t\t\tTMP_420(bool) = TMP_419 != 0\n\t\t\tRETURN TMP_420\n\tFunction UserConfiguration.isUsingAsCollateralOne(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: collateralData = self.data & COLLATERAL_MASK\n\t\tIRs:\n\t\t\tREF_116(uint256) -> self.data\n\t\t\tTMP_421(uint256) = REF_116 & COLLATERAL_MASK\n\t\t\tcollateralData(uint256) := TMP_421(uint256)\n\t\tExpression: collateralData != 0 && (collateralData & (collateralData - 1) == 0)\n\t\tIRs:\n\t\t\tTMP_422(bool) = collateralData != 0\n\t\t\tTMP_423(uint256) = collateralData (c)- 1\n\t\t\tTMP_424(uint256) = collateralData & TMP_423\n\t\t\tTMP_425(bool) = TMP_424 == 0\n\t\t\tTMP_426(bool) = TMP_422 && TMP_425\n\t\t\tRETURN TMP_426\n\tFunction UserConfiguration.isUsingAsCollateralAny(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: self.data & COLLATERAL_MASK != 0\n\t\tIRs:\n\t\t\tREF_117(uint256) -> self.data\n\t\t\tTMP_427(uint256) = REF_117 & COLLATERAL_MASK\n\t\t\tTMP_428(bool) = TMP_427 != 0\n\t\t\tRETURN TMP_428\n\tFunction UserConfiguration.isBorrowingOne(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: borrowingData = self.data & BORROWING_MASK\n\t\tIRs:\n\t\t\tREF_118(uint256) -> self.data\n\t\t\tTMP_429(uint256) = REF_118 & BORROWING_MASK\n\t\t\tborrowingData(uint256) := TMP_429(uint256)\n\t\tExpression: borrowingData != 0 && (borrowingData & (borrowingData - 1) == 0)\n\t\tIRs:\n\t\t\tTMP_430(bool) = borrowingData != 0\n\t\t\tTMP_431(uint256) = borrowingData (c)- 1\n\t\t\tTMP_432(uint256) = borrowingData & TMP_431\n\t\t\tTMP_433(bool) = TMP_432 == 0\n\t\t\tTMP_434(bool) = TMP_430 && TMP_433\n\t\t\tRETURN TMP_434\n\tFunction UserConfiguration.isBorrowingAny(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: self.data & BORROWING_MASK != 0\n\t\tIRs:\n\t\t\tREF_119(uint256) -> self.data\n\t\t\tTMP_435(uint256) = REF_119 & BORROWING_MASK\n\t\t\tTMP_436(bool) = TMP_435 != 0\n\t\t\tRETURN TMP_436\n\tFunction UserConfiguration.isEmpty(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: self.data == 0\n\t\tIRs:\n\t\t\tREF_120(uint256) -> self.data\n\t\t\tTMP_437(bool) = REF_120 == 0\n\t\t\tRETURN TMP_437\n\tFunction UserConfiguration.getIsolationModeState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)) (*)\n\t\tExpression: isUsingAsCollateralOne(self)\n\t\tIRs:\n\t\t\tTMP_438(bool) = INTERNAL_CALL, UserConfiguration.isUsingAsCollateralOne(DataTypes.UserConfigurationMap)(self)\n\t\t\tCONDITION TMP_438\n\t\tExpression: assetId = _getFirstAssetIdByMask(self,COLLATERAL_MASK)\n\t\tIRs:\n\t\t\tTMP_439(uint256) = INTERNAL_CALL, UserConfiguration._getFirstAssetIdByMask(DataTypes.UserConfigurationMap,uint256)(self,COLLATERAL_MASK)\n\t\t\tassetId(uint256) := TMP_439(uint256)\n\t\tExpression: assetAddress = reservesList[assetId]\n\t\tIRs:\n\t\t\tREF_121(address) -> reservesList[assetId]\n\t\t\tassetAddress(address) := REF_121(address)\n\t\tExpression: ceiling = reservesData[assetAddress].configuration.getDebtCeiling()\n\t\tIRs:\n\t\t\tREF_122(DataTypes.ReserveData) -> reservesData[assetAddress]\n\t\t\tREF_123(DataTypes.ReserveConfigurationMap) -> REF_122.configuration\n\t\t\tTMP_440(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap), arguments:['REF_123'] \n\t\t\tceiling(uint256) := TMP_440(uint256)\n\t\tExpression: ceiling != 0\n\t\tIRs:\n\t\t\tTMP_441(bool) = ceiling != 0\n\t\t\tCONDITION TMP_441\n\t\tExpression: (true,assetAddress,ceiling)\n\t\tIRs:\n\t\t\tRETURN True,assetAddress,ceiling\n\t\tExpression: (false,address(0),0)\n\t\tIRs:\n\t\t\tTMP_442 = CONVERT 0 to address\n\t\t\tRETURN False,TMP_442,0\n\tFunction UserConfiguration.getSiloedBorrowingState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)) (*)\n\t\tExpression: isBorrowingOne(self)\n\t\tIRs:\n\t\t\tTMP_443(bool) = INTERNAL_CALL, UserConfiguration.isBorrowingOne(DataTypes.UserConfigurationMap)(self)\n\t\t\tCONDITION TMP_443\n\t\tExpression: assetId = _getFirstAssetIdByMask(self,BORROWING_MASK)\n\t\tIRs:\n\t\t\tTMP_444(uint256) = INTERNAL_CALL, UserConfiguration._getFirstAssetIdByMask(DataTypes.UserConfigurationMap,uint256)(self,BORROWING_MASK)\n\t\t\tassetId(uint256) := TMP_444(uint256)\n\t\tExpression: assetAddress = reservesList[assetId]\n\t\tIRs:\n\t\t\tREF_125(address) -> reservesList[assetId]\n\t\t\tassetAddress(address) := REF_125(address)\n\t\tExpression: reservesData[assetAddress].configuration.getSiloedBorrowing()\n\t\tIRs:\n\t\t\tREF_126(DataTypes.ReserveData) -> reservesData[assetAddress]\n\t\t\tREF_127(DataTypes.ReserveConfigurationMap) -> REF_126.configuration\n\t\t\tTMP_445(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getSiloedBorrowing(DataTypes.ReserveConfigurationMap), arguments:['REF_127'] \n\t\t\tCONDITION TMP_445\n\t\tExpression: (true,assetAddress)\n\t\tIRs:\n\t\t\tRETURN True,assetAddress\n\t\tExpression: (false,address(0))\n\t\tIRs:\n\t\t\tTMP_446 = CONVERT 0 to address\n\t\t\tRETURN False,TMP_446\n\tFunction UserConfiguration._getFirstAssetIdByMask(DataTypes.UserConfigurationMap,uint256) (*)\n\t\tExpression: bitmapData = self.data & mask\n\t\tIRs:\n\t\t\tREF_129(uint256) -> self.data\n\t\t\tTMP_447(uint256) = REF_129 & mask\n\t\t\tbitmapData(uint256) := TMP_447(uint256)\n\t\tExpression: firstAssetPosition = bitmapData & ~ (bitmapData - 1)\n\t\tIRs:\n\t\t\tTMP_448(uint256) = bitmapData - 1\n\t\t\tTMP_449 = UnaryType.TILD TMP_448 \n\t\t\tTMP_450(uint256) = bitmapData & TMP_449\n\t\t\tfirstAssetPosition(uint256) := TMP_450(uint256)\n\t\tExpression: (firstAssetPosition >>= 2) != 0\n\t\tIRs:\n\t\t\tfirstAssetPosition(uint256) = firstAssetPosition >> 2\n\t\t\tTMP_451(bool) = firstAssetPosition != 0\n\t\t\tCONDITION TMP_451\n\t\tExpression: id += 1\n\t\tIRs:\n\t\t\tid(uint256) = id + 1\n\t\tExpression: id\n\t\tIRs:\n\t\t\tRETURN id\n\tFunction UserConfiguration.slitherConstructorConstantVariables() (*)\n\t\tExpression: BORROWING_MASK = 0x5555555555555555555555555555555555555555555555555555555555555555\n\t\tIRs:\n\t\t\tBORROWING_MASK(uint256) := 38597363079105398474523661669562635951089994888546854679819194669304376546645(uint256)\n\t\tExpression: COLLATERAL_MASK = 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\t\tIRs:\n\t\t\tCOLLATERAL_MASK(uint256) := 77194726158210796949047323339125271902179989777093709359638389338608753093290(uint256)\nContract Errors\n\tFunction Errors.slitherConstructorConstantVariables() (*)\n\t\tExpression: CALLER_NOT_POOL_ADMIN = 1\n\t\tIRs:\n\t\t\tCALLER_NOT_POOL_ADMIN(string) := 1(string)\n\t\tExpression: CALLER_NOT_EMERGENCY_ADMIN = 2\n\t\tIRs:\n\t\t\tCALLER_NOT_EMERGENCY_ADMIN(string) := 2(string)\n\t\tExpression: CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = 3\n\t\tIRs:\n\t\t\tCALLER_NOT_POOL_OR_EMERGENCY_ADMIN(string) := 3(string)\n\t\tExpression: CALLER_NOT_RISK_OR_POOL_ADMIN = 4\n\t\tIRs:\n\t\t\tCALLER_NOT_RISK_OR_POOL_ADMIN(string) := 4(string)\n\t\tExpression: CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = 5\n\t\tIRs:\n\t\t\tCALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN(string) := 5(string)\n\t\tExpression: CALLER_NOT_BRIDGE = 6\n\t\tIRs:\n\t\t\tCALLER_NOT_BRIDGE(string) := 6(string)\n\t\tExpression: ADDRESSES_PROVIDER_NOT_REGISTERED = 7\n\t\tIRs:\n\t\t\tADDRESSES_PROVIDER_NOT_REGISTERED(string) := 7(string)\n\t\tExpression: INVALID_ADDRESSES_PROVIDER_ID = 8\n\t\tIRs:\n\t\t\tINVALID_ADDRESSES_PROVIDER_ID(string) := 8(string)\n\t\tExpression: NOT_CONTRACT = 9\n\t\tIRs:\n\t\t\tNOT_CONTRACT(string) := 9(string)\n\t\tExpression: CALLER_NOT_POOL_CONFIGURATOR = 10\n\t\tIRs:\n\t\t\tCALLER_NOT_POOL_CONFIGURATOR(string) := 10(string)\n\t\tExpression: CALLER_NOT_ATOKEN = 11\n\t\tIRs:\n\t\t\tCALLER_NOT_ATOKEN(string) := 11(string)\n\t\tExpression: INVALID_ADDRESSES_PROVIDER = 12\n\t\tIRs:\n\t\t\tINVALID_ADDRESSES_PROVIDER(string) := 12(string)\n\t\tExpression: INVALID_FLASHLOAN_EXECUTOR_RETURN = 13\n\t\tIRs:\n\t\t\tINVALID_FLASHLOAN_EXECUTOR_RETURN(string) := 13(string)\n\t\tExpression: RESERVE_ALREADY_ADDED = 14\n\t\tIRs:\n\t\t\tRESERVE_ALREADY_ADDED(string) := 14(string)\n\t\tExpression: NO_MORE_RESERVES_ALLOWED = 15\n\t\tIRs:\n\t\t\tNO_MORE_RESERVES_ALLOWED(string) := 15(string)\n\t\tExpression: EMODE_CATEGORY_RESERVED = 16\n\t\tIRs:\n\t\t\tEMODE_CATEGORY_RESERVED(string) := 16(string)\n\t\tExpression: INVALID_EMODE_CATEGORY_ASSIGNMENT = 17\n\t\tIRs:\n\t\t\tINVALID_EMODE_CATEGORY_ASSIGNMENT(string) := 17(string)\n\t\tExpression: RESERVE_LIQUIDITY_NOT_ZERO = 18\n\t\tIRs:\n\t\t\tRESERVE_LIQUIDITY_NOT_ZERO(string) := 18(string)\n\t\tExpression: FLASHLOAN_PREMIUM_INVALID = 19\n\t\tIRs:\n\t\t\tFLASHLOAN_PREMIUM_INVALID(string) := 19(string)\n\t\tExpression: INVALID_RESERVE_PARAMS = 20\n\t\tIRs:\n\t\t\tINVALID_RESERVE_PARAMS(string) := 20(string)\n\t\tExpression: INVALID_EMODE_CATEGORY_PARAMS = 21\n\t\tIRs:\n\t\t\tINVALID_EMODE_CATEGORY_PARAMS(string) := 21(string)\n\t\tExpression: BRIDGE_PROTOCOL_FEE_INVALID = 22\n\t\tIRs:\n\t\t\tBRIDGE_PROTOCOL_FEE_INVALID(string) := 22(string)\n\t\tExpression: CALLER_MUST_BE_POOL = 23\n\t\tIRs:\n\t\t\tCALLER_MUST_BE_POOL(string) := 23(string)\n\t\tExpression: INVALID_MINT_AMOUNT = 24\n\t\tIRs:\n\t\t\tINVALID_MINT_AMOUNT(string) := 24(string)\n\t\tExpression: INVALID_BURN_AMOUNT = 25\n\t\tIRs:\n\t\t\tINVALID_BURN_AMOUNT(string) := 25(string)\n\t\tExpression: INVALID_AMOUNT = 26\n\t\tIRs:\n\t\t\tINVALID_AMOUNT(string) := 26(string)\n\t\tExpression: RESERVE_INACTIVE = 27\n\t\tIRs:\n\t\t\tRESERVE_INACTIVE(string) := 27(string)\n\t\tExpression: RESERVE_FROZEN = 28\n\t\tIRs:\n\t\t\tRESERVE_FROZEN(string) := 28(string)\n\t\tExpression: RESERVE_PAUSED = 29\n\t\tIRs:\n\t\t\tRESERVE_PAUSED(string) := 29(string)\n\t\tExpression: BORROWING_NOT_ENABLED = 30\n\t\tIRs:\n\t\t\tBORROWING_NOT_ENABLED(string) := 30(string)\n\t\tExpression: STABLE_BORROWING_NOT_ENABLED = 31\n\t\tIRs:\n\t\t\tSTABLE_BORROWING_NOT_ENABLED(string) := 31(string)\n\t\tExpression: NOT_ENOUGH_AVAILABLE_USER_BALANCE = 32\n\t\tIRs:\n\t\t\tNOT_ENOUGH_AVAILABLE_USER_BALANCE(string) := 32(string)\n\t\tExpression: INVALID_INTEREST_RATE_MODE_SELECTED = 33\n\t\tIRs:\n\t\t\tINVALID_INTEREST_RATE_MODE_SELECTED(string) := 33(string)\n\t\tExpression: COLLATERAL_BALANCE_IS_ZERO = 34\n\t\tIRs:\n\t\t\tCOLLATERAL_BALANCE_IS_ZERO(string) := 34(string)\n\t\tExpression: HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = 35\n\t\tIRs:\n\t\t\tHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD(string) := 35(string)\n\t\tExpression: COLLATERAL_CANNOT_COVER_NEW_BORROW = 36\n\t\tIRs:\n\t\t\tCOLLATERAL_CANNOT_COVER_NEW_BORROW(string) := 36(string)\n\t\tExpression: COLLATERAL_SAME_AS_BORROWING_CURRENCY = 37\n\t\tIRs:\n\t\t\tCOLLATERAL_SAME_AS_BORROWING_CURRENCY(string) := 37(string)\n\t\tExpression: AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = 38\n\t\tIRs:\n\t\t\tAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE(string) := 38(string)\n\t\tExpression: NO_DEBT_OF_SELECTED_TYPE = 39\n\t\tIRs:\n\t\t\tNO_DEBT_OF_SELECTED_TYPE(string) := 39(string)\n\t\tExpression: NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = 40\n\t\tIRs:\n\t\t\tNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF(string) := 40(string)\n\t\tExpression: NO_OUTSTANDING_STABLE_DEBT = 41\n\t\tIRs:\n\t\t\tNO_OUTSTANDING_STABLE_DEBT(string) := 41(string)\n\t\tExpression: NO_OUTSTANDING_VARIABLE_DEBT = 42\n\t\tIRs:\n\t\t\tNO_OUTSTANDING_VARIABLE_DEBT(string) := 42(string)\n\t\tExpression: UNDERLYING_BALANCE_ZERO = 43\n\t\tIRs:\n\t\t\tUNDERLYING_BALANCE_ZERO(string) := 43(string)\n\t\tExpression: INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = 44\n\t\tIRs:\n\t\t\tINTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET(string) := 44(string)\n\t\tExpression: HEALTH_FACTOR_NOT_BELOW_THRESHOLD = 45\n\t\tIRs:\n\t\t\tHEALTH_FACTOR_NOT_BELOW_THRESHOLD(string) := 45(string)\n\t\tExpression: COLLATERAL_CANNOT_BE_LIQUIDATED = 46\n\t\tIRs:\n\t\t\tCOLLATERAL_CANNOT_BE_LIQUIDATED(string) := 46(string)\n\t\tExpression: SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = 47\n\t\tIRs:\n\t\t\tSPECIFIED_CURRENCY_NOT_BORROWED_BY_USER(string) := 47(string)\n\t\tExpression: INCONSISTENT_FLASHLOAN_PARAMS = 49\n\t\tIRs:\n\t\t\tINCONSISTENT_FLASHLOAN_PARAMS(string) := 49(string)\n\t\tExpression: BORROW_CAP_EXCEEDED = 50\n\t\tIRs:\n\t\t\tBORROW_CAP_EXCEEDED(string) := 50(string)\n\t\tExpression: SUPPLY_CAP_EXCEEDED = 51\n\t\tIRs:\n\t\t\tSUPPLY_CAP_EXCEEDED(string) := 51(string)\n\t\tExpression: UNBACKED_MINT_CAP_EXCEEDED = 52\n\t\tIRs:\n\t\t\tUNBACKED_MINT_CAP_EXCEEDED(string) := 52(string)\n\t\tExpression: DEBT_CEILING_EXCEEDED = 53\n\t\tIRs:\n\t\t\tDEBT_CEILING_EXCEEDED(string) := 53(string)\n\t\tExpression: UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = 54\n\t\tIRs:\n\t\t\tUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO(string) := 54(string)\n\t\tExpression: STABLE_DEBT_NOT_ZERO = 55\n\t\tIRs:\n\t\t\tSTABLE_DEBT_NOT_ZERO(string) := 55(string)\n\t\tExpression: VARIABLE_DEBT_SUPPLY_NOT_ZERO = 56\n\t\tIRs:\n\t\t\tVARIABLE_DEBT_SUPPLY_NOT_ZERO(string) := 56(string)\n\t\tExpression: LTV_VALIDATION_FAILED = 57\n\t\tIRs:\n\t\t\tLTV_VALIDATION_FAILED(string) := 57(string)\n\t\tExpression: INCONSISTENT_EMODE_CATEGORY = 58\n\t\tIRs:\n\t\t\tINCONSISTENT_EMODE_CATEGORY(string) := 58(string)\n\t\tExpression: PRICE_ORACLE_SENTINEL_CHECK_FAILED = 59\n\t\tIRs:\n\t\t\tPRICE_ORACLE_SENTINEL_CHECK_FAILED(string) := 59(string)\n\t\tExpression: ASSET_NOT_BORROWABLE_IN_ISOLATION = 60\n\t\tIRs:\n\t\t\tASSET_NOT_BORROWABLE_IN_ISOLATION(string) := 60(string)\n\t\tExpression: RESERVE_ALREADY_INITIALIZED = 61\n\t\tIRs:\n\t\t\tRESERVE_ALREADY_INITIALIZED(string) := 61(string)\n\t\tExpression: USER_IN_ISOLATION_MODE_OR_LTV_ZERO = 62\n\t\tIRs:\n\t\t\tUSER_IN_ISOLATION_MODE_OR_LTV_ZERO(string) := 62(string)\n\t\tExpression: INVALID_LTV = 63\n\t\tIRs:\n\t\t\tINVALID_LTV(string) := 63(string)\n\t\tExpression: INVALID_LIQ_THRESHOLD = 64\n\t\tIRs:\n\t\t\tINVALID_LIQ_THRESHOLD(string) := 64(string)\n\t\tExpression: INVALID_LIQ_BONUS = 65\n\t\tIRs:\n\t\t\tINVALID_LIQ_BONUS(string) := 65(string)\n\t\tExpression: INVALID_DECIMALS = 66\n\t\tIRs:\n\t\t\tINVALID_DECIMALS(string) := 66(string)\n\t\tExpression: INVALID_RESERVE_FACTOR = 67\n\t\tIRs:\n\t\t\tINVALID_RESERVE_FACTOR(string) := 67(string)\n\t\tExpression: INVALID_BORROW_CAP = 68\n\t\tIRs:\n\t\t\tINVALID_BORROW_CAP(string) := 68(string)\n\t\tExpression: INVALID_SUPPLY_CAP = 69\n\t\tIRs:\n\t\t\tINVALID_SUPPLY_CAP(string) := 69(string)\n\t\tExpression: INVALID_LIQUIDATION_PROTOCOL_FEE = 70\n\t\tIRs:\n\t\t\tINVALID_LIQUIDATION_PROTOCOL_FEE(string) := 70(string)\n\t\tExpression: INVALID_EMODE_CATEGORY = 71\n\t\tIRs:\n\t\t\tINVALID_EMODE_CATEGORY(string) := 71(string)\n\t\tExpression: INVALID_UNBACKED_MINT_CAP = 72\n\t\tIRs:\n\t\t\tINVALID_UNBACKED_MINT_CAP(string) := 72(string)\n\t\tExpression: INVALID_DEBT_CEILING = 73\n\t\tIRs:\n\t\t\tINVALID_DEBT_CEILING(string) := 73(string)\n\t\tExpression: INVALID_RESERVE_INDEX = 74\n\t\tIRs:\n\t\t\tINVALID_RESERVE_INDEX(string) := 74(string)\n\t\tExpression: ACL_ADMIN_CANNOT_BE_ZERO = 75\n\t\tIRs:\n\t\t\tACL_ADMIN_CANNOT_BE_ZERO(string) := 75(string)\n\t\tExpression: INCONSISTENT_PARAMS_LENGTH = 76\n\t\tIRs:\n\t\t\tINCONSISTENT_PARAMS_LENGTH(string) := 76(string)\n\t\tExpression: ZERO_ADDRESS_NOT_VALID = 77\n\t\tIRs:\n\t\t\tZERO_ADDRESS_NOT_VALID(string) := 77(string)\n\t\tExpression: INVALID_EXPIRATION = 78\n\t\tIRs:\n\t\t\tINVALID_EXPIRATION(string) := 78(string)\n\t\tExpression: INVALID_SIGNATURE = 79\n\t\tIRs:\n\t\t\tINVALID_SIGNATURE(string) := 79(string)\n\t\tExpression: OPERATION_NOT_SUPPORTED = 80\n\t\tIRs:\n\t\t\tOPERATION_NOT_SUPPORTED(string) := 80(string)\n\t\tExpression: DEBT_CEILING_NOT_ZERO = 81\n\t\tIRs:\n\t\t\tDEBT_CEILING_NOT_ZERO(string) := 81(string)\n\t\tExpression: ASSET_NOT_LISTED = 82\n\t\tIRs:\n\t\t\tASSET_NOT_LISTED(string) := 82(string)\n\t\tExpression: INVALID_OPTIMAL_USAGE_RATIO = 83\n\t\tIRs:\n\t\t\tINVALID_OPTIMAL_USAGE_RATIO(string) := 83(string)\n\t\tExpression: INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = 84\n\t\tIRs:\n\t\t\tINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO(string) := 84(string)\n\t\tExpression: UNDERLYING_CANNOT_BE_RESCUED = 85\n\t\tIRs:\n\t\t\tUNDERLYING_CANNOT_BE_RESCUED(string) := 85(string)\n\t\tExpression: ADDRESSES_PROVIDER_ALREADY_ADDED = 86\n\t\tIRs:\n\t\t\tADDRESSES_PROVIDER_ALREADY_ADDED(string) := 86(string)\n\t\tExpression: POOL_ADDRESSES_DO_NOT_MATCH = 87\n\t\tIRs:\n\t\t\tPOOL_ADDRESSES_DO_NOT_MATCH(string) := 87(string)\n\t\tExpression: STABLE_BORROWING_ENABLED = 88\n\t\tIRs:\n\t\t\tSTABLE_BORROWING_ENABLED(string) := 88(string)\n\t\tExpression: SILOED_BORROWING_VIOLATION = 89\n\t\tIRs:\n\t\t\tSILOED_BORROWING_VIOLATION(string) := 89(string)\n\t\tExpression: RESERVE_DEBT_NOT_ZERO = 90\n\t\tIRs:\n\t\t\tRESERVE_DEBT_NOT_ZERO(string) := 90(string)\n\t\tExpression: FLASHLOAN_DISABLED = 91\n\t\tIRs:\n\t\t\tFLASHLOAN_DISABLED(string) := 91(string)\nContract Helpers\n\tFunction Helpers.getUserCurrentDebt(address,DataTypes.ReserveCache) (*)\n\t\tExpression: (IERC20(reserveCache.stableDebtTokenAddress).balanceOf(user),IERC20(reserveCache.variableDebtTokenAddress).balanceOf(user))\n\t\tIRs:\n\t\t\tREF_130(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_452 = CONVERT REF_130 to IERC20\n\t\t\tTMP_453(uint256) = HIGH_LEVEL_CALL, dest:TMP_452(IERC20), function:balanceOf, arguments:['user']  \n\t\t\tREF_132(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_454 = CONVERT REF_132 to IERC20\n\t\t\tTMP_455(uint256) = HIGH_LEVEL_CALL, dest:TMP_454(IERC20), function:balanceOf, arguments:['user']  \n\t\t\tRETURN TMP_453,TMP_455\nContract BorrowLogic\n\tFunction BorrowLogic.executeBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteBorrowParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_134(address) -> params.asset\n\t\t\tREF_135(DataTypes.ReserveData) -> reservesData[REF_134]\n\t\t\treserve(DataTypes.ReserveData) := REF_135(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_456(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_456(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: (isolationModeActive,isolationModeCollateralAddress,isolationModeDebtCeiling) = userConfig.getIsolationModeState(reservesData,reservesList)\n\t\tIRs:\n\t\t\tTUPLE_4(bool,address,uint256) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.getIsolationModeState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)), arguments:['userConfig', 'reservesData', 'reservesList'] \n\t\t\tisolationModeActive(bool)= UNPACK TUPLE_4 index: 0 \n\t\t\tisolationModeCollateralAddress(address)= UNPACK TUPLE_4 index: 1 \n\t\t\tisolationModeDebtCeiling(uint256)= UNPACK TUPLE_4 index: 2 \n\t\tExpression: ValidationLogic.validateBorrow(reservesData,reservesList,eModeCategories,DataTypes.ValidateBorrowParams({reserveCache:reserveCache,userConfig:userConfig,asset:params.asset,userAddress:params.onBehalfOf,amount:params.amount,interestRateMode:params.interestRateMode,maxStableLoanPercent:params.maxStableRateBorrowSizePercent,reservesCount:params.reservesCount,oracle:params.oracle,userEModeCategory:params.userEModeCategory,priceOracleSentinel:params.priceOracleSentinel,isolationModeActive:isolationModeActive,isolationModeCollateralAddress:isolationModeCollateralAddress,isolationModeDebtCeiling:isolationModeDebtCeiling}))\n\t\tIRs:\n\t\t\tREF_141(address) -> params.asset\n\t\t\tREF_142(address) -> params.onBehalfOf\n\t\t\tREF_143(uint256) -> params.amount\n\t\t\tREF_144(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_145(uint256) -> params.maxStableRateBorrowSizePercent\n\t\t\tREF_146(uint256) -> params.reservesCount\n\t\t\tREF_147(address) -> params.oracle\n\t\t\tREF_148(uint8) -> params.userEModeCategory\n\t\t\tREF_149(address) -> params.priceOracleSentinel\n\t\t\tTMP_458(DataTypes.ValidateBorrowParams) = new ValidateBorrowParams(reserveCache,userConfig,REF_141,REF_142,REF_143,REF_144,REF_145,REF_146,REF_147,REF_148,REF_149,isolationModeActive,isolationModeCollateralAddress,isolationModeDebtCeiling)\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.ValidateBorrowParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'TMP_458'] \n\t\tExpression: currentStableRate = 0\n\t\tIRs:\n\t\t\tcurrentStableRate(uint256) := 0(uint256)\n\t\tExpression: isFirstBorrowing = false\n\t\tIRs:\n\t\t\tisFirstBorrowing(bool) := False(bool)\n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_150(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_151(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_460(bool) = REF_150 == REF_151\n\t\t\tCONDITION TMP_460\n\t\tExpression: currentStableRate = reserve.currentStableBorrowRate\n\t\tIRs:\n\t\t\tREF_152(uint128) -> reserve.currentStableBorrowRate\n\t\t\tcurrentStableRate(uint256) := REF_152(uint128)\n\t\tExpression: (isFirstBorrowing,reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(reserveCache.stableDebtTokenAddress).mint(params.user,params.onBehalfOf,params.amount,currentStableRate)\n\t\tIRs:\n\t\t\tREF_153(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_154(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_155(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_461 = CONVERT REF_155 to IStableDebtToken\n\t\t\tREF_157(address) -> params.user\n\t\t\tREF_158(address) -> params.onBehalfOf\n\t\t\tREF_159(uint256) -> params.amount\n\t\t\tTUPLE_5(bool,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_461(IStableDebtToken), function:mint, arguments:['REF_157', 'REF_158', 'REF_159', 'currentStableRate']  \n\t\t\tisFirstBorrowing(bool)= UNPACK TUPLE_5 index: 0 \n\t\t\tREF_153(uint256)= UNPACK TUPLE_5 index: 1 \n\t\t\tREF_154(uint256)= UNPACK TUPLE_5 index: 2 \n\t\tExpression: (isFirstBorrowing,reserveCache.nextScaledVariableDebt) = IVariableDebtToken(reserveCache.variableDebtTokenAddress).mint(params.user,params.onBehalfOf,params.amount,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_160(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_161(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_462 = CONVERT REF_161 to IVariableDebtToken\n\t\t\tREF_163(address) -> params.user\n\t\t\tREF_164(address) -> params.onBehalfOf\n\t\t\tREF_165(uint256) -> params.amount\n\t\t\tREF_166(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTUPLE_6(bool,uint256) = HIGH_LEVEL_CALL, dest:TMP_462(IVariableDebtToken), function:mint, arguments:['REF_163', 'REF_164', 'REF_165', 'REF_166']  \n\t\t\tisFirstBorrowing(bool)= UNPACK TUPLE_6 index: 0 \n\t\t\tREF_160(uint256)= UNPACK TUPLE_6 index: 1 \n\t\tExpression: isFirstBorrowing\n\t\tIRs:\n\t\t\tCONDITION isFirstBorrowing\n\t\tExpression: userConfig.setBorrowing(reserve.id,true)\n\t\tIRs:\n\t\t\tREF_168(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setBorrowing(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_168', 'True'] \n\t\tExpression: isolationModeActive\n\t\tIRs:\n\t\t\tCONDITION isolationModeActive\n\t\tExpression: nextIsolationModeTotalDebt = reservesData[isolationModeCollateralAddress].isolationModeTotalDebt += (params.amount / 10 ** (reserveCache.reserveConfiguration.getDecimals() - ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128()\n\t\tIRs:\n\t\t\tREF_169(DataTypes.ReserveData) -> reservesData[isolationModeCollateralAddress]\n\t\t\tREF_170(uint128) -> REF_169.isolationModeTotalDebt\n\t\t\tREF_171(uint256) -> params.amount\n\t\t\tREF_172(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_464(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_172'] \n\t\t\tREF_174(uint256) -> ReserveConfiguration.DEBT_CEILING_DECIMALS\n\t\t\tTMP_465(uint256) = TMP_464 (c)- REF_174\n\t\t\tTMP_466(uint256) = 10 (c)** TMP_465\n\t\t\tTMP_467(uint256) = REF_171 (c)/ TMP_466\n\t\t\tTMP_468(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_467'] \n\t\t\tREF_170(-> reservesData) = REF_170 (c)+ TMP_468\n\t\t\tnextIsolationModeTotalDebt(uint256) := REF_170(uint128)\n\t\tExpression: IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,nextIsolationModeTotalDebt)\n\t\tIRs:\n\t\t\tEmit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,nextIsolationModeTotalDebt)\n\t\tExpression: params.releaseUnderlying\n\t\tIRs:\n\t\t\tREF_176(bool) -> params.releaseUnderlying\n\t\t\tCONDITION REF_176\n\t\tExpression: IAToken(reserveCache.aTokenAddress).transferUnderlyingTo(params.user,params.amount)\n\t\tIRs:\n\t\t\tREF_177(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_470 = CONVERT REF_177 to IAToken\n\t\t\tREF_179(address) -> params.user\n\t\t\tREF_180(uint256) -> params.amount\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_470(IAToken), function:transferUnderlyingTo, arguments:['REF_179', 'REF_180']  \n\t\tExpression: params.releaseUnderlying\n\t\tIRs:\n\t\t\tREF_181(bool) -> params.releaseUnderlying\n\t\t\tCONDITION REF_181\n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,0,params.amount)\n\t\tIRs:\n\t\t\tREF_183(address) -> params.asset\n\t\t\tREF_184(uint256) -> params.amount\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_183', '0', 'REF_184'] \n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,0,0)\n\t\tIRs:\n\t\t\tREF_186(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_186', '0', '0'] \n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_187(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_188(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_474(bool) = REF_187 == REF_188\n\t\t\tCONDITION TMP_474\n\t\tExpression: Borrow(params.asset,params.user,params.onBehalfOf,params.amount,params.interestRateMode,currentStableRate,params.referralCode)\n\t\tIRs:\n\t\t\tREF_189(address) -> params.asset\n\t\t\tREF_190(address) -> params.user\n\t\t\tREF_191(address) -> params.onBehalfOf\n\t\t\tREF_192(uint256) -> params.amount\n\t\t\tREF_193(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_194(uint16) -> params.referralCode\n\t\t\tEmit Borrow(REF_189,REF_190,REF_191,REF_192,REF_193,currentStableRate,REF_194)\n\t\tExpression: Borrow(params.asset,params.user,params.onBehalfOf,params.amount,params.interestRateMode,reserve.currentVariableBorrowRate,params.referralCode)\n\t\tIRs:\n\t\t\tREF_195(address) -> params.asset\n\t\t\tREF_196(address) -> params.user\n\t\t\tREF_197(address) -> params.onBehalfOf\n\t\t\tREF_198(uint256) -> params.amount\n\t\t\tREF_199(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_200(uint128) -> reserve.currentVariableBorrowRate\n\t\t\tREF_201(uint16) -> params.referralCode\n\t\t\tEmit Borrow(REF_195,REF_196,REF_197,REF_198,REF_199,REF_200,REF_201)\n\tFunction BorrowLogic.executeRepay(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteRepayParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_202(address) -> params.asset\n\t\t\tREF_203(DataTypes.ReserveData) -> reservesData[REF_202]\n\t\t\treserve(DataTypes.ReserveData) := REF_203(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_477(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_477(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: (stableDebt,variableDebt) = Helpers.getUserCurrentDebt(params.onBehalfOf,reserveCache)\n\t\tIRs:\n\t\t\tREF_207(address) -> params.onBehalfOf\n\t\t\tTUPLE_7(uint256,uint256) = LIBRARY_CALL, dest:Helpers, function:Helpers.getUserCurrentDebt(address,DataTypes.ReserveCache), arguments:['REF_207', 'reserveCache'] \n\t\t\tstableDebt(uint256)= UNPACK TUPLE_7 index: 0 \n\t\t\tvariableDebt(uint256)= UNPACK TUPLE_7 index: 1 \n\t\tExpression: ValidationLogic.validateRepay(reserveCache,params.amount,params.interestRateMode,params.onBehalfOf,stableDebt,variableDebt)\n\t\tIRs:\n\t\t\tREF_209(uint256) -> params.amount\n\t\t\tREF_210(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_211(address) -> params.onBehalfOf\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateRepay(DataTypes.ReserveCache,uint256,DataTypes.InterestRateMode,address,uint256,uint256), arguments:['reserveCache', 'REF_209', 'REF_210', 'REF_211', 'stableDebt', 'variableDebt'] \n\t\tExpression: params.useATokens && params.amount == type()(uint256).max\n\t\tIRs:\n\t\t\tREF_212(bool) -> params.useATokens\n\t\t\tREF_213(uint256) -> params.amount\n\t\t\tTMP_481(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tTMP_482(bool) = REF_213 == TMP_481\n\t\t\tTMP_483(bool) = REF_212 && TMP_482\n\t\t\tCONDITION TMP_483\n\t\tExpression: params.amount = IAToken(reserveCache.aTokenAddress).balanceOf(msg.sender)\n\t\tIRs:\n\t\t\tREF_214(uint256) -> params.amount\n\t\t\tREF_215(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_484 = CONVERT REF_215 to IAToken\n\t\t\tTMP_485(uint256) = HIGH_LEVEL_CALL, dest:TMP_484(IAToken), function:balanceOf, arguments:['msg.sender']  \n\t\t\tREF_214(uint256) (->params) := TMP_485(uint256)\n\t\tExpression: params.amount < paybackAmount\n\t\tIRs:\n\t\t\tREF_217(uint256) -> params.amount\n\t\t\tTMP_486(bool) = REF_217 < paybackAmount\n\t\t\tCONDITION TMP_486\n\t\tExpression: paybackAmount = params.amount\n\t\tIRs:\n\t\t\tREF_218(uint256) -> params.amount\n\t\t\tpaybackAmount(uint256) := REF_218(uint256)\n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_219(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_220(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_487(bool) = REF_219 == REF_220\n\t\t\tCONDITION TMP_487\n\t\tExpression: (reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(reserveCache.stableDebtTokenAddress).burn(params.onBehalfOf,paybackAmount)\n\t\tIRs:\n\t\t\tREF_221(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_222(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_223(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_488 = CONVERT REF_223 to IStableDebtToken\n\t\t\tREF_225(address) -> params.onBehalfOf\n\t\t\tTUPLE_8(uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_488(IStableDebtToken), function:burn, arguments:['REF_225', 'paybackAmount']  \n\t\t\tREF_221(uint256)= UNPACK TUPLE_8 index: 0 \n\t\t\tREF_222(uint256)= UNPACK TUPLE_8 index: 1 \n\t\tExpression: reserveCache.nextScaledVariableDebt = IVariableDebtToken(reserveCache.variableDebtTokenAddress).burn(params.onBehalfOf,paybackAmount,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_226(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_227(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_489 = CONVERT REF_227 to IVariableDebtToken\n\t\t\tREF_229(address) -> params.onBehalfOf\n\t\t\tREF_230(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_490(uint256) = HIGH_LEVEL_CALL, dest:TMP_489(IVariableDebtToken), function:burn, arguments:['REF_229', 'paybackAmount', 'REF_230']  \n\t\t\tREF_226(uint256) (->reserveCache) := TMP_490(uint256)\n\t\tExpression: stableDebt + variableDebt - paybackAmount == 0\n\t\tIRs:\n\t\t\tTMP_491(uint256) = stableDebt (c)+ variableDebt\n\t\t\tTMP_492(uint256) = TMP_491 (c)- paybackAmount\n\t\t\tTMP_493(bool) = TMP_492 == 0\n\t\t\tCONDITION TMP_493\n\t\tExpression: userConfig.setBorrowing(reserve.id,false)\n\t\tIRs:\n\t\t\tREF_232(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setBorrowing(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_232', 'False'] \n\t\tExpression: IsolationModeLogic.updateIsolatedDebtIfIsolated(reservesData,reservesList,userConfig,reserveCache,paybackAmount)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:IsolationModeLogic, function:IsolationModeLogic.updateIsolatedDebtIfIsolated(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveCache,uint256), arguments:['reservesData', 'reservesList', 'userConfig', 'reserveCache', 'paybackAmount'] \n\t\tExpression: params.useATokens\n\t\tIRs:\n\t\t\tREF_234(bool) -> params.useATokens\n\t\t\tCONDITION REF_234\n\t\tExpression: IAToken(reserveCache.aTokenAddress).burn(msg.sender,reserveCache.aTokenAddress,paybackAmount,reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_235(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_496 = CONVERT REF_235 to IAToken\n\t\t\tREF_237(address) -> reserveCache.aTokenAddress\n\t\t\tREF_238(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_496(IAToken), function:burn, arguments:['msg.sender', 'REF_237', 'paybackAmount', 'REF_238']  \n\t\tExpression: IERC20(params.asset).safeTransferFrom(msg.sender,reserveCache.aTokenAddress,paybackAmount)\n\t\tIRs:\n\t\t\tREF_239(address) -> params.asset\n\t\t\tTMP_498 = CONVERT REF_239 to IERC20\n\t\t\tREF_241(address) -> reserveCache.aTokenAddress\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_498', 'msg.sender', 'REF_241', 'paybackAmount'] \n\t\tExpression: IAToken(reserveCache.aTokenAddress).handleRepayment(msg.sender,params.onBehalfOf,paybackAmount)\n\t\tIRs:\n\t\t\tREF_242(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_500 = CONVERT REF_242 to IAToken\n\t\t\tREF_244(address) -> params.onBehalfOf\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_500(IAToken), function:handleRepayment, arguments:['msg.sender', 'REF_244', 'paybackAmount']  \n\t\tExpression: Repay(params.asset,params.onBehalfOf,msg.sender,paybackAmount,params.useATokens)\n\t\tIRs:\n\t\t\tREF_245(address) -> params.asset\n\t\t\tREF_246(address) -> params.onBehalfOf\n\t\t\tREF_247(bool) -> params.useATokens\n\t\t\tEmit Repay(REF_245,REF_246,msg.sender,paybackAmount,REF_247)\n\t\tExpression: paybackAmount\n\t\tIRs:\n\t\t\tRETURN paybackAmount\n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_248(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_249(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_503(bool) = REF_248 == REF_249\n\t\t\tCONDITION TMP_503\n\t\tExpression: paybackAmount = stableDebt\n\t\tIRs:\n\t\t\tpaybackAmount(uint256) := stableDebt(uint256)\n\t\tExpression: paybackAmount = variableDebt\n\t\tIRs:\n\t\t\tpaybackAmount(uint256) := variableDebt(uint256)\n\t\tExpression: params.useATokens\n\t\tIRs:\n\t\t\tREF_250(bool) -> params.useATokens\n\t\t\tCONDITION REF_250\n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,0,0)\n\t\tIRs:\n\t\t\tREF_252(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_252', '0', '0'] \n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,paybackAmount,0)\n\t\tIRs:\n\t\t\tREF_254(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_254', 'paybackAmount', '0'] \n\tFunction BorrowLogic.executeRebalanceStableBorrowRate(DataTypes.ReserveData,address,address) (*)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_506(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_506(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: ValidationLogic.validateRebalanceStableBorrowRate(reserve,reserveCache,asset)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateRebalanceStableBorrowRate(DataTypes.ReserveData,DataTypes.ReserveCache,address), arguments:['reserve', 'reserveCache', 'asset'] \n\t\tExpression: stableDebtToken = IStableDebtToken(reserveCache.stableDebtTokenAddress)\n\t\tIRs:\n\t\t\tREF_258(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_509 = CONVERT REF_258 to IStableDebtToken\n\t\t\tstableDebtToken(IStableDebtToken) := TMP_509(IStableDebtToken)\n\t\tExpression: stableDebt = IERC20(address(stableDebtToken)).balanceOf(user)\n\t\tIRs:\n\t\t\tTMP_510 = CONVERT stableDebtToken to address\n\t\t\tTMP_511 = CONVERT TMP_510 to IERC20\n\t\t\tTMP_512(uint256) = HIGH_LEVEL_CALL, dest:TMP_511(IERC20), function:balanceOf, arguments:['user']  \n\t\t\tstableDebt(uint256) := TMP_512(uint256)\n\t\tExpression: stableDebtToken.burn(user,stableDebt)\n\t\tIRs:\n\t\t\tTUPLE_9(uint256,uint256) = HIGH_LEVEL_CALL, dest:stableDebtToken(IStableDebtToken), function:burn, arguments:['user', 'stableDebt']  \n\t\tExpression: (None,reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = stableDebtToken.mint(user,user,stableDebt,reserve.currentStableBorrowRate)\n\t\tIRs:\n\t\t\tREF_261(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_262(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_264(uint128) -> reserve.currentStableBorrowRate\n\t\t\tTUPLE_10(bool,uint256,uint256) = HIGH_LEVEL_CALL, dest:stableDebtToken(IStableDebtToken), function:mint, arguments:['user', 'user', 'stableDebt', 'REF_264']  \n\t\t\tREF_261(uint256)= UNPACK TUPLE_10 index: 1 \n\t\t\tREF_262(uint256)= UNPACK TUPLE_10 index: 2 \n\t\tExpression: reserve.updateInterestRates(reserveCache,asset,0,0)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'asset', '0', '0'] \n\t\tExpression: RebalanceStableBorrowRate(asset,user)\n\t\tIRs:\n\t\t\tEmit RebalanceStableBorrowRate(asset,user)\n\tFunction BorrowLogic.executeSwapBorrowRateMode(DataTypes.ReserveData,DataTypes.UserConfigurationMap,address,DataTypes.InterestRateMode) (*)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_515(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_515(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: (stableDebt,variableDebt) = Helpers.getUserCurrentDebt(msg.sender,reserveCache)\n\t\tIRs:\n\t\t\tTUPLE_11(uint256,uint256) = LIBRARY_CALL, dest:Helpers, function:Helpers.getUserCurrentDebt(address,DataTypes.ReserveCache), arguments:['msg.sender', 'reserveCache'] \n\t\t\tstableDebt(uint256)= UNPACK TUPLE_11 index: 0 \n\t\t\tvariableDebt(uint256)= UNPACK TUPLE_11 index: 1 \n\t\tExpression: ValidationLogic.validateSwapRateMode(reserve,reserveCache,userConfig,stableDebt,variableDebt,interestRateMode)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSwapRateMode(DataTypes.ReserveData,DataTypes.ReserveCache,DataTypes.UserConfigurationMap,uint256,uint256,DataTypes.InterestRateMode), arguments:['reserve', 'reserveCache', 'userConfig', 'stableDebt', 'variableDebt', 'interestRateMode'] \n\t\tExpression: interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_270(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_518(bool) = interestRateMode == REF_270\n\t\t\tCONDITION TMP_518\n\t\tExpression: (reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(reserveCache.stableDebtTokenAddress).burn(msg.sender,stableDebt)\n\t\tIRs:\n\t\t\tREF_271(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_272(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_273(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_519 = CONVERT REF_273 to IStableDebtToken\n\t\t\tTUPLE_12(uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_519(IStableDebtToken), function:burn, arguments:['msg.sender', 'stableDebt']  \n\t\t\tREF_271(uint256)= UNPACK TUPLE_12 index: 0 \n\t\t\tREF_272(uint256)= UNPACK TUPLE_12 index: 1 \n\t\tExpression: (None,reserveCache.nextScaledVariableDebt) = IVariableDebtToken(reserveCache.variableDebtTokenAddress).mint(msg.sender,msg.sender,stableDebt,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_275(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_276(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_520 = CONVERT REF_276 to IVariableDebtToken\n\t\t\tREF_278(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTUPLE_13(bool,uint256) = HIGH_LEVEL_CALL, dest:TMP_520(IVariableDebtToken), function:mint, arguments:['msg.sender', 'msg.sender', 'stableDebt', 'REF_278']  \n\t\t\tREF_275(uint256)= UNPACK TUPLE_13 index: 1 \n\t\tExpression: reserveCache.nextScaledVariableDebt = IVariableDebtToken(reserveCache.variableDebtTokenAddress).burn(msg.sender,variableDebt,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_279(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_280(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_521 = CONVERT REF_280 to IVariableDebtToken\n\t\t\tREF_282(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_522(uint256) = HIGH_LEVEL_CALL, dest:TMP_521(IVariableDebtToken), function:burn, arguments:['msg.sender', 'variableDebt', 'REF_282']  \n\t\t\tREF_279(uint256) (->reserveCache) := TMP_522(uint256)\n\t\tExpression: (None,reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(reserveCache.stableDebtTokenAddress).mint(msg.sender,msg.sender,variableDebt,reserve.currentStableBorrowRate)\n\t\tIRs:\n\t\t\tREF_283(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_284(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_285(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_523 = CONVERT REF_285 to IStableDebtToken\n\t\t\tREF_287(uint128) -> reserve.currentStableBorrowRate\n\t\t\tTUPLE_14(bool,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_523(IStableDebtToken), function:mint, arguments:['msg.sender', 'msg.sender', 'variableDebt', 'REF_287']  \n\t\t\tREF_283(uint256)= UNPACK TUPLE_14 index: 1 \n\t\t\tREF_284(uint256)= UNPACK TUPLE_14 index: 2 \n\t\tExpression: reserve.updateInterestRates(reserveCache,asset,0,0)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'asset', '0', '0'] \n\t\tExpression: SwapBorrowRateMode(asset,msg.sender,interestRateMode)\n\t\tIRs:\n\t\t\tEmit SwapBorrowRateMode(asset,msg.sender,interestRateMode)\nContract BridgeLogic\n\tFunction BridgeLogic.executeMintUnbacked(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,address,uint256,address,uint16) (*)\n\t\tExpression: reserve = reservesData[asset]\n\t\tIRs:\n\t\t\tREF_289(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treserve(DataTypes.ReserveData) := REF_289(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_526(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_526(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: ValidationLogic.validateSupply(reserveCache,reserve,amount)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSupply(DataTypes.ReserveCache,DataTypes.ReserveData,uint256), arguments:['reserveCache', 'reserve', 'amount'] \n\t\tExpression: unbackedMintCap = reserveCache.reserveConfiguration.getUnbackedMintCap()\n\t\tIRs:\n\t\t\tREF_293(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_529(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getUnbackedMintCap(DataTypes.ReserveConfigurationMap), arguments:['REF_293'] \n\t\t\tunbackedMintCap(uint256) := TMP_529(uint256)\n\t\tExpression: reserveDecimals = reserveCache.reserveConfiguration.getDecimals()\n\t\tIRs:\n\t\t\tREF_295(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_530(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_295'] \n\t\t\treserveDecimals(uint256) := TMP_530(uint256)\n\t\tExpression: unbacked = reserve.unbacked += amount.toUint128()\n\t\tIRs:\n\t\t\tREF_297(uint128) -> reserve.unbacked\n\t\t\tTMP_531(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['amount'] \n\t\t\tREF_297(-> reserve) = REF_297 (c)+ TMP_531\n\t\t\tunbacked(uint256) := REF_297(uint128)\n\t\tExpression: require(bool,string)(unbacked <= unbackedMintCap * (10 ** reserveDecimals),Errors.UNBACKED_MINT_CAP_EXCEEDED)\n\t\tIRs:\n\t\t\tTMP_532(uint256) = 10 (c)** reserveDecimals\n\t\t\tTMP_533(uint256) = unbackedMintCap (c)* TMP_532\n\t\t\tTMP_534(bool) = unbacked <= TMP_533\n\t\t\tREF_299(string) -> Errors.UNBACKED_MINT_CAP_EXCEEDED\n\t\t\tTMP_535(None) = SOLIDITY_CALL require(bool,string)(TMP_534,REF_299)\n\t\tExpression: reserve.updateInterestRates(reserveCache,asset,0,0)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'asset', '0', '0'] \n\t\tExpression: isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(msg.sender,onBehalfOf,amount,reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_301(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_537 = CONVERT REF_301 to IAToken\n\t\t\tREF_303(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_538(bool) = HIGH_LEVEL_CALL, dest:TMP_537(IAToken), function:mint, arguments:['msg.sender', 'onBehalfOf', 'amount', 'REF_303']  \n\t\t\tisFirstSupply(bool) := TMP_538(bool)\n\t\tExpression: isFirstSupply\n\t\tIRs:\n\t\t\tCONDITION isFirstSupply\n\t\tExpression: ValidationLogic.validateAutomaticUseAsCollateral(reservesData,reservesList,userConfig,reserveCache.reserveConfiguration,reserveCache.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_305(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tREF_306(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_539(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address), arguments:['reservesData', 'reservesList', 'userConfig', 'REF_305', 'REF_306'] \n\t\t\tCONDITION TMP_539\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,true)\n\t\tIRs:\n\t\t\tREF_308(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_308', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(asset,onBehalfOf)\n\t\tIRs:\n\t\t\tEmit ReserveUsedAsCollateralEnabled(asset,onBehalfOf)\n\t\tExpression: MintUnbacked(asset,msg.sender,onBehalfOf,amount,referralCode)\n\t\tIRs:\n\t\t\tEmit MintUnbacked(asset,msg.sender,onBehalfOf,amount,referralCode)\n\tFunction BridgeLogic.executeBackUnbacked(DataTypes.ReserveData,address,uint256,uint256,uint256) (*)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_543(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_543(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: feeToProtocol = fee.percentMul(protocolFeeBps)\n\t\tIRs:\n\t\t\tTMP_545(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['fee', 'protocolFeeBps'] \n\t\t\tfeeToProtocol(uint256) := TMP_545(uint256)\n\t\tExpression: feeToLP = fee - feeToProtocol\n\t\tIRs:\n\t\t\tTMP_546(uint256) = fee (c)- feeToProtocol\n\t\t\tfeeToLP(uint256) := TMP_546(uint256)\n\t\tExpression: added = backingAmount + fee\n\t\tIRs:\n\t\t\tTMP_547(uint256) = backingAmount (c)+ fee\n\t\t\tadded(uint256) := TMP_547(uint256)\n\t\tExpression: reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(IERC20(reserveCache.aTokenAddress).totalSupply() + uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),feeToLP)\n\t\tIRs:\n\t\t\tREF_312(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_314(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_548 = CONVERT REF_314 to IERC20\n\t\t\tTMP_549(uint256) = HIGH_LEVEL_CALL, dest:TMP_548(IERC20), function:totalSupply, arguments:[]  \n\t\t\tREF_316(uint128) -> reserve.accruedToTreasury\n\t\t\tTMP_550 = CONVERT REF_316 to uint256\n\t\t\tREF_318(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_551(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_550', 'REF_318'] \n\t\t\tTMP_552(uint256) = TMP_549 (c)+ TMP_551\n\t\t\tTMP_553(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cumulateToLiquidityIndex(DataTypes.ReserveData,uint256,uint256), arguments:['reserve', 'TMP_552', 'feeToLP'] \n\t\t\tREF_312(uint256) (->reserveCache) := TMP_553(uint256)\n\t\tExpression: reserve.accruedToTreasury += feeToProtocol.rayDiv(reserveCache.nextLiquidityIndex).toUint128()\n\t\tIRs:\n\t\t\tREF_319(uint128) -> reserve.accruedToTreasury\n\t\t\tREF_321(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_554(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['feeToProtocol', 'REF_321'] \n\t\t\tTMP_555(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_554'] \n\t\t\tREF_319(-> reserve) = REF_319 (c)+ TMP_555\n\t\tExpression: reserve.unbacked -= backingAmount.toUint128()\n\t\tIRs:\n\t\t\tREF_323(uint128) -> reserve.unbacked\n\t\t\tTMP_556(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['backingAmount'] \n\t\t\tREF_323(-> reserve) = REF_323 (c)- TMP_556\n\t\tExpression: reserve.updateInterestRates(reserveCache,asset,added,0)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'asset', 'added', '0'] \n\t\tExpression: IERC20(asset).safeTransferFrom(msg.sender,reserveCache.aTokenAddress,added)\n\t\tIRs:\n\t\t\tTMP_558 = CONVERT asset to IERC20\n\t\t\tREF_327(address) -> reserveCache.aTokenAddress\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_558', 'msg.sender', 'REF_327', 'added'] \n\t\tExpression: BackUnbacked(asset,msg.sender,backingAmount,fee)\n\t\tIRs:\n\t\t\tEmit BackUnbacked(asset,msg.sender,backingAmount,fee)\n\t\tExpression: backingAmount\n\t\tIRs:\n\t\t\tRETURN backingAmount\n\t\tExpression: (amount < reserve.unbacked)\n\t\tIRs:\n\t\t\tREF_328(uint128) -> reserve.unbacked\n\t\t\tTMP_561(bool) = amount < REF_328\n\t\t\tCONDITION TMP_561\n\t\tExpression: backingAmount = amount\n\t\tIRs:\n\t\t\tbackingAmount(uint256) := amount(uint256)\n\t\tExpression: backingAmount = reserve.unbacked\n\t\tIRs:\n\t\t\tREF_329(uint128) -> reserve.unbacked\n\t\t\tbackingAmount(uint256) := REF_329(uint128)\nContract EModeLogic\n\tFunction EModeLogic.executeSetUserEMode(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),mapping(address => uint8),DataTypes.UserConfigurationMap,DataTypes.ExecuteSetUserEModeParams) (*)\n\t\tExpression: ValidationLogic.validateSetUserEMode(reservesData,reservesList,eModeCategories,userConfig,params.reservesCount,params.categoryId)\n\t\tIRs:\n\t\t\tREF_331(uint256) -> params.reservesCount\n\t\t\tREF_332(uint8) -> params.categoryId\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSetUserEMode(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,uint256,uint8), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'REF_331', 'REF_332'] \n\t\tExpression: prevCategoryId = usersEModeCategory[msg.sender]\n\t\tIRs:\n\t\t\tREF_333(uint8) -> usersEModeCategory[msg.sender]\n\t\t\tprevCategoryId(uint8) := REF_333(uint8)\n\t\tExpression: usersEModeCategory[msg.sender] = params.categoryId\n\t\tIRs:\n\t\t\tREF_334(uint8) -> usersEModeCategory[msg.sender]\n\t\t\tREF_335(uint8) -> params.categoryId\n\t\t\tREF_334(uint8) (->usersEModeCategory) := REF_335(uint8)\n\t\tExpression: prevCategoryId != 0\n\t\tIRs:\n\t\t\tTMP_563(bool) = prevCategoryId != 0\n\t\t\tCONDITION TMP_563\n\t\tExpression: ValidationLogic.validateHealthFactor(reservesData,reservesList,eModeCategories,userConfig,msg.sender,params.categoryId,params.reservesCount,params.oracle)\n\t\tIRs:\n\t\t\tREF_337(uint8) -> params.categoryId\n\t\t\tREF_338(uint256) -> params.reservesCount\n\t\t\tREF_339(address) -> params.oracle\n\t\t\tTUPLE_15(uint256,bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateHealthFactor(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,uint8,uint256,address), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'msg.sender', 'REF_337', 'REF_338', 'REF_339'] \n\t\tExpression: UserEModeSet(msg.sender,params.categoryId)\n\t\tIRs:\n\t\t\tREF_340(uint8) -> params.categoryId\n\t\t\tEmit UserEModeSet(msg.sender,REF_340)\n\tFunction EModeLogic.getEModeConfiguration(DataTypes.EModeCategory,IPriceOracleGetter) (*)\n\t\tExpression: eModeAssetPrice = 0\n\t\tIRs:\n\t\t\teModeAssetPrice(uint256) := 0(uint256)\n\t\tExpression: eModePriceSource = category.priceSource\n\t\tIRs:\n\t\t\tREF_341(address) -> category.priceSource\n\t\t\teModePriceSource(address) := REF_341(address)\n\t\tExpression: eModePriceSource != address(0)\n\t\tIRs:\n\t\t\tTMP_565 = CONVERT 0 to address\n\t\t\tTMP_566(bool) = eModePriceSource != TMP_565\n\t\t\tCONDITION TMP_566\n\t\tExpression: eModeAssetPrice = oracle.getAssetPrice(eModePriceSource)\n\t\tIRs:\n\t\t\tTMP_567(uint256) = HIGH_LEVEL_CALL, dest:oracle(IPriceOracleGetter), function:getAssetPrice, arguments:['eModePriceSource']  \n\t\t\teModeAssetPrice(uint256) := TMP_567(uint256)\n\t\tExpression: (category.ltv,category.liquidationThreshold,eModeAssetPrice)\n\t\tIRs:\n\t\t\tREF_343(uint16) -> category.ltv\n\t\t\tREF_344(uint16) -> category.liquidationThreshold\n\t\t\tRETURN REF_343,REF_344,eModeAssetPrice\n\tFunction EModeLogic.isInEModeCategory(uint256,uint256) (*)\n\t\tExpression: (eModeUserCategory != 0 && eModeAssetCategory == eModeUserCategory)\n\t\tIRs:\n\t\t\tTMP_568(bool) = eModeUserCategory != 0\n\t\t\tTMP_569(bool) = eModeAssetCategory == eModeUserCategory\n\t\t\tTMP_570(bool) = TMP_568 && TMP_569\n\t\t\tRETURN TMP_570\nContract FlashLoanLogic\n\tFunction FlashLoanLogic.executeFlashLoan(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.FlashloanParams) (*)\n\t\tExpression: ValidationLogic.validateFlashloan(reservesData,params.assets,params.amounts)\n\t\tIRs:\n\t\t\tREF_346(address[]) -> params.assets\n\t\t\tREF_347(uint256[]) -> params.amounts\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateFlashloan(mapping(address => DataTypes.ReserveData),address[],uint256[]), arguments:['reservesData', 'REF_346', 'REF_347'] \n\t\tExpression: vars.totalPremiums = new uint256[](params.assets.length)\n\t\tIRs:\n\t\t\tREF_348(uint256[]) -> vars.totalPremiums\n\t\t\tREF_349(address[]) -> params.assets\n\t\t\tREF_350 -> LENGTH REF_349\n\t\t\tTMP_573(uint256[])  = new uint256[](REF_350)\n\t\t\tREF_348(uint256[]) (->vars) := TMP_573(uint256[])\n\t\tExpression: vars.receiver = IFlashLoanReceiver(params.receiverAddress)\n\t\tIRs:\n\t\t\tREF_351(IFlashLoanReceiver) -> vars.receiver\n\t\t\tREF_352(address) -> params.receiverAddress\n\t\t\tTMP_574 = CONVERT REF_352 to IFlashLoanReceiver\n\t\t\tREF_351(IFlashLoanReceiver) (->vars) := TMP_574(IFlashLoanReceiver)\n\t\tExpression: vars.i = 0\n\t\tIRs:\n\t\t\tREF_353(uint256) -> vars.i\n\t\t\tREF_353(uint256) (->vars) := 0(uint256)\n\t\tExpression: vars.i < params.assets.length\n\t\tIRs:\n\t\t\tREF_354(uint256) -> vars.i\n\t\t\tREF_355(address[]) -> params.assets\n\t\t\tREF_356 -> LENGTH REF_355\n\t\t\tTMP_575(bool) = REF_354 < REF_356\n\t\t\tCONDITION TMP_575\n\t\tExpression: vars.currentAmount = params.amounts[vars.i]\n\t\tIRs:\n\t\t\tREF_357(uint256) -> vars.currentAmount\n\t\t\tREF_358(uint256[]) -> params.amounts\n\t\t\tREF_359(uint256) -> vars.i\n\t\t\tREF_360(uint256) -> REF_358[REF_359]\n\t\t\tREF_357(uint256) (->vars) := REF_360(uint256)\n\t\tExpression: IAToken(reservesData[params.assets[vars.i]].aTokenAddress).transferUnderlyingTo(params.receiverAddress,vars.currentAmount)\n\t\tIRs:\n\t\t\tREF_361(address[]) -> params.assets\n\t\t\tREF_362(uint256) -> vars.i\n\t\t\tREF_363(address) -> REF_361[REF_362]\n\t\t\tREF_364(DataTypes.ReserveData) -> reservesData[REF_363]\n\t\t\tREF_365(address) -> REF_364.aTokenAddress\n\t\t\tTMP_576 = CONVERT REF_365 to IAToken\n\t\t\tREF_367(address) -> params.receiverAddress\n\t\t\tREF_368(uint256) -> vars.currentAmount\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_576(IAToken), function:transferUnderlyingTo, arguments:['REF_367', 'REF_368']  \n\t\tExpression: vars.i ++\n\t\tIRs:\n\t\t\tREF_369(uint256) -> vars.i\n\t\t\tTMP_578(uint256) := REF_369(uint256)\n\t\t\tREF_369(-> vars) = REF_369 (c)+ 1\n\t\tExpression: require(bool,string)(vars.receiver.executeOperation(params.assets,params.amounts,vars.totalPremiums,msg.sender,params.params),Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN)\n\t\tIRs:\n\t\t\tREF_370(IFlashLoanReceiver) -> vars.receiver\n\t\t\tREF_372(address[]) -> params.assets\n\t\t\tREF_373(uint256[]) -> params.amounts\n\t\t\tREF_374(uint256[]) -> vars.totalPremiums\n\t\t\tREF_375(bytes) -> params.params\n\t\t\tTMP_579(bool) = HIGH_LEVEL_CALL, dest:REF_370(IFlashLoanReceiver), function:executeOperation, arguments:['REF_372', 'REF_373', 'REF_374', 'msg.sender', 'REF_375']  \n\t\t\tREF_376(string) -> Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN\n\t\t\tTMP_580(None) = SOLIDITY_CALL require(bool,string)(TMP_579,REF_376)\n\t\tExpression: vars.i = 0\n\t\tIRs:\n\t\t\tREF_377(uint256) -> vars.i\n\t\t\tREF_377(uint256) (->vars) := 0(uint256)\n\t\tExpression: vars.i < params.assets.length\n\t\tIRs:\n\t\t\tREF_378(uint256) -> vars.i\n\t\t\tREF_379(address[]) -> params.assets\n\t\t\tREF_380 -> LENGTH REF_379\n\t\t\tTMP_581(bool) = REF_378 < REF_380\n\t\t\tCONDITION TMP_581\n\t\tExpression: vars.currentAsset = params.assets[vars.i]\n\t\tIRs:\n\t\t\tREF_381(address) -> vars.currentAsset\n\t\t\tREF_382(address[]) -> params.assets\n\t\t\tREF_383(uint256) -> vars.i\n\t\t\tREF_384(address) -> REF_382[REF_383]\n\t\t\tREF_381(address) (->vars) := REF_384(address)\n\t\tExpression: vars.currentAmount = params.amounts[vars.i]\n\t\tIRs:\n\t\t\tREF_385(uint256) -> vars.currentAmount\n\t\t\tREF_386(uint256[]) -> params.amounts\n\t\t\tREF_387(uint256) -> vars.i\n\t\t\tREF_388(uint256) -> REF_386[REF_387]\n\t\t\tREF_385(uint256) (->vars) := REF_388(uint256)\n\t\tExpression: DataTypes.InterestRateMode(params.interestRateModes[vars.i]) == DataTypes.InterestRateMode.NONE\n\t\tIRs:\n\t\t\tREF_389(uint256[]) -> params.interestRateModes\n\t\t\tREF_390(uint256) -> vars.i\n\t\t\tREF_391(uint256) -> REF_389[REF_390]\n\t\t\tTMP_582 = CONVERT REF_391 to DataTypes.InterestRateMode\n\t\t\tREF_392(DataTypes.InterestRateMode) -> InterestRateMode.NONE\n\t\t\tTMP_583(bool) = TMP_582 == REF_392\n\t\t\tCONDITION TMP_583\n\t\tExpression: _handleFlashLoanRepayment(reservesData[vars.currentAsset],DataTypes.FlashLoanRepaymentParams({asset:vars.currentAsset,receiverAddress:params.receiverAddress,amount:vars.currentAmount,totalPremium:vars.totalPremiums[vars.i],flashLoanPremiumToProtocol:vars.flashloanPremiumToProtocol,referralCode:params.referralCode}))\n\t\tIRs:\n\t\t\tREF_393(address) -> vars.currentAsset\n\t\t\tREF_394(DataTypes.ReserveData) -> reservesData[REF_393]\n\t\t\tREF_396(address) -> vars.currentAsset\n\t\t\tREF_397(address) -> params.receiverAddress\n\t\t\tREF_398(uint256) -> vars.currentAmount\n\t\t\tREF_399(uint256[]) -> vars.totalPremiums\n\t\t\tREF_400(uint256) -> vars.i\n\t\t\tREF_401(uint256) -> REF_399[REF_400]\n\t\t\tREF_402(uint256) -> vars.flashloanPremiumToProtocol\n\t\t\tREF_403(uint16) -> params.referralCode\n\t\t\tTMP_584(DataTypes.FlashLoanRepaymentParams) = new FlashLoanRepaymentParams(REF_398,REF_401,REF_402,REF_396,REF_397,REF_403)\n\t\t\tINTERNAL_CALL, FlashLoanLogic._handleFlashLoanRepayment(DataTypes.ReserveData,DataTypes.FlashLoanRepaymentParams)(REF_394,TMP_584)\n\t\tExpression: BorrowLogic.executeBorrow(reservesData,reservesList,eModeCategories,userConfig,DataTypes.ExecuteBorrowParams({asset:vars.currentAsset,user:msg.sender,onBehalfOf:params.onBehalfOf,amount:vars.currentAmount,interestRateMode:DataTypes.InterestRateMode(params.interestRateModes[vars.i]),referralCode:params.referralCode,releaseUnderlying:false,maxStableRateBorrowSizePercent:params.maxStableRateBorrowSizePercent,reservesCount:params.reservesCount,oracle:IPoolAddressesProvider(params.addressesProvider).getPriceOracle(),userEModeCategory:params.userEModeCategory,priceOracleSentinel:IPoolAddressesProvider(params.addressesProvider).getPriceOracleSentinel()}))\n\t\tIRs:\n\t\t\tREF_406(address) -> vars.currentAsset\n\t\t\tREF_407(address) -> params.onBehalfOf\n\t\t\tREF_408(uint256) -> vars.currentAmount\n\t\t\tREF_409(uint256[]) -> params.interestRateModes\n\t\t\tREF_410(uint256) -> vars.i\n\t\t\tREF_411(uint256) -> REF_409[REF_410]\n\t\t\tTMP_586 = CONVERT REF_411 to DataTypes.InterestRateMode\n\t\t\tREF_412(uint16) -> params.referralCode\n\t\t\tREF_413(uint256) -> params.maxStableRateBorrowSizePercent\n\t\t\tREF_414(uint256) -> params.reservesCount\n\t\t\tREF_415(address) -> params.addressesProvider\n\t\t\tTMP_587 = CONVERT REF_415 to IPoolAddressesProvider\n\t\t\tTMP_588(address) = HIGH_LEVEL_CALL, dest:TMP_587(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_417(uint8) -> params.userEModeCategory\n\t\t\tREF_418(address) -> params.addressesProvider\n\t\t\tTMP_589 = CONVERT REF_418 to IPoolAddressesProvider\n\t\t\tTMP_590(address) = HIGH_LEVEL_CALL, dest:TMP_589(IPoolAddressesProvider), function:getPriceOracleSentinel, arguments:[]  \n\t\t\tTMP_591(DataTypes.ExecuteBorrowParams) = new ExecuteBorrowParams(REF_406,msg.sender,REF_407,REF_408,TMP_586,REF_412,False,REF_413,REF_414,TMP_588,REF_417,TMP_590)\n\t\t\tLIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteBorrowParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'TMP_591'] \n\t\tExpression: FlashLoan(params.receiverAddress,msg.sender,vars.currentAsset,vars.currentAmount,DataTypes.InterestRateMode(params.interestRateModes[vars.i]),0,params.referralCode)\n\t\tIRs:\n\t\t\tREF_420(address) -> params.receiverAddress\n\t\t\tREF_421(address) -> vars.currentAsset\n\t\t\tREF_422(uint256) -> vars.currentAmount\n\t\t\tREF_423(uint256[]) -> params.interestRateModes\n\t\t\tREF_424(uint256) -> vars.i\n\t\t\tREF_425(uint256) -> REF_423[REF_424]\n\t\t\tTMP_593 = CONVERT REF_425 to DataTypes.InterestRateMode\n\t\t\tREF_426(uint16) -> params.referralCode\n\t\t\tEmit FlashLoan(REF_420,msg.sender,REF_421,REF_422,TMP_593,0,REF_426)\n\t\tExpression: vars.i ++\n\t\tIRs:\n\t\t\tREF_427(uint256) -> vars.i\n\t\t\tTMP_595(uint256) := REF_427(uint256)\n\t\t\tREF_427(-> vars) = REF_427 (c)+ 1\n\t\tExpression: params.isAuthorizedFlashBorrower\n\t\tIRs:\n\t\t\tREF_428(bool) -> params.isAuthorizedFlashBorrower\n\t\t\tCONDITION REF_428\n\t\tExpression: (vars.flashloanPremiumTotal,vars.flashloanPremiumToProtocol) = (0,0)\n\t\tIRs:\n\t\t\tREF_429(uint256) -> vars.flashloanPremiumTotal\n\t\t\tREF_430(uint256) -> vars.flashloanPremiumToProtocol\n\t\t\tREF_429(uint256) (->vars) := 0(uint256)\n\t\t\tREF_430(uint256) (->vars) := 0(uint256)\n\t\tExpression: (vars.flashloanPremiumTotal,vars.flashloanPremiumToProtocol) = (params.flashLoanPremiumTotal,params.flashLoanPremiumToProtocol)\n\t\tIRs:\n\t\t\tREF_431(uint256) -> vars.flashloanPremiumTotal\n\t\t\tREF_432(uint256) -> vars.flashloanPremiumToProtocol\n\t\t\tREF_433(uint256) -> params.flashLoanPremiumTotal\n\t\t\tREF_434(uint256) -> params.flashLoanPremiumToProtocol\n\t\t\tREF_431(uint256) (->vars) := REF_433(uint256)\n\t\t\tREF_432(uint256) (->vars) := REF_434(uint256)\n\t\tExpression: DataTypes.InterestRateMode(params.interestRateModes[vars.i]) == DataTypes.InterestRateMode.NONE\n\t\tIRs:\n\t\t\tREF_435(uint256[]) -> params.interestRateModes\n\t\t\tREF_436(uint256) -> vars.i\n\t\t\tREF_437(uint256) -> REF_435[REF_436]\n\t\t\tTMP_596 = CONVERT REF_437 to DataTypes.InterestRateMode\n\t\t\tREF_438(DataTypes.InterestRateMode) -> InterestRateMode.NONE\n\t\t\tTMP_597(bool) = TMP_596 == REF_438\n\t\t\tCONDITION TMP_597\n\t\tExpression: vars.totalPremiums[vars.i] = vars.currentAmount.percentMul(vars.flashloanPremiumTotal)\n\t\tIRs:\n\t\t\tREF_439(uint256[]) -> vars.totalPremiums\n\t\t\tREF_440(uint256) -> vars.i\n\t\t\tREF_441(uint256) -> REF_439[REF_440]\n\t\t\tREF_442(uint256) -> vars.currentAmount\n\t\t\tREF_444(uint256) -> vars.flashloanPremiumTotal\n\t\t\tTMP_598(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_442', 'REF_444'] \n\t\t\tREF_441(uint256) (->vars) := TMP_598(uint256)\n\t\tExpression: vars.totalPremiums[vars.i] = 0\n\t\tIRs:\n\t\t\tREF_445(uint256[]) -> vars.totalPremiums\n\t\t\tREF_446(uint256) -> vars.i\n\t\t\tREF_447(uint256) -> REF_445[REF_446]\n\t\t\tREF_447(uint256) (->vars) := 0(uint256)\n\tFunction FlashLoanLogic.executeFlashLoanSimple(DataTypes.ReserveData,DataTypes.FlashloanSimpleParams) (*)\n\t\tExpression: ValidationLogic.validateFlashloanSimple(reserve)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateFlashloanSimple(DataTypes.ReserveData), arguments:['reserve'] \n\t\tExpression: receiver = IFlashLoanSimpleReceiver(params.receiverAddress)\n\t\tIRs:\n\t\t\tREF_449(address) -> params.receiverAddress\n\t\t\tTMP_600 = CONVERT REF_449 to IFlashLoanSimpleReceiver\n\t\t\treceiver(IFlashLoanSimpleReceiver) := TMP_600(IFlashLoanSimpleReceiver)\n\t\tExpression: totalPremium = params.amount.percentMul(params.flashLoanPremiumTotal)\n\t\tIRs:\n\t\t\tREF_450(uint256) -> params.amount\n\t\t\tREF_452(uint256) -> params.flashLoanPremiumTotal\n\t\t\tTMP_601(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_450', 'REF_452'] \n\t\t\ttotalPremium(uint256) := TMP_601(uint256)\n\t\tExpression: IAToken(reserve.aTokenAddress).transferUnderlyingTo(params.receiverAddress,params.amount)\n\t\tIRs:\n\t\t\tREF_453(address) -> reserve.aTokenAddress\n\t\t\tTMP_602 = CONVERT REF_453 to IAToken\n\t\t\tREF_455(address) -> params.receiverAddress\n\t\t\tREF_456(uint256) -> params.amount\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_602(IAToken), function:transferUnderlyingTo, arguments:['REF_455', 'REF_456']  \n\t\tExpression: require(bool,string)(receiver.executeOperation(params.asset,params.amount,totalPremium,msg.sender,params.params),Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN)\n\t\tIRs:\n\t\t\tREF_458(address) -> params.asset\n\t\t\tREF_459(uint256) -> params.amount\n\t\t\tREF_460(bytes) -> params.params\n\t\t\tTMP_604(bool) = HIGH_LEVEL_CALL, dest:receiver(IFlashLoanSimpleReceiver), function:executeOperation, arguments:['REF_458', 'REF_459', 'totalPremium', 'msg.sender', 'REF_460']  \n\t\t\tREF_461(string) -> Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN\n\t\t\tTMP_605(None) = SOLIDITY_CALL require(bool,string)(TMP_604,REF_461)\n\t\tExpression: _handleFlashLoanRepayment(reserve,DataTypes.FlashLoanRepaymentParams({asset:params.asset,receiverAddress:params.receiverAddress,amount:params.amount,totalPremium:totalPremium,flashLoanPremiumToProtocol:params.flashLoanPremiumToProtocol,referralCode:params.referralCode}))\n\t\tIRs:\n\t\t\tREF_463(address) -> params.asset\n\t\t\tREF_464(address) -> params.receiverAddress\n\t\t\tREF_465(uint256) -> params.amount\n\t\t\tREF_466(uint256) -> params.flashLoanPremiumToProtocol\n\t\t\tREF_467(uint16) -> params.referralCode\n\t\t\tTMP_606(DataTypes.FlashLoanRepaymentParams) = new FlashLoanRepaymentParams(REF_465,totalPremium,REF_466,REF_463,REF_464,REF_467)\n\t\t\tINTERNAL_CALL, FlashLoanLogic._handleFlashLoanRepayment(DataTypes.ReserveData,DataTypes.FlashLoanRepaymentParams)(reserve,TMP_606)\n\tFunction FlashLoanLogic._handleFlashLoanRepayment(DataTypes.ReserveData,DataTypes.FlashLoanRepaymentParams) (*)\n\t\tExpression: premiumToProtocol = params.totalPremium.percentMul(params.flashLoanPremiumToProtocol)\n\t\tIRs:\n\t\t\tREF_468(uint256) -> params.totalPremium\n\t\t\tREF_470(uint256) -> params.flashLoanPremiumToProtocol\n\t\t\tTMP_608(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_468', 'REF_470'] \n\t\t\tpremiumToProtocol(uint256) := TMP_608(uint256)\n\t\tExpression: premiumToLP = params.totalPremium - premiumToProtocol\n\t\tIRs:\n\t\t\tREF_471(uint256) -> params.totalPremium\n\t\t\tTMP_609(uint256) = REF_471 (c)- premiumToProtocol\n\t\t\tpremiumToLP(uint256) := TMP_609(uint256)\n\t\tExpression: amountPlusPremium = params.amount + params.totalPremium\n\t\tIRs:\n\t\t\tREF_472(uint256) -> params.amount\n\t\t\tREF_473(uint256) -> params.totalPremium\n\t\t\tTMP_610(uint256) = REF_472 (c)+ REF_473\n\t\t\tamountPlusPremium(uint256) := TMP_610(uint256)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_611(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_611(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(IERC20(reserveCache.aTokenAddress).totalSupply() + uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),premiumToLP)\n\t\tIRs:\n\t\t\tREF_476(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_478(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_613 = CONVERT REF_478 to IERC20\n\t\t\tTMP_614(uint256) = HIGH_LEVEL_CALL, dest:TMP_613(IERC20), function:totalSupply, arguments:[]  \n\t\t\tREF_480(uint128) -> reserve.accruedToTreasury\n\t\t\tTMP_615 = CONVERT REF_480 to uint256\n\t\t\tREF_482(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_616(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_615', 'REF_482'] \n\t\t\tTMP_617(uint256) = TMP_614 (c)+ TMP_616\n\t\t\tTMP_618(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cumulateToLiquidityIndex(DataTypes.ReserveData,uint256,uint256), arguments:['reserve', 'TMP_617', 'premiumToLP'] \n\t\t\tREF_476(uint256) (->reserveCache) := TMP_618(uint256)\n\t\tExpression: reserve.accruedToTreasury += premiumToProtocol.rayDiv(reserveCache.nextLiquidityIndex).toUint128()\n\t\tIRs:\n\t\t\tREF_483(uint128) -> reserve.accruedToTreasury\n\t\t\tREF_485(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_619(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['premiumToProtocol', 'REF_485'] \n\t\t\tTMP_620(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_619'] \n\t\t\tREF_483(-> reserve) = REF_483 (c)+ TMP_620\n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,amountPlusPremium,0)\n\t\tIRs:\n\t\t\tREF_488(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_488', 'amountPlusPremium', '0'] \n\t\tExpression: IERC20(params.asset).safeTransferFrom(params.receiverAddress,reserveCache.aTokenAddress,amountPlusPremium)\n\t\tIRs:\n\t\t\tREF_489(address) -> params.asset\n\t\t\tTMP_622 = CONVERT REF_489 to IERC20\n\t\t\tREF_491(address) -> params.receiverAddress\n\t\t\tREF_492(address) -> reserveCache.aTokenAddress\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_622', 'REF_491', 'REF_492', 'amountPlusPremium'] \n\t\tExpression: IAToken(reserveCache.aTokenAddress).handleRepayment(params.receiverAddress,params.receiverAddress,amountPlusPremium)\n\t\tIRs:\n\t\t\tREF_493(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_624 = CONVERT REF_493 to IAToken\n\t\t\tREF_495(address) -> params.receiverAddress\n\t\t\tREF_496(address) -> params.receiverAddress\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_624(IAToken), function:handleRepayment, arguments:['REF_495', 'REF_496', 'amountPlusPremium']  \n\t\tExpression: FlashLoan(params.receiverAddress,msg.sender,params.asset,params.amount,DataTypes.InterestRateMode(0),params.totalPremium,params.referralCode)\n\t\tIRs:\n\t\t\tREF_497(address) -> params.receiverAddress\n\t\t\tREF_498(address) -> params.asset\n\t\t\tREF_499(uint256) -> params.amount\n\t\t\tTMP_626 = CONVERT 0 to DataTypes.InterestRateMode\n\t\t\tREF_500(uint256) -> params.totalPremium\n\t\t\tREF_501(uint16) -> params.referralCode\n\t\t\tEmit FlashLoan(REF_497,msg.sender,REF_498,REF_499,TMP_626,REF_500,REF_501)\nContract GenericLogic\n\tFunction GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams) (*)\n\t\tExpression: params.userConfig.isEmpty()\n\t\tIRs:\n\t\t\tREF_502(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tTMP_628(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isEmpty(DataTypes.UserConfigurationMap), arguments:['REF_502'] \n\t\t\tCONDITION TMP_628\n\t\tExpression: (0,0,0,0,type()(uint256).max,false)\n\t\tIRs:\n\t\t\tTMP_630(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tRETURN 0,0,0,0,TMP_630,False\n\t\tExpression: params.userEModeCategory != 0\n\t\tIRs:\n\t\t\tREF_504(uint8) -> params.userEModeCategory\n\t\t\tTMP_631(bool) = REF_504 != 0\n\t\t\tCONDITION TMP_631\n\t\tExpression: (vars.eModeLtv,vars.eModeLiqThreshold,vars.eModeAssetPrice) = EModeLogic.getEModeConfiguration(eModeCategories[params.userEModeCategory],IPriceOracleGetter(params.oracle))\n\t\tIRs:\n\t\t\tREF_505(uint256) -> vars.eModeLtv\n\t\t\tREF_506(uint256) -> vars.eModeLiqThreshold\n\t\t\tREF_507(uint256) -> vars.eModeAssetPrice\n\t\t\tREF_509(uint8) -> params.userEModeCategory\n\t\t\tREF_510(DataTypes.EModeCategory) -> eModeCategories[REF_509]\n\t\t\tREF_511(address) -> params.oracle\n\t\t\tTMP_632 = CONVERT REF_511 to IPriceOracleGetter\n\t\t\tTUPLE_16(uint256,uint256,uint256) = LIBRARY_CALL, dest:EModeLogic, function:EModeLogic.getEModeConfiguration(DataTypes.EModeCategory,IPriceOracleGetter), arguments:['REF_510', 'TMP_632'] \n\t\t\tREF_505(uint256)= UNPACK TUPLE_16 index: 0 \n\t\t\tREF_506(uint256)= UNPACK TUPLE_16 index: 1 \n\t\t\tREF_507(uint256)= UNPACK TUPLE_16 index: 2 \n\t\tExpression: vars.i < params.reservesCount\n\t\tIRs:\n\t\t\tREF_512(uint256) -> vars.i\n\t\t\tREF_513(uint256) -> params.reservesCount\n\t\t\tTMP_633(bool) = REF_512 < REF_513\n\t\t\tCONDITION TMP_633\n\t\tExpression: ! params.userConfig.isUsingAsCollateralOrBorrowing(vars.i)\n\t\tIRs:\n\t\t\tREF_514(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_516(uint256) -> vars.i\n\t\t\tTMP_634(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateralOrBorrowing(DataTypes.UserConfigurationMap,uint256), arguments:['REF_514', 'REF_516'] \n\t\t\tTMP_635 = UnaryType.BANG TMP_634 \n\t\t\tCONDITION TMP_635\n\t\tExpression: ++ vars.i\n\t\tIRs:\n\t\t\tREF_517(uint256) -> vars.i\n\t\t\tREF_517(-> vars) = REF_517 + 1\n\t\tExpression: vars.currentReserveAddress = reservesList[vars.i]\n\t\tIRs:\n\t\t\tREF_518(address) -> vars.currentReserveAddress\n\t\t\tREF_519(uint256) -> vars.i\n\t\t\tREF_520(address) -> reservesList[REF_519]\n\t\t\tREF_518(address) (->vars) := REF_520(address)\n\t\tExpression: vars.currentReserveAddress == address(0)\n\t\tIRs:\n\t\t\tREF_521(address) -> vars.currentReserveAddress\n\t\t\tTMP_636 = CONVERT 0 to address\n\t\t\tTMP_637(bool) = REF_521 == TMP_636\n\t\t\tCONDITION TMP_637\n\t\tExpression: ++ vars.i\n\t\tIRs:\n\t\t\tREF_522(uint256) -> vars.i\n\t\t\tREF_522(-> vars) = REF_522 + 1\n\t\tExpression: currentReserve = reservesData[vars.currentReserveAddress]\n\t\tIRs:\n\t\t\tREF_523(address) -> vars.currentReserveAddress\n\t\t\tREF_524(DataTypes.ReserveData) -> reservesData[REF_523]\n\t\t\tcurrentReserve(DataTypes.ReserveData) := REF_524(DataTypes.ReserveData)\n\t\tExpression: (vars.ltv,vars.liquidationThreshold,None,vars.decimals,None,vars.eModeAssetCategory) = currentReserve.configuration.getParams()\n\t\tIRs:\n\t\t\tREF_525(uint256) -> vars.ltv\n\t\t\tREF_526(uint256) -> vars.liquidationThreshold\n\t\t\tREF_527(uint256) -> vars.decimals\n\t\t\tREF_528(uint256) -> vars.eModeAssetCategory\n\t\t\tREF_529(DataTypes.ReserveConfigurationMap) -> currentReserve.configuration\n\t\t\tTUPLE_17(uint256,uint256,uint256,uint256,uint256,uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getParams(DataTypes.ReserveConfigurationMap), arguments:['REF_529'] \n\t\t\tREF_525(uint256)= UNPACK TUPLE_17 index: 0 \n\t\t\tREF_526(uint256)= UNPACK TUPLE_17 index: 1 \n\t\t\tREF_527(uint256)= UNPACK TUPLE_17 index: 3 \n\t\t\tREF_528(uint256)= UNPACK TUPLE_17 index: 5 \n\t\tExpression: vars.assetUnit = 10 ** vars.decimals\n\t\tIRs:\n\t\t\tREF_531(uint256) -> vars.assetUnit\n\t\t\tREF_532(uint256) -> vars.decimals\n\t\t\tTMP_638(uint256) = 10 ** REF_532\n\t\t\tREF_531(uint256) (->vars) := TMP_638(uint256)\n\t\tExpression: vars.liquidationThreshold != 0 && params.userConfig.isUsingAsCollateral(vars.i)\n\t\tIRs:\n\t\t\tREF_533(uint256) -> vars.liquidationThreshold\n\t\t\tTMP_639(bool) = REF_533 != 0\n\t\t\tREF_534(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_536(uint256) -> vars.i\n\t\t\tTMP_640(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['REF_534', 'REF_536'] \n\t\t\tTMP_641(bool) = TMP_639 && TMP_640\n\t\t\tCONDITION TMP_641\n\t\tExpression: vars.userBalanceInBaseCurrency = _getUserBalanceInBaseCurrency(params.user,currentReserve,vars.assetPrice,vars.assetUnit)\n\t\tIRs:\n\t\t\tREF_537(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_538(address) -> params.user\n\t\t\tREF_539(uint256) -> vars.assetPrice\n\t\t\tREF_540(uint256) -> vars.assetUnit\n\t\t\tTMP_642(uint256) = INTERNAL_CALL, GenericLogic._getUserBalanceInBaseCurrency(address,DataTypes.ReserveData,uint256,uint256)(REF_538,currentReserve,REF_539,REF_540)\n\t\t\tREF_537(uint256) (->vars) := TMP_642(uint256)\n\t\tExpression: vars.totalCollateralInBaseCurrency += vars.userBalanceInBaseCurrency\n\t\tIRs:\n\t\t\tREF_541(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tREF_542(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_541(-> vars) = REF_541 (c)+ REF_542\n\t\tExpression: vars.isInEModeCategory = EModeLogic.isInEModeCategory(params.userEModeCategory,vars.eModeAssetCategory)\n\t\tIRs:\n\t\t\tREF_543(bool) -> vars.isInEModeCategory\n\t\t\tREF_545(uint8) -> params.userEModeCategory\n\t\t\tREF_546(uint256) -> vars.eModeAssetCategory\n\t\t\tTMP_643(bool) = LIBRARY_CALL, dest:EModeLogic, function:EModeLogic.isInEModeCategory(uint256,uint256), arguments:['REF_545', 'REF_546'] \n\t\t\tREF_543(bool) (->vars) := TMP_643(bool)\n\t\tExpression: vars.ltv != 0\n\t\tIRs:\n\t\t\tREF_547(uint256) -> vars.ltv\n\t\t\tTMP_644(bool) = REF_547 != 0\n\t\t\tCONDITION TMP_644\n\t\tExpression: vars.hasZeroLtvCollateral = true\n\t\tIRs:\n\t\t\tREF_548(bool) -> vars.hasZeroLtvCollateral\n\t\t\tREF_548(bool) (->vars) := True(bool)\n\t\tExpression: params.userConfig.isBorrowing(vars.i)\n\t\tIRs:\n\t\t\tREF_549(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_551(uint256) -> vars.i\n\t\t\tTMP_645(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowing(DataTypes.UserConfigurationMap,uint256), arguments:['REF_549', 'REF_551'] \n\t\t\tCONDITION TMP_645\n\t\tExpression: vars.totalDebtInBaseCurrency += _getUserDebtInBaseCurrency(params.user,currentReserve,vars.assetPrice,vars.assetUnit)\n\t\tIRs:\n\t\t\tREF_552(uint256) -> vars.totalDebtInBaseCurrency\n\t\t\tREF_553(address) -> params.user\n\t\t\tREF_554(uint256) -> vars.assetPrice\n\t\t\tREF_555(uint256) -> vars.assetUnit\n\t\t\tTMP_646(uint256) = INTERNAL_CALL, GenericLogic._getUserDebtInBaseCurrency(address,DataTypes.ReserveData,uint256,uint256)(REF_553,currentReserve,REF_554,REF_555)\n\t\t\tREF_552(-> vars) = REF_552 (c)+ TMP_646\n\t\tExpression: ++ vars.i\n\t\tIRs:\n\t\t\tREF_556(uint256) -> vars.i\n\t\t\tREF_556(-> vars) = REF_556 + 1\n\t\tExpression: (vars.totalCollateralInBaseCurrency,vars.totalDebtInBaseCurrency,vars.avgLtv,vars.avgLiquidationThreshold,vars.healthFactor,vars.hasZeroLtvCollateral)\n\t\tIRs:\n\t\t\tREF_557(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tREF_558(uint256) -> vars.totalDebtInBaseCurrency\n\t\t\tREF_559(uint256) -> vars.avgLtv\n\t\t\tREF_560(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_561(uint256) -> vars.healthFactor\n\t\t\tREF_562(bool) -> vars.hasZeroLtvCollateral\n\t\t\tRETURN REF_557,REF_558,REF_559,REF_560,REF_561,REF_562\n\t\tExpression: vars.eModeAssetPrice != 0 && params.userEModeCategory == vars.eModeAssetCategory\n\t\tIRs:\n\t\t\tREF_563(uint256) -> vars.eModeAssetPrice\n\t\t\tTMP_647(bool) = REF_563 != 0\n\t\t\tREF_564(uint8) -> params.userEModeCategory\n\t\t\tREF_565(uint256) -> vars.eModeAssetCategory\n\t\t\tTMP_648(bool) = REF_564 == REF_565\n\t\t\tTMP_649(bool) = TMP_647 && TMP_648\n\t\t\tCONDITION TMP_649\n\t\tExpression: vars.assetPrice = vars.eModeAssetPrice\n\t\tIRs:\n\t\t\tREF_566(uint256) -> vars.assetPrice\n\t\t\tREF_567(uint256) -> vars.eModeAssetPrice\n\t\t\tREF_566(uint256) (->vars) := REF_567(uint256)\n\t\tExpression: vars.assetPrice = IPriceOracleGetter(params.oracle).getAssetPrice(vars.currentReserveAddress)\n\t\tIRs:\n\t\t\tREF_568(uint256) -> vars.assetPrice\n\t\t\tREF_569(address) -> params.oracle\n\t\t\tTMP_650 = CONVERT REF_569 to IPriceOracleGetter\n\t\t\tREF_571(address) -> vars.currentReserveAddress\n\t\t\tTMP_651(uint256) = HIGH_LEVEL_CALL, dest:TMP_650(IPriceOracleGetter), function:getAssetPrice, arguments:['REF_571']  \n\t\t\tREF_568(uint256) (->vars) := TMP_651(uint256)\n\t\tExpression: vars.isInEModeCategory\n\t\tIRs:\n\t\t\tREF_572(bool) -> vars.isInEModeCategory\n\t\t\tCONDITION REF_572\n\t\tExpression: vars.avgLtv += vars.userBalanceInBaseCurrency * vars.eModeLtv\n\t\tIRs:\n\t\t\tREF_573(uint256) -> vars.avgLtv\n\t\t\tREF_574(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_575(uint256) -> vars.eModeLtv\n\t\t\tTMP_652(uint256) = REF_574 (c)* REF_575\n\t\t\tREF_573(-> vars) = REF_573 (c)+ TMP_652\n\t\tExpression: vars.avgLtv += vars.userBalanceInBaseCurrency * vars.ltv\n\t\tIRs:\n\t\t\tREF_576(uint256) -> vars.avgLtv\n\t\t\tREF_577(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_578(uint256) -> vars.ltv\n\t\t\tTMP_653(uint256) = REF_577 (c)* REF_578\n\t\t\tREF_576(-> vars) = REF_576 (c)+ TMP_653\n\t\tExpression: vars.isInEModeCategory\n\t\tIRs:\n\t\t\tREF_579(bool) -> vars.isInEModeCategory\n\t\t\tCONDITION REF_579\n\t\tExpression: vars.avgLiquidationThreshold += vars.userBalanceInBaseCurrency * vars.eModeLiqThreshold\n\t\tIRs:\n\t\t\tREF_580(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_581(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_582(uint256) -> vars.eModeLiqThreshold\n\t\t\tTMP_654(uint256) = REF_581 (c)* REF_582\n\t\t\tREF_580(-> vars) = REF_580 (c)+ TMP_654\n\t\tExpression: vars.avgLiquidationThreshold += vars.userBalanceInBaseCurrency * vars.liquidationThreshold\n\t\tIRs:\n\t\t\tREF_583(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_584(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_585(uint256) -> vars.liquidationThreshold\n\t\t\tTMP_655(uint256) = REF_584 (c)* REF_585\n\t\t\tREF_583(-> vars) = REF_583 (c)+ TMP_655\n\t\tExpression: vars.totalCollateralInBaseCurrency != 0\n\t\tIRs:\n\t\t\tREF_586(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tTMP_656(bool) = REF_586 != 0\n\t\t\tCONDITION TMP_656\n\t\tExpression: vars.avgLtv = vars.avgLtv / vars.totalCollateralInBaseCurrency\n\t\tIRs:\n\t\t\tREF_587(uint256) -> vars.avgLtv\n\t\t\tREF_588(uint256) -> vars.avgLtv\n\t\t\tREF_589(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tTMP_657(uint256) = REF_588 / REF_589\n\t\t\tREF_587(uint256) (->vars) := TMP_657(uint256)\n\t\tExpression: vars.avgLtv = 0\n\t\tIRs:\n\t\t\tREF_590(uint256) -> vars.avgLtv\n\t\t\tREF_590(uint256) (->vars) := 0(uint256)\n\t\tExpression: vars.totalCollateralInBaseCurrency != 0\n\t\tIRs:\n\t\t\tREF_591(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tTMP_658(bool) = REF_591 != 0\n\t\t\tCONDITION TMP_658\n\t\tExpression: vars.avgLiquidationThreshold = vars.avgLiquidationThreshold / vars.totalCollateralInBaseCurrency\n\t\tIRs:\n\t\t\tREF_592(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_593(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_594(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tTMP_659(uint256) = REF_593 / REF_594\n\t\t\tREF_592(uint256) (->vars) := TMP_659(uint256)\n\t\tExpression: vars.avgLiquidationThreshold = 0\n\t\tIRs:\n\t\t\tREF_595(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_595(uint256) (->vars) := 0(uint256)\n\t\tExpression: (vars.totalDebtInBaseCurrency == 0)\n\t\tIRs:\n\t\t\tREF_596(uint256) -> vars.totalDebtInBaseCurrency\n\t\t\tTMP_660(bool) = REF_596 == 0\n\t\t\tCONDITION TMP_660\n\t\tExpression: vars.healthFactor = type()(uint256).max\n\t\tIRs:\n\t\t\tREF_597(uint256) -> vars.healthFactor\n\t\t\tTMP_662(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tREF_597(uint256) (->vars) := TMP_662(uint256)\n\t\tExpression: vars.healthFactor = (vars.totalCollateralInBaseCurrency.percentMul(vars.avgLiquidationThreshold)).wadDiv(vars.totalDebtInBaseCurrency)\n\t\tIRs:\n\t\t\tREF_598(uint256) -> vars.healthFactor\n\t\t\tREF_599(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tREF_601(uint256) -> vars.avgLiquidationThreshold\n\t\t\tTMP_663(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_599', 'REF_601'] \n\t\t\tREF_603(uint256) -> vars.totalDebtInBaseCurrency\n\t\t\tTMP_664(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.wadDiv(uint256,uint256), arguments:['TMP_663', 'REF_603'] \n\t\t\tREF_598(uint256) (->vars) := TMP_664(uint256)\n\tFunction GenericLogic.calculateAvailableBorrows(uint256,uint256,uint256) (*)\n\t\tExpression: availableBorrowsInBaseCurrency = totalCollateralInBaseCurrency.percentMul(ltv)\n\t\tIRs:\n\t\t\tTMP_665(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['totalCollateralInBaseCurrency', 'ltv'] \n\t\t\tavailableBorrowsInBaseCurrency(uint256) := TMP_665(uint256)\n\t\tExpression: availableBorrowsInBaseCurrency < totalDebtInBaseCurrency\n\t\tIRs:\n\t\t\tTMP_666(bool) = availableBorrowsInBaseCurrency < totalDebtInBaseCurrency\n\t\t\tCONDITION TMP_666\n\t\tExpression: 0\n\t\tIRs:\n\t\t\tRETURN 0\n\t\tExpression: availableBorrowsInBaseCurrency = availableBorrowsInBaseCurrency - totalDebtInBaseCurrency\n\t\tIRs:\n\t\t\tTMP_667(uint256) = availableBorrowsInBaseCurrency (c)- totalDebtInBaseCurrency\n\t\t\tavailableBorrowsInBaseCurrency(uint256) := TMP_667(uint256)\n\t\tExpression: availableBorrowsInBaseCurrency\n\t\tIRs:\n\t\t\tRETURN availableBorrowsInBaseCurrency\n\tFunction GenericLogic._getUserDebtInBaseCurrency(address,DataTypes.ReserveData,uint256,uint256) (*)\n\t\tExpression: userTotalDebt = IScaledBalanceToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user)\n\t\tIRs:\n\t\t\tREF_605(address) -> reserve.variableDebtTokenAddress\n\t\t\tTMP_668 = CONVERT REF_605 to IScaledBalanceToken\n\t\t\tTMP_669(uint256) = HIGH_LEVEL_CALL, dest:TMP_668(IScaledBalanceToken), function:scaledBalanceOf, arguments:['user']  \n\t\t\tuserTotalDebt(uint256) := TMP_669(uint256)\n\t\tExpression: userTotalDebt != 0\n\t\tIRs:\n\t\t\tTMP_670(bool) = userTotalDebt != 0\n\t\t\tCONDITION TMP_670\n\t\tExpression: userTotalDebt = userTotalDebt.rayMul(reserve.getNormalizedDebt())\n\t\tIRs:\n\t\t\tTMP_671(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedDebt(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\tTMP_672(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['userTotalDebt', 'TMP_671'] \n\t\t\tuserTotalDebt(uint256) := TMP_672(uint256)\n\t\tExpression: userTotalDebt = userTotalDebt + IERC20(reserve.stableDebtTokenAddress).balanceOf(user)\n\t\tIRs:\n\t\t\tREF_609(address) -> reserve.stableDebtTokenAddress\n\t\t\tTMP_673 = CONVERT REF_609 to IERC20\n\t\t\tTMP_674(uint256) = HIGH_LEVEL_CALL, dest:TMP_673(IERC20), function:balanceOf, arguments:['user']  \n\t\t\tTMP_675(uint256) = userTotalDebt (c)+ TMP_674\n\t\t\tuserTotalDebt(uint256) := TMP_675(uint256)\n\t\tExpression: userTotalDebt = assetPrice * userTotalDebt\n\t\tIRs:\n\t\t\tTMP_676(uint256) = assetPrice (c)* userTotalDebt\n\t\t\tuserTotalDebt(uint256) := TMP_676(uint256)\n\t\tExpression: userTotalDebt / assetUnit\n\t\tIRs:\n\t\t\tTMP_677(uint256) = userTotalDebt / assetUnit\n\t\t\tRETURN TMP_677\n\tFunction GenericLogic._getUserBalanceInBaseCurrency(address,DataTypes.ReserveData,uint256,uint256) (*)\n\t\tExpression: normalizedIncome = reserve.getNormalizedIncome()\n\t\tIRs:\n\t\t\tTMP_678(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedIncome(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\tnormalizedIncome(uint256) := TMP_678(uint256)\n\t\tExpression: balance = (IScaledBalanceToken(reserve.aTokenAddress).scaledBalanceOf(user).rayMul(normalizedIncome)) * assetPrice\n\t\tIRs:\n\t\t\tREF_612(address) -> reserve.aTokenAddress\n\t\t\tTMP_679 = CONVERT REF_612 to IScaledBalanceToken\n\t\t\tTMP_680(uint256) = HIGH_LEVEL_CALL, dest:TMP_679(IScaledBalanceToken), function:scaledBalanceOf, arguments:['user']  \n\t\t\tTMP_681(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_680', 'normalizedIncome'] \n\t\t\tTMP_682(uint256) = TMP_681 (c)* assetPrice\n\t\t\tbalance(uint256) := TMP_682(uint256)\n\t\tExpression: balance / assetUnit\n\t\tIRs:\n\t\t\tTMP_683(uint256) = balance / assetUnit\n\t\t\tRETURN TMP_683\nContract IsolationModeLogic\n\tFunction IsolationModeLogic.updateIsolatedDebtIfIsolated(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveCache,uint256) (*)\n\t\tExpression: (isolationModeActive,isolationModeCollateralAddress,None) = userConfig.getIsolationModeState(reservesData,reservesList)\n\t\tIRs:\n\t\t\tTUPLE_18(bool,address,uint256) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.getIsolationModeState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)), arguments:['userConfig', 'reservesData', 'reservesList'] \n\t\t\tisolationModeActive(bool)= UNPACK TUPLE_18 index: 0 \n\t\t\tisolationModeCollateralAddress(address)= UNPACK TUPLE_18 index: 1 \n\t\tExpression: isolationModeActive\n\t\tIRs:\n\t\t\tCONDITION isolationModeActive\n\t\tExpression: isolationModeTotalDebt = reservesData[isolationModeCollateralAddress].isolationModeTotalDebt\n\t\tIRs:\n\t\t\tREF_616(DataTypes.ReserveData) -> reservesData[isolationModeCollateralAddress]\n\t\t\tREF_617(uint128) -> REF_616.isolationModeTotalDebt\n\t\t\tisolationModeTotalDebt(uint128) := REF_617(uint128)\n\t\tExpression: isolatedDebtRepaid = (repayAmount / 10 ** (reserveCache.reserveConfiguration.getDecimals() - ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128()\n\t\tIRs:\n\t\t\tREF_618(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_684(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_618'] \n\t\t\tREF_620(uint256) -> ReserveConfiguration.DEBT_CEILING_DECIMALS\n\t\t\tTMP_685(uint256) = TMP_684 (c)- REF_620\n\t\t\tTMP_686(uint256) = 10 (c)** TMP_685\n\t\t\tTMP_687(uint256) = repayAmount (c)/ TMP_686\n\t\t\tTMP_688(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_687'] \n\t\t\tisolatedDebtRepaid(uint128) := TMP_688(uint128)\n\t\tExpression: isolationModeTotalDebt <= isolatedDebtRepaid\n\t\tIRs:\n\t\t\tTMP_689(bool) = isolationModeTotalDebt <= isolatedDebtRepaid\n\t\t\tCONDITION TMP_689\n\t\tExpression: reservesData[isolationModeCollateralAddress].isolationModeTotalDebt = 0\n\t\tIRs:\n\t\t\tREF_622(DataTypes.ReserveData) -> reservesData[isolationModeCollateralAddress]\n\t\t\tREF_623(uint128) -> REF_622.isolationModeTotalDebt\n\t\t\tREF_623(uint128) (->reservesData) := 0(uint256)\n\t\tExpression: IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,0)\n\t\tIRs:\n\t\t\tEmit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,0)\n\t\tExpression: nextIsolationModeTotalDebt = reservesData[isolationModeCollateralAddress].isolationModeTotalDebt = isolationModeTotalDebt - isolatedDebtRepaid\n\t\tIRs:\n\t\t\tREF_624(DataTypes.ReserveData) -> reservesData[isolationModeCollateralAddress]\n\t\t\tREF_625(uint128) -> REF_624.isolationModeTotalDebt\n\t\t\tTMP_691(uint128) = isolationModeTotalDebt (c)- isolatedDebtRepaid\n\t\t\tREF_625(uint128) (->reservesData) := TMP_691(uint128)\n\t\t\tnextIsolationModeTotalDebt(uint256) := REF_625(uint128)\n\t\tExpression: IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,nextIsolationModeTotalDebt)\n\t\tIRs:\n\t\t\tEmit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,nextIsolationModeTotalDebt)\nContract LiquidationLogic\n\tFunction LiquidationLogic.executeLiquidationCall(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(address => DataTypes.UserConfigurationMap),mapping(uint8 => DataTypes.EModeCategory),DataTypes.ExecuteLiquidationCallParams) (*)\n\t\tExpression: collateralReserve = reservesData[params.collateralAsset]\n\t\tIRs:\n\t\t\tREF_626(address) -> params.collateralAsset\n\t\t\tREF_627(DataTypes.ReserveData) -> reservesData[REF_626]\n\t\t\tcollateralReserve(DataTypes.ReserveData) := REF_627(DataTypes.ReserveData)\n\t\tExpression: debtReserve = reservesData[params.debtAsset]\n\t\tIRs:\n\t\t\tREF_628(address) -> params.debtAsset\n\t\t\tREF_629(DataTypes.ReserveData) -> reservesData[REF_628]\n\t\t\tdebtReserve(DataTypes.ReserveData) := REF_629(DataTypes.ReserveData)\n\t\tExpression: userConfig = usersConfig[params.user]\n\t\tIRs:\n\t\t\tREF_630(address) -> params.user\n\t\t\tREF_631(DataTypes.UserConfigurationMap) -> usersConfig[REF_630]\n\t\t\tuserConfig(DataTypes.UserConfigurationMap) := REF_631(DataTypes.UserConfigurationMap)\n\t\tExpression: vars.debtReserveCache = debtReserve.cache()\n\t\tIRs:\n\t\t\tREF_632(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tTMP_693(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['debtReserve'] \n\t\t\tREF_632(DataTypes.ReserveCache) (->vars) := TMP_693(DataTypes.ReserveCache)\n\t\tExpression: debtReserve.updateState(vars.debtReserveCache)\n\t\tIRs:\n\t\t\tREF_635(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['debtReserve', 'REF_635'] \n\t\tExpression: (None,None,None,None,vars.healthFactor,None) = GenericLogic.calculateUserAccountData(reservesData,reservesList,eModeCategories,DataTypes.CalculateUserAccountDataParams({userConfig:userConfig,reservesCount:params.reservesCount,user:params.user,oracle:params.priceOracle,userEModeCategory:params.userEModeCategory}))\n\t\tIRs:\n\t\t\tREF_636(uint256) -> vars.healthFactor\n\t\t\tREF_639(uint256) -> params.reservesCount\n\t\t\tREF_640(address) -> params.user\n\t\t\tREF_641(address) -> params.priceOracle\n\t\t\tREF_642(uint8) -> params.userEModeCategory\n\t\t\tTMP_695(DataTypes.CalculateUserAccountDataParams) = new CalculateUserAccountDataParams(userConfig,REF_639,REF_640,REF_641,REF_642)\n\t\t\tTUPLE_19(uint256,uint256,uint256,uint256,uint256,bool) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'TMP_695'] \n\t\t\tREF_636(uint256)= UNPACK TUPLE_19 index: 4 \n\t\tExpression: (vars.userVariableDebt,vars.userTotalDebt,vars.actualDebtToLiquidate) = _calculateDebt(vars.debtReserveCache,params,vars.healthFactor)\n\t\tIRs:\n\t\t\tREF_643(uint256) -> vars.userVariableDebt\n\t\t\tREF_644(uint256) -> vars.userTotalDebt\n\t\t\tREF_645(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_646(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_647(uint256) -> vars.healthFactor\n\t\t\tTUPLE_20(uint256,uint256,uint256) = INTERNAL_CALL, LiquidationLogic._calculateDebt(DataTypes.ReserveCache,DataTypes.ExecuteLiquidationCallParams,uint256)(REF_646,params,REF_647)\n\t\t\tREF_643(uint256)= UNPACK TUPLE_20 index: 0 \n\t\t\tREF_644(uint256)= UNPACK TUPLE_20 index: 1 \n\t\t\tREF_645(uint256)= UNPACK TUPLE_20 index: 2 \n\t\tExpression: ValidationLogic.validateLiquidationCall(userConfig,collateralReserve,DataTypes.ValidateLiquidationCallParams({debtReserveCache:vars.debtReserveCache,totalDebt:vars.userTotalDebt,healthFactor:vars.healthFactor,priceOracleSentinel:params.priceOracleSentinel}))\n\t\tIRs:\n\t\t\tREF_650(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_651(uint256) -> vars.userTotalDebt\n\t\t\tREF_652(uint256) -> vars.healthFactor\n\t\t\tREF_653(address) -> params.priceOracleSentinel\n\t\t\tTMP_696(DataTypes.ValidateLiquidationCallParams) = new ValidateLiquidationCallParams(REF_650,REF_651,REF_652,REF_653)\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateLiquidationCall(DataTypes.UserConfigurationMap,DataTypes.ReserveData,DataTypes.ValidateLiquidationCallParams), arguments:['userConfig', 'collateralReserve', 'TMP_696'] \n\t\tExpression: (vars.collateralAToken,vars.collateralPriceSource,vars.debtPriceSource,vars.liquidationBonus) = _getConfigurationData(eModeCategories,collateralReserve,params)\n\t\tIRs:\n\t\t\tREF_654(IAToken) -> vars.collateralAToken\n\t\t\tREF_655(address) -> vars.collateralPriceSource\n\t\t\tREF_656(address) -> vars.debtPriceSource\n\t\t\tREF_657(uint256) -> vars.liquidationBonus\n\t\t\tTUPLE_21(IAToken,address,address,uint256) = INTERNAL_CALL, LiquidationLogic._getConfigurationData(mapping(uint8 => DataTypes.EModeCategory),DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams)(eModeCategories,collateralReserve,params)\n\t\t\tREF_654(IAToken)= UNPACK TUPLE_21 index: 0 \n\t\t\tREF_655(address)= UNPACK TUPLE_21 index: 1 \n\t\t\tREF_656(address)= UNPACK TUPLE_21 index: 2 \n\t\t\tREF_657(uint256)= UNPACK TUPLE_21 index: 3 \n\t\tExpression: vars.userCollateralBalance = vars.collateralAToken.balanceOf(params.user)\n\t\tIRs:\n\t\t\tREF_658(uint256) -> vars.userCollateralBalance\n\t\t\tREF_659(IAToken) -> vars.collateralAToken\n\t\t\tREF_661(address) -> params.user\n\t\t\tTMP_698(uint256) = HIGH_LEVEL_CALL, dest:REF_659(IAToken), function:balanceOf, arguments:['REF_661']  \n\t\t\tREF_658(uint256) (->vars) := TMP_698(uint256)\n\t\tExpression: (vars.actualCollateralToLiquidate,vars.actualDebtToLiquidate,vars.liquidationProtocolFeeAmount) = _calculateAvailableCollateralToLiquidate(collateralReserve,vars.debtReserveCache,vars.collateralPriceSource,vars.debtPriceSource,vars.actualDebtToLiquidate,vars.userCollateralBalance,vars.liquidationBonus,IPriceOracleGetter(params.priceOracle))\n\t\tIRs:\n\t\t\tREF_662(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tREF_663(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_664(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tREF_665(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_666(address) -> vars.collateralPriceSource\n\t\t\tREF_667(address) -> vars.debtPriceSource\n\t\t\tREF_668(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_669(uint256) -> vars.userCollateralBalance\n\t\t\tREF_670(uint256) -> vars.liquidationBonus\n\t\t\tREF_671(address) -> params.priceOracle\n\t\t\tTMP_699 = CONVERT REF_671 to IPriceOracleGetter\n\t\t\tTUPLE_22(uint256,uint256,uint256) = INTERNAL_CALL, LiquidationLogic._calculateAvailableCollateralToLiquidate(DataTypes.ReserveData,DataTypes.ReserveCache,address,address,uint256,uint256,uint256,IPriceOracleGetter)(collateralReserve,REF_665,REF_666,REF_667,REF_668,REF_669,REF_670,TMP_699)\n\t\t\tREF_662(uint256)= UNPACK TUPLE_22 index: 0 \n\t\t\tREF_663(uint256)= UNPACK TUPLE_22 index: 1 \n\t\t\tREF_664(uint256)= UNPACK TUPLE_22 index: 2 \n\t\tExpression: vars.userTotalDebt == vars.actualDebtToLiquidate\n\t\tIRs:\n\t\t\tREF_672(uint256) -> vars.userTotalDebt\n\t\t\tREF_673(uint256) -> vars.actualDebtToLiquidate\n\t\t\tTMP_700(bool) = REF_672 == REF_673\n\t\t\tCONDITION TMP_700\n\t\tExpression: userConfig.setBorrowing(debtReserve.id,false)\n\t\tIRs:\n\t\t\tREF_675(uint16) -> debtReserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setBorrowing(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_675', 'False'] \n\t\tExpression: vars.actualCollateralToLiquidate + vars.liquidationProtocolFeeAmount == vars.userCollateralBalance\n\t\tIRs:\n\t\t\tREF_676(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tREF_677(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tTMP_702(uint256) = REF_676 (c)+ REF_677\n\t\t\tREF_678(uint256) -> vars.userCollateralBalance\n\t\t\tTMP_703(bool) = TMP_702 == REF_678\n\t\t\tCONDITION TMP_703\n\t\tExpression: userConfig.setUsingAsCollateral(collateralReserve.id,false)\n\t\tIRs:\n\t\t\tREF_680(uint16) -> collateralReserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_680', 'False'] \n\t\tExpression: ReserveUsedAsCollateralDisabled(params.collateralAsset,params.user)\n\t\tIRs:\n\t\t\tREF_681(address) -> params.collateralAsset\n\t\t\tREF_682(address) -> params.user\n\t\t\tEmit ReserveUsedAsCollateralDisabled(REF_681,REF_682)\n\t\tExpression: _burnDebtTokens(params,vars)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, LiquidationLogic._burnDebtTokens(DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars)(params,vars)\n\t\tExpression: debtReserve.updateInterestRates(vars.debtReserveCache,params.debtAsset,vars.actualDebtToLiquidate,0)\n\t\tIRs:\n\t\t\tREF_684(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_685(address) -> params.debtAsset\n\t\t\tREF_686(uint256) -> vars.actualDebtToLiquidate\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['debtReserve', 'REF_684', 'REF_685', 'REF_686', '0'] \n\t\tExpression: IsolationModeLogic.updateIsolatedDebtIfIsolated(reservesData,reservesList,userConfig,vars.debtReserveCache,vars.actualDebtToLiquidate)\n\t\tIRs:\n\t\t\tREF_688(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_689(uint256) -> vars.actualDebtToLiquidate\n\t\t\tLIBRARY_CALL, dest:IsolationModeLogic, function:IsolationModeLogic.updateIsolatedDebtIfIsolated(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveCache,uint256), arguments:['reservesData', 'reservesList', 'userConfig', 'REF_688', 'REF_689'] \n\t\tExpression: params.receiveAToken\n\t\tIRs:\n\t\t\tREF_690(bool) -> params.receiveAToken\n\t\t\tCONDITION REF_690\n\t\tExpression: _liquidateATokens(reservesData,reservesList,usersConfig,collateralReserve,params,vars)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, LiquidationLogic._liquidateATokens(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(address => DataTypes.UserConfigurationMap),DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars)(reservesData,reservesList,usersConfig,collateralReserve,params,vars)\n\t\tExpression: _burnCollateralATokens(collateralReserve,params,vars)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, LiquidationLogic._burnCollateralATokens(DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars)(collateralReserve,params,vars)\n\t\tExpression: vars.liquidationProtocolFeeAmount != 0\n\t\tIRs:\n\t\t\tREF_691(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tTMP_711(bool) = REF_691 != 0\n\t\t\tCONDITION TMP_711\n\t\tExpression: liquidityIndex = collateralReserve.getNormalizedIncome()\n\t\tIRs:\n\t\t\tTMP_712(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedIncome(DataTypes.ReserveData), arguments:['collateralReserve'] \n\t\t\tliquidityIndex(uint256) := TMP_712(uint256)\n\t\tExpression: scaledDownLiquidationProtocolFee = vars.liquidationProtocolFeeAmount.rayDiv(liquidityIndex)\n\t\tIRs:\n\t\t\tREF_693(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tTMP_713(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['REF_693', 'liquidityIndex'] \n\t\t\tscaledDownLiquidationProtocolFee(uint256) := TMP_713(uint256)\n\t\tExpression: scaledDownUserBalance = vars.collateralAToken.scaledBalanceOf(params.user)\n\t\tIRs:\n\t\t\tREF_695(IAToken) -> vars.collateralAToken\n\t\t\tREF_697(address) -> params.user\n\t\t\tTMP_714(uint256) = HIGH_LEVEL_CALL, dest:REF_695(IAToken), function:scaledBalanceOf, arguments:['REF_697']  \n\t\t\tscaledDownUserBalance(uint256) := TMP_714(uint256)\n\t\tExpression: scaledDownLiquidationProtocolFee > scaledDownUserBalance\n\t\tIRs:\n\t\t\tTMP_715(bool) = scaledDownLiquidationProtocolFee > scaledDownUserBalance\n\t\t\tCONDITION TMP_715\n\t\tExpression: vars.liquidationProtocolFeeAmount = scaledDownUserBalance.rayMul(liquidityIndex)\n\t\tIRs:\n\t\t\tREF_698(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tTMP_716(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['scaledDownUserBalance', 'liquidityIndex'] \n\t\t\tREF_698(uint256) (->vars) := TMP_716(uint256)\n\t\tExpression: vars.collateralAToken.transferOnLiquidation(params.user,vars.collateralAToken.RESERVE_TREASURY_ADDRESS(),vars.liquidationProtocolFeeAmount)\n\t\tIRs:\n\t\t\tREF_700(IAToken) -> vars.collateralAToken\n\t\t\tREF_702(address) -> params.user\n\t\t\tREF_703(IAToken) -> vars.collateralAToken\n\t\t\tTMP_717(address) = HIGH_LEVEL_CALL, dest:REF_703(IAToken), function:RESERVE_TREASURY_ADDRESS, arguments:[]  \n\t\t\tREF_705(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tHIGH_LEVEL_CALL, dest:REF_700(IAToken), function:transferOnLiquidation, arguments:['REF_702', 'TMP_717', 'REF_705']  \n\t\tExpression: IERC20(params.debtAsset).safeTransferFrom(msg.sender,vars.debtReserveCache.aTokenAddress,vars.actualDebtToLiquidate)\n\t\tIRs:\n\t\t\tREF_706(address) -> params.debtAsset\n\t\t\tTMP_719 = CONVERT REF_706 to IERC20\n\t\t\tREF_708(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_709(address) -> REF_708.aTokenAddress\n\t\t\tREF_710(uint256) -> vars.actualDebtToLiquidate\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_719', 'msg.sender', 'REF_709', 'REF_710'] \n\t\tExpression: IAToken(vars.debtReserveCache.aTokenAddress).handleRepayment(msg.sender,params.user,vars.actualDebtToLiquidate)\n\t\tIRs:\n\t\t\tREF_711(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_712(address) -> REF_711.aTokenAddress\n\t\t\tTMP_721 = CONVERT REF_712 to IAToken\n\t\t\tREF_714(address) -> params.user\n\t\t\tREF_715(uint256) -> vars.actualDebtToLiquidate\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_721(IAToken), function:handleRepayment, arguments:['msg.sender', 'REF_714', 'REF_715']  \n\t\tExpression: LiquidationCall(params.collateralAsset,params.debtAsset,params.user,vars.actualDebtToLiquidate,vars.actualCollateralToLiquidate,msg.sender,params.receiveAToken)\n\t\tIRs:\n\t\t\tREF_716(address) -> params.collateralAsset\n\t\t\tREF_717(address) -> params.debtAsset\n\t\t\tREF_718(address) -> params.user\n\t\t\tREF_719(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_720(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tREF_721(bool) -> params.receiveAToken\n\t\t\tEmit LiquidationCall(REF_716,REF_717,REF_718,REF_719,REF_720,msg.sender,REF_721)\n\tFunction LiquidationLogic._burnCollateralATokens(DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars) (*)\n\t\tExpression: collateralReserveCache = collateralReserve.cache()\n\t\tIRs:\n\t\t\tTMP_724(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['collateralReserve'] \n\t\t\tcollateralReserveCache(DataTypes.ReserveCache) := TMP_724(DataTypes.ReserveCache)\n\t\tExpression: collateralReserve.updateState(collateralReserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['collateralReserve', 'collateralReserveCache'] \n\t\tExpression: collateralReserve.updateInterestRates(collateralReserveCache,params.collateralAsset,0,vars.actualCollateralToLiquidate)\n\t\tIRs:\n\t\t\tREF_725(address) -> params.collateralAsset\n\t\t\tREF_726(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['collateralReserve', 'collateralReserveCache', 'REF_725', '0', 'REF_726'] \n\t\tExpression: vars.collateralAToken.burn(params.user,msg.sender,vars.actualCollateralToLiquidate,collateralReserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_727(IAToken) -> vars.collateralAToken\n\t\t\tREF_729(address) -> params.user\n\t\t\tREF_730(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tREF_731(uint256) -> collateralReserveCache.nextLiquidityIndex\n\t\t\tHIGH_LEVEL_CALL, dest:REF_727(IAToken), function:burn, arguments:['REF_729', 'msg.sender', 'REF_730', 'REF_731']  \n\tFunction LiquidationLogic._liquidateATokens(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(address => DataTypes.UserConfigurationMap),DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars) (*)\n\t\tExpression: liquidatorPreviousATokenBalance = IERC20(vars.collateralAToken).balanceOf(msg.sender)\n\t\tIRs:\n\t\t\tREF_732(IAToken) -> vars.collateralAToken\n\t\t\tTMP_728 = CONVERT REF_732 to IERC20\n\t\t\tTMP_729(uint256) = HIGH_LEVEL_CALL, dest:TMP_728(IERC20), function:balanceOf, arguments:['msg.sender']  \n\t\t\tliquidatorPreviousATokenBalance(uint256) := TMP_729(uint256)\n\t\tExpression: vars.collateralAToken.transferOnLiquidation(params.user,msg.sender,vars.actualCollateralToLiquidate)\n\t\tIRs:\n\t\t\tREF_734(IAToken) -> vars.collateralAToken\n\t\t\tREF_736(address) -> params.user\n\t\t\tREF_737(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tHIGH_LEVEL_CALL, dest:REF_734(IAToken), function:transferOnLiquidation, arguments:['REF_736', 'msg.sender', 'REF_737']  \n\t\tExpression: liquidatorPreviousATokenBalance == 0\n\t\tIRs:\n\t\t\tTMP_731(bool) = liquidatorPreviousATokenBalance == 0\n\t\t\tCONDITION TMP_731\n\t\tExpression: liquidatorConfig = usersConfig[msg.sender]\n\t\tIRs:\n\t\t\tREF_738(DataTypes.UserConfigurationMap) -> usersConfig[msg.sender]\n\t\t\tliquidatorConfig(DataTypes.UserConfigurationMap) := REF_738(DataTypes.UserConfigurationMap)\n\t\tExpression: ValidationLogic.validateAutomaticUseAsCollateral(reservesData,reservesList,liquidatorConfig,collateralReserve.configuration,collateralReserve.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_740(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tREF_741(address) -> collateralReserve.aTokenAddress\n\t\t\tTMP_732(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address), arguments:['reservesData', 'reservesList', 'liquidatorConfig', 'REF_740', 'REF_741'] \n\t\t\tCONDITION TMP_732\n\t\tExpression: liquidatorConfig.setUsingAsCollateral(collateralReserve.id,true)\n\t\tIRs:\n\t\t\tREF_743(uint16) -> collateralReserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['liquidatorConfig', 'REF_743', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(params.collateralAsset,msg.sender)\n\t\tIRs:\n\t\t\tREF_744(address) -> params.collateralAsset\n\t\t\tEmit ReserveUsedAsCollateralEnabled(REF_744,msg.sender)\n\tFunction LiquidationLogic._burnDebtTokens(DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars) (*)\n\t\tExpression: vars.userVariableDebt >= vars.actualDebtToLiquidate\n\t\tIRs:\n\t\t\tREF_745(uint256) -> vars.userVariableDebt\n\t\t\tREF_746(uint256) -> vars.actualDebtToLiquidate\n\t\t\tTMP_735(bool) = REF_745 >= REF_746\n\t\t\tCONDITION TMP_735\n\t\tExpression: vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(vars.debtReserveCache.variableDebtTokenAddress).burn(params.user,vars.actualDebtToLiquidate,vars.debtReserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_747(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_748(uint256) -> REF_747.nextScaledVariableDebt\n\t\t\tREF_749(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_750(address) -> REF_749.variableDebtTokenAddress\n\t\t\tTMP_736 = CONVERT REF_750 to IVariableDebtToken\n\t\t\tREF_752(address) -> params.user\n\t\t\tREF_753(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_754(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_755(uint256) -> REF_754.nextVariableBorrowIndex\n\t\t\tTMP_737(uint256) = HIGH_LEVEL_CALL, dest:TMP_736(IVariableDebtToken), function:burn, arguments:['REF_752', 'REF_753', 'REF_755']  \n\t\t\tREF_748(uint256) (->vars) := TMP_737(uint256)\n\t\tExpression: vars.userVariableDebt != 0\n\t\tIRs:\n\t\t\tREF_756(uint256) -> vars.userVariableDebt\n\t\t\tTMP_738(bool) = REF_756 != 0\n\t\t\tCONDITION TMP_738\n\t\tExpression: vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(vars.debtReserveCache.variableDebtTokenAddress).burn(params.user,vars.userVariableDebt,vars.debtReserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_757(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_758(uint256) -> REF_757.nextScaledVariableDebt\n\t\t\tREF_759(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_760(address) -> REF_759.variableDebtTokenAddress\n\t\t\tTMP_739 = CONVERT REF_760 to IVariableDebtToken\n\t\t\tREF_762(address) -> params.user\n\t\t\tREF_763(uint256) -> vars.userVariableDebt\n\t\t\tREF_764(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_765(uint256) -> REF_764.nextVariableBorrowIndex\n\t\t\tTMP_740(uint256) = HIGH_LEVEL_CALL, dest:TMP_739(IVariableDebtToken), function:burn, arguments:['REF_762', 'REF_763', 'REF_765']  \n\t\t\tREF_758(uint256) (->vars) := TMP_740(uint256)\n\t\tExpression: (vars.debtReserveCache.nextTotalStableDebt,vars.debtReserveCache.nextAvgStableBorrowRate) = IStableDebtToken(vars.debtReserveCache.stableDebtTokenAddress).burn(params.user,vars.actualDebtToLiquidate - vars.userVariableDebt)\n\t\tIRs:\n\t\t\tREF_766(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_767(uint256) -> REF_766.nextTotalStableDebt\n\t\t\tREF_768(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_769(uint256) -> REF_768.nextAvgStableBorrowRate\n\t\t\tREF_770(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_771(address) -> REF_770.stableDebtTokenAddress\n\t\t\tTMP_741 = CONVERT REF_771 to IStableDebtToken\n\t\t\tREF_773(address) -> params.user\n\t\t\tREF_774(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_775(uint256) -> vars.userVariableDebt\n\t\t\tTMP_742(uint256) = REF_774 (c)- REF_775\n\t\t\tTUPLE_23(uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_741(IStableDebtToken), function:burn, arguments:['REF_773', 'TMP_742']  \n\t\t\tREF_767(uint256)= UNPACK TUPLE_23 index: 0 \n\t\t\tREF_769(uint256)= UNPACK TUPLE_23 index: 1 \n\tFunction LiquidationLogic._calculateDebt(DataTypes.ReserveCache,DataTypes.ExecuteLiquidationCallParams,uint256) (*)\n\t\tExpression: (userStableDebt,userVariableDebt) = Helpers.getUserCurrentDebt(params.user,debtReserveCache)\n\t\tIRs:\n\t\t\tREF_777(address) -> params.user\n\t\t\tTUPLE_24(uint256,uint256) = LIBRARY_CALL, dest:Helpers, function:Helpers.getUserCurrentDebt(address,DataTypes.ReserveCache), arguments:['REF_777', 'debtReserveCache'] \n\t\t\tuserStableDebt(uint256)= UNPACK TUPLE_24 index: 0 \n\t\t\tuserVariableDebt(uint256)= UNPACK TUPLE_24 index: 1 \n\t\tExpression: userTotalDebt = userStableDebt + userVariableDebt\n\t\tIRs:\n\t\t\tTMP_743(uint256) = userStableDebt (c)+ userVariableDebt\n\t\t\tuserTotalDebt(uint256) := TMP_743(uint256)\n\t\tExpression: maxLiquidatableDebt = userTotalDebt.percentMul(closeFactor)\n\t\tIRs:\n\t\t\tTMP_744(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['userTotalDebt', 'closeFactor'] \n\t\t\tmaxLiquidatableDebt(uint256) := TMP_744(uint256)\n\t\tExpression: (userVariableDebt,userTotalDebt,actualDebtToLiquidate)\n\t\tIRs:\n\t\t\tRETURN userVariableDebt,userTotalDebt,actualDebtToLiquidate\n\t\tExpression: healthFactor > CLOSE_FACTOR_HF_THRESHOLD\n\t\tIRs:\n\t\t\tTMP_745(bool) = healthFactor > CLOSE_FACTOR_HF_THRESHOLD\n\t\t\tCONDITION TMP_745\n\t\tExpression: closeFactor = DEFAULT_LIQUIDATION_CLOSE_FACTOR\n\t\tIRs:\n\t\t\tcloseFactor(uint256) := DEFAULT_LIQUIDATION_CLOSE_FACTOR(uint256)\n\t\tExpression: closeFactor = MAX_LIQUIDATION_CLOSE_FACTOR\n\t\tIRs:\n\t\t\tcloseFactor(uint256) := MAX_LIQUIDATION_CLOSE_FACTOR(uint256)\n\t\tExpression: params.debtToCover > maxLiquidatableDebt\n\t\tIRs:\n\t\t\tREF_779(uint256) -> params.debtToCover\n\t\t\tTMP_746(bool) = REF_779 > maxLiquidatableDebt\n\t\t\tCONDITION TMP_746\n\t\tExpression: actualDebtToLiquidate = maxLiquidatableDebt\n\t\tIRs:\n\t\t\tactualDebtToLiquidate(uint256) := maxLiquidatableDebt(uint256)\n\t\tExpression: actualDebtToLiquidate = params.debtToCover\n\t\tIRs:\n\t\t\tREF_780(uint256) -> params.debtToCover\n\t\t\tactualDebtToLiquidate(uint256) := REF_780(uint256)\n\tFunction LiquidationLogic._getConfigurationData(mapping(uint8 => DataTypes.EModeCategory),DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams) (*)\n\t\tExpression: collateralAToken = IAToken(collateralReserve.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_781(address) -> collateralReserve.aTokenAddress\n\t\t\tTMP_747 = CONVERT REF_781 to IAToken\n\t\t\tcollateralAToken(IAToken) := TMP_747(IAToken)\n\t\tExpression: liquidationBonus = collateralReserve.configuration.getLiquidationBonus()\n\t\tIRs:\n\t\t\tREF_782(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_748(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLiquidationBonus(DataTypes.ReserveConfigurationMap), arguments:['REF_782'] \n\t\t\tliquidationBonus(uint256) := TMP_748(uint256)\n\t\tExpression: collateralPriceSource = params.collateralAsset\n\t\tIRs:\n\t\t\tREF_784(address) -> params.collateralAsset\n\t\t\tcollateralPriceSource(address) := REF_784(address)\n\t\tExpression: debtPriceSource = params.debtAsset\n\t\tIRs:\n\t\t\tREF_785(address) -> params.debtAsset\n\t\t\tdebtPriceSource(address) := REF_785(address)\n\t\tExpression: params.userEModeCategory != 0\n\t\tIRs:\n\t\t\tREF_786(uint8) -> params.userEModeCategory\n\t\t\tTMP_749(bool) = REF_786 != 0\n\t\t\tCONDITION TMP_749\n\t\tExpression: eModePriceSource = eModeCategories[params.userEModeCategory].priceSource\n\t\tIRs:\n\t\t\tREF_787(uint8) -> params.userEModeCategory\n\t\t\tREF_788(DataTypes.EModeCategory) -> eModeCategories[REF_787]\n\t\t\tREF_789(address) -> REF_788.priceSource\n\t\t\teModePriceSource(address) := REF_789(address)\n\t\tExpression: EModeLogic.isInEModeCategory(params.userEModeCategory,collateralReserve.configuration.getEModeCategory())\n\t\tIRs:\n\t\t\tREF_791(uint8) -> params.userEModeCategory\n\t\t\tREF_792(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_750(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getEModeCategory(DataTypes.ReserveConfigurationMap), arguments:['REF_792'] \n\t\t\tTMP_751(bool) = LIBRARY_CALL, dest:EModeLogic, function:EModeLogic.isInEModeCategory(uint256,uint256), arguments:['REF_791', 'TMP_750'] \n\t\t\tCONDITION TMP_751\n\t\tExpression: liquidationBonus = eModeCategories[params.userEModeCategory].liquidationBonus\n\t\tIRs:\n\t\t\tREF_794(uint8) -> params.userEModeCategory\n\t\t\tREF_795(DataTypes.EModeCategory) -> eModeCategories[REF_794]\n\t\t\tREF_796(uint16) -> REF_795.liquidationBonus\n\t\t\tliquidationBonus(uint256) := REF_796(uint16)\n\t\tExpression: eModePriceSource != address(0)\n\t\tIRs:\n\t\t\tTMP_752 = CONVERT 0 to address\n\t\t\tTMP_753(bool) = eModePriceSource != TMP_752\n\t\t\tCONDITION TMP_753\n\t\tExpression: collateralPriceSource = eModePriceSource\n\t\tIRs:\n\t\t\tcollateralPriceSource(address) := eModePriceSource(address)\n\t\tExpression: eModePriceSource != address(0)\n\t\tIRs:\n\t\t\tTMP_754 = CONVERT 0 to address\n\t\t\tTMP_755(bool) = eModePriceSource != TMP_754\n\t\t\tCONDITION TMP_755\n\t\tExpression: debtPriceSource = eModePriceSource\n\t\tIRs:\n\t\t\tdebtPriceSource(address) := eModePriceSource(address)\n\t\tExpression: (collateralAToken,collateralPriceSource,debtPriceSource,liquidationBonus)\n\t\tIRs:\n\t\t\tRETURN collateralAToken,collateralPriceSource,debtPriceSource,liquidationBonus\n\tFunction LiquidationLogic._calculateAvailableCollateralToLiquidate(DataTypes.ReserveData,DataTypes.ReserveCache,address,address,uint256,uint256,uint256,IPriceOracleGetter) (*)\n\t\tExpression: vars.collateralPrice = oracle.getAssetPrice(collateralAsset)\n\t\tIRs:\n\t\t\tREF_797(uint256) -> vars.collateralPrice\n\t\t\tTMP_756(uint256) = HIGH_LEVEL_CALL, dest:oracle(IPriceOracleGetter), function:getAssetPrice, arguments:['collateralAsset']  \n\t\t\tREF_797(uint256) (->vars) := TMP_756(uint256)\n\t\tExpression: vars.debtAssetPrice = oracle.getAssetPrice(debtAsset)\n\t\tIRs:\n\t\t\tREF_799(uint256) -> vars.debtAssetPrice\n\t\t\tTMP_757(uint256) = HIGH_LEVEL_CALL, dest:oracle(IPriceOracleGetter), function:getAssetPrice, arguments:['debtAsset']  \n\t\t\tREF_799(uint256) (->vars) := TMP_757(uint256)\n\t\tExpression: vars.collateralDecimals = collateralReserve.configuration.getDecimals()\n\t\tIRs:\n\t\t\tREF_801(uint256) -> vars.collateralDecimals\n\t\t\tREF_802(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_758(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_802'] \n\t\t\tREF_801(uint256) (->vars) := TMP_758(uint256)\n\t\tExpression: vars.debtAssetDecimals = debtReserveCache.reserveConfiguration.getDecimals()\n\t\tIRs:\n\t\t\tREF_804(uint256) -> vars.debtAssetDecimals\n\t\t\tREF_805(DataTypes.ReserveConfigurationMap) -> debtReserveCache.reserveConfiguration\n\t\t\tTMP_759(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_805'] \n\t\t\tREF_804(uint256) (->vars) := TMP_759(uint256)\n\t\tExpression: vars.collateralAssetUnit = 10 ** vars.collateralDecimals\n\t\tIRs:\n\t\t\tREF_807(uint256) -> vars.collateralAssetUnit\n\t\t\tREF_808(uint256) -> vars.collateralDecimals\n\t\t\tTMP_760(uint256) = 10 ** REF_808\n\t\t\tREF_807(uint256) (->vars) := TMP_760(uint256)\n\t\tExpression: vars.debtAssetUnit = 10 ** vars.debtAssetDecimals\n\t\tIRs:\n\t\t\tREF_809(uint256) -> vars.debtAssetUnit\n\t\t\tREF_810(uint256) -> vars.debtAssetDecimals\n\t\t\tTMP_761(uint256) = 10 ** REF_810\n\t\t\tREF_809(uint256) (->vars) := TMP_761(uint256)\n\t\tExpression: vars.liquidationProtocolFeePercentage = collateralReserve.configuration.getLiquidationProtocolFee()\n\t\tIRs:\n\t\t\tREF_811(uint256) -> vars.liquidationProtocolFeePercentage\n\t\t\tREF_812(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_762(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLiquidationProtocolFee(DataTypes.ReserveConfigurationMap), arguments:['REF_812'] \n\t\t\tREF_811(uint256) (->vars) := TMP_762(uint256)\n\t\tExpression: vars.baseCollateral = ((vars.debtAssetPrice * debtToCover * vars.collateralAssetUnit)) / (vars.collateralPrice * vars.debtAssetUnit)\n\t\tIRs:\n\t\t\tREF_814(uint256) -> vars.baseCollateral\n\t\t\tREF_815(uint256) -> vars.debtAssetPrice\n\t\t\tTMP_763(uint256) = REF_815 (c)* debtToCover\n\t\t\tREF_816(uint256) -> vars.collateralAssetUnit\n\t\t\tTMP_764(uint256) = TMP_763 (c)* REF_816\n\t\t\tREF_817(uint256) -> vars.collateralPrice\n\t\t\tREF_818(uint256) -> vars.debtAssetUnit\n\t\t\tTMP_765(uint256) = REF_817 (c)* REF_818\n\t\t\tTMP_766(uint256) = TMP_764 (c)/ TMP_765\n\t\t\tREF_814(uint256) (->vars) := TMP_766(uint256)\n\t\tExpression: vars.maxCollateralToLiquidate = vars.baseCollateral.percentMul(liquidationBonus)\n\t\tIRs:\n\t\t\tREF_819(uint256) -> vars.maxCollateralToLiquidate\n\t\t\tREF_820(uint256) -> vars.baseCollateral\n\t\t\tTMP_767(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_820', 'liquidationBonus'] \n\t\t\tREF_819(uint256) (->vars) := TMP_767(uint256)\n\t\tExpression: vars.maxCollateralToLiquidate > userCollateralBalance\n\t\tIRs:\n\t\t\tREF_822(uint256) -> vars.maxCollateralToLiquidate\n\t\t\tTMP_768(bool) = REF_822 > userCollateralBalance\n\t\t\tCONDITION TMP_768\n\t\tExpression: vars.collateralAmount = userCollateralBalance\n\t\tIRs:\n\t\t\tREF_823(uint256) -> vars.collateralAmount\n\t\t\tREF_823(uint256) (->vars) := userCollateralBalance(uint256)\n\t\tExpression: vars.debtAmountNeeded = ((vars.collateralPrice * vars.collateralAmount * vars.debtAssetUnit) / (vars.debtAssetPrice * vars.collateralAssetUnit)).percentDiv(liquidationBonus)\n\t\tIRs:\n\t\t\tREF_824(uint256) -> vars.debtAmountNeeded\n\t\t\tREF_825(uint256) -> vars.collateralPrice\n\t\t\tREF_826(uint256) -> vars.collateralAmount\n\t\t\tTMP_769(uint256) = REF_825 (c)* REF_826\n\t\t\tREF_827(uint256) -> vars.debtAssetUnit\n\t\t\tTMP_770(uint256) = TMP_769 (c)* REF_827\n\t\t\tREF_828(uint256) -> vars.debtAssetPrice\n\t\t\tREF_829(uint256) -> vars.collateralAssetUnit\n\t\t\tTMP_771(uint256) = REF_828 (c)* REF_829\n\t\t\tTMP_772(uint256) = TMP_770 (c)/ TMP_771\n\t\t\tTMP_773(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentDiv(uint256,uint256), arguments:['TMP_772', 'liquidationBonus'] \n\t\t\tREF_824(uint256) (->vars) := TMP_773(uint256)\n\t\tExpression: vars.collateralAmount = vars.maxCollateralToLiquidate\n\t\tIRs:\n\t\t\tREF_831(uint256) -> vars.collateralAmount\n\t\t\tREF_832(uint256) -> vars.maxCollateralToLiquidate\n\t\t\tREF_831(uint256) (->vars) := REF_832(uint256)\n\t\tExpression: vars.debtAmountNeeded = debtToCover\n\t\tIRs:\n\t\t\tREF_833(uint256) -> vars.debtAmountNeeded\n\t\t\tREF_833(uint256) (->vars) := debtToCover(uint256)\n\t\tExpression: vars.liquidationProtocolFeePercentage != 0\n\t\tIRs:\n\t\t\tREF_834(uint256) -> vars.liquidationProtocolFeePercentage\n\t\t\tTMP_774(bool) = REF_834 != 0\n\t\t\tCONDITION TMP_774\n\t\tExpression: vars.bonusCollateral = vars.collateralAmount - vars.collateralAmount.percentDiv(liquidationBonus)\n\t\tIRs:\n\t\t\tREF_835(uint256) -> vars.bonusCollateral\n\t\t\tREF_836(uint256) -> vars.collateralAmount\n\t\t\tREF_837(uint256) -> vars.collateralAmount\n\t\t\tTMP_775(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentDiv(uint256,uint256), arguments:['REF_837', 'liquidationBonus'] \n\t\t\tTMP_776(uint256) = REF_836 (c)- TMP_775\n\t\t\tREF_835(uint256) (->vars) := TMP_776(uint256)\n\t\tExpression: vars.liquidationProtocolFee = vars.bonusCollateral.percentMul(vars.liquidationProtocolFeePercentage)\n\t\tIRs:\n\t\t\tREF_839(uint256) -> vars.liquidationProtocolFee\n\t\t\tREF_840(uint256) -> vars.bonusCollateral\n\t\t\tREF_842(uint256) -> vars.liquidationProtocolFeePercentage\n\t\t\tTMP_777(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_840', 'REF_842'] \n\t\t\tREF_839(uint256) (->vars) := TMP_777(uint256)\n\t\tExpression: (vars.collateralAmount - vars.liquidationProtocolFee,vars.debtAmountNeeded,vars.liquidationProtocolFee)\n\t\tIRs:\n\t\t\tREF_843(uint256) -> vars.collateralAmount\n\t\t\tREF_844(uint256) -> vars.liquidationProtocolFee\n\t\t\tTMP_778(uint256) = REF_843 (c)- REF_844\n\t\t\tREF_845(uint256) -> vars.debtAmountNeeded\n\t\t\tREF_846(uint256) -> vars.liquidationProtocolFee\n\t\t\tRETURN TMP_778,REF_845,REF_846\n\t\tExpression: (vars.collateralAmount,vars.debtAmountNeeded,0)\n\t\tIRs:\n\t\t\tREF_847(uint256) -> vars.collateralAmount\n\t\t\tREF_848(uint256) -> vars.debtAmountNeeded\n\t\t\tRETURN REF_847,REF_848,0\n\tFunction LiquidationLogic.slitherConstructorConstantVariables() (*)\n\t\tExpression: DEFAULT_LIQUIDATION_CLOSE_FACTOR = 0.5e4\n\t\tIRs:\n\t\t\tDEFAULT_LIQUIDATION_CLOSE_FACTOR(uint256) := 5000(uint256)\n\t\tExpression: MAX_LIQUIDATION_CLOSE_FACTOR = 1e4\n\t\tIRs:\n\t\t\tMAX_LIQUIDATION_CLOSE_FACTOR(uint256) := 10000(uint256)\n\t\tExpression: CLOSE_FACTOR_HF_THRESHOLD = 0.95e18\n\t\tIRs:\n\t\t\tCLOSE_FACTOR_HF_THRESHOLD(uint256) := 950000000000000000(uint256)\nContract PoolLogic\n\tFunction PoolLogic.executeInitReserve(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.InitReserveParams) (*)\n\t\tExpression: require(bool,string)(Address.isContract(params.asset),Errors.NOT_CONTRACT)\n\t\tIRs:\n\t\t\tREF_850(address) -> params.asset\n\t\t\tTMP_779(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['REF_850'] \n\t\t\tREF_851(string) -> Errors.NOT_CONTRACT\n\t\t\tTMP_780(None) = SOLIDITY_CALL require(bool,string)(TMP_779,REF_851)\n\t\tExpression: reservesData[params.asset].init(params.aTokenAddress,params.stableDebtAddress,params.variableDebtAddress,params.interestRateStrategyAddress)\n\t\tIRs:\n\t\t\tREF_852(address) -> params.asset\n\t\t\tREF_853(DataTypes.ReserveData) -> reservesData[REF_852]\n\t\t\tREF_855(address) -> params.aTokenAddress\n\t\t\tREF_856(address) -> params.stableDebtAddress\n\t\t\tREF_857(address) -> params.variableDebtAddress\n\t\t\tREF_858(address) -> params.interestRateStrategyAddress\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.init(DataTypes.ReserveData,address,address,address,address), arguments:['REF_853', 'REF_855', 'REF_856', 'REF_857', 'REF_858'] \n\t\tExpression: reserveAlreadyAdded = reservesData[params.asset].id != 0 || reservesList[0] == params.asset\n\t\tIRs:\n\t\t\tREF_859(address) -> params.asset\n\t\t\tREF_860(DataTypes.ReserveData) -> reservesData[REF_859]\n\t\t\tREF_861(uint16) -> REF_860.id\n\t\t\tTMP_782(bool) = REF_861 != 0\n\t\t\tREF_862(address) -> reservesList[0]\n\t\t\tREF_863(address) -> params.asset\n\t\t\tTMP_783(bool) = REF_862 == REF_863\n\t\t\tTMP_784(bool) = TMP_782 || TMP_783\n\t\t\treserveAlreadyAdded(bool) := TMP_784(bool)\n\t\tExpression: require(bool,string)(! reserveAlreadyAdded,Errors.RESERVE_ALREADY_ADDED)\n\t\tIRs:\n\t\t\tTMP_785 = UnaryType.BANG reserveAlreadyAdded \n\t\t\tREF_864(string) -> Errors.RESERVE_ALREADY_ADDED\n\t\t\tTMP_786(None) = SOLIDITY_CALL require(bool,string)(TMP_785,REF_864)\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint16) := 0(uint256)\n\t\tExpression: i < params.reservesCount\n\t\tIRs:\n\t\t\tREF_865(uint16) -> params.reservesCount\n\t\t\tTMP_787(bool) = i < REF_865\n\t\t\tCONDITION TMP_787\n\t\tExpression: reservesList[i] == address(0)\n\t\tIRs:\n\t\t\tREF_866(address) -> reservesList[i]\n\t\t\tTMP_788 = CONVERT 0 to address\n\t\t\tTMP_789(bool) = REF_866 == TMP_788\n\t\t\tCONDITION TMP_789\n\t\tExpression: reservesData[params.asset].id = i\n\t\tIRs:\n\t\t\tREF_867(address) -> params.asset\n\t\t\tREF_868(DataTypes.ReserveData) -> reservesData[REF_867]\n\t\t\tREF_869(uint16) -> REF_868.id\n\t\t\tREF_869(uint16) (->reservesData) := i(uint16)\n\t\tExpression: reservesList[i] = params.asset\n\t\tIRs:\n\t\t\tREF_870(address) -> reservesList[i]\n\t\t\tREF_871(address) -> params.asset\n\t\t\tREF_870(address) (->reservesList) := REF_871(address)\n\t\tExpression: false\n\t\tIRs:\n\t\t\tRETURN False\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_790(uint16) := i(uint16)\n\t\t\ti(uint16) = i (c)+ 1\n\t\tExpression: require(bool,string)(params.reservesCount < params.maxNumberReserves,Errors.NO_MORE_RESERVES_ALLOWED)\n\t\tIRs:\n\t\t\tREF_872(uint16) -> params.reservesCount\n\t\t\tREF_873(uint16) -> params.maxNumberReserves\n\t\t\tTMP_791(bool) = REF_872 < REF_873\n\t\t\tREF_874(string) -> Errors.NO_MORE_RESERVES_ALLOWED\n\t\t\tTMP_792(None) = SOLIDITY_CALL require(bool,string)(TMP_791,REF_874)\n\t\tExpression: reservesData[params.asset].id = params.reservesCount\n\t\tIRs:\n\t\t\tREF_875(address) -> params.asset\n\t\t\tREF_876(DataTypes.ReserveData) -> reservesData[REF_875]\n\t\t\tREF_877(uint16) -> REF_876.id\n\t\t\tREF_878(uint16) -> params.reservesCount\n\t\t\tREF_877(uint16) (->reservesData) := REF_878(uint16)\n\t\tExpression: reservesList[params.reservesCount] = params.asset\n\t\tIRs:\n\t\t\tREF_879(uint16) -> params.reservesCount\n\t\t\tREF_880(address) -> reservesList[REF_879]\n\t\t\tREF_881(address) -> params.asset\n\t\t\tREF_880(address) (->reservesList) := REF_881(address)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction PoolLogic.executeRescueTokens(address,address,uint256) (*)\n\t\tExpression: IERC20(token).safeTransfer(to,amount)\n\t\tIRs:\n\t\t\tTMP_793 = CONVERT token to IERC20\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_793', 'to', 'amount'] \n\tFunction PoolLogic.executeMintToTreasury(mapping(address => DataTypes.ReserveData),address[]) (*)\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint256) := 0(uint256)\n\t\tExpression: i < assets.length\n\t\tIRs:\n\t\t\tREF_883 -> LENGTH assets\n\t\t\tTMP_795(bool) = i < REF_883\n\t\t\tCONDITION TMP_795\n\t\tExpression: assetAddress = assets[i]\n\t\tIRs:\n\t\t\tREF_884(address) -> assets[i]\n\t\t\tassetAddress(address) := REF_884(address)\n\t\tExpression: reserve = reservesData[assetAddress]\n\t\tIRs:\n\t\t\tREF_885(DataTypes.ReserveData) -> reservesData[assetAddress]\n\t\t\treserve(DataTypes.ReserveData) := REF_885(DataTypes.ReserveData)\n\t\tExpression: ! reserve.configuration.getActive()\n\t\tIRs:\n\t\t\tREF_886(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tTMP_796(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getActive(DataTypes.ReserveConfigurationMap), arguments:['REF_886'] \n\t\t\tTMP_797 = UnaryType.BANG TMP_796 \n\t\t\tCONDITION TMP_797\n\t\tExpression: accruedToTreasury = reserve.accruedToTreasury\n\t\tIRs:\n\t\t\tREF_888(uint128) -> reserve.accruedToTreasury\n\t\t\taccruedToTreasury(uint256) := REF_888(uint128)\n\t\tExpression: accruedToTreasury != 0\n\t\tIRs:\n\t\t\tTMP_798(bool) = accruedToTreasury != 0\n\t\t\tCONDITION TMP_798\n\t\tExpression: reserve.accruedToTreasury = 0\n\t\tIRs:\n\t\t\tREF_889(uint128) -> reserve.accruedToTreasury\n\t\t\tREF_889(uint128) (->reserve) := 0(uint256)\n\t\tExpression: normalizedIncome = reserve.getNormalizedIncome()\n\t\tIRs:\n\t\t\tTMP_799(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedIncome(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\tnormalizedIncome(uint256) := TMP_799(uint256)\n\t\tExpression: amountToMint = accruedToTreasury.rayMul(normalizedIncome)\n\t\tIRs:\n\t\t\tTMP_800(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['accruedToTreasury', 'normalizedIncome'] \n\t\t\tamountToMint(uint256) := TMP_800(uint256)\n\t\tExpression: IAToken(reserve.aTokenAddress).mintToTreasury(amountToMint,normalizedIncome)\n\t\tIRs:\n\t\t\tREF_892(address) -> reserve.aTokenAddress\n\t\t\tTMP_801 = CONVERT REF_892 to IAToken\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_801(IAToken), function:mintToTreasury, arguments:['amountToMint', 'normalizedIncome']  \n\t\tExpression: MintedToTreasury(assetAddress,amountToMint)\n\t\tIRs:\n\t\t\tEmit MintedToTreasury(assetAddress,amountToMint)\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_804(uint256) := i(uint256)\n\t\t\ti(uint256) = i (c)+ 1\n\tFunction PoolLogic.executeResetIsolationModeTotalDebt(mapping(address => DataTypes.ReserveData),address) (*)\n\t\tExpression: require(bool,string)(reservesData[asset].configuration.getDebtCeiling() == 0,Errors.DEBT_CEILING_NOT_ZERO)\n\t\tIRs:\n\t\t\tREF_894(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\tREF_895(DataTypes.ReserveConfigurationMap) -> REF_894.configuration\n\t\t\tTMP_805(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap), arguments:['REF_895'] \n\t\t\tTMP_806(bool) = TMP_805 == 0\n\t\t\tREF_897(string) -> Errors.DEBT_CEILING_NOT_ZERO\n\t\t\tTMP_807(None) = SOLIDITY_CALL require(bool,string)(TMP_806,REF_897)\n\t\tExpression: reservesData[asset].isolationModeTotalDebt = 0\n\t\tIRs:\n\t\t\tREF_898(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\tREF_899(uint128) -> REF_898.isolationModeTotalDebt\n\t\t\tREF_899(uint128) (->reservesData) := 0(uint256)\n\t\tExpression: IsolationModeTotalDebtUpdated(asset,0)\n\t\tIRs:\n\t\t\tEmit IsolationModeTotalDebtUpdated(asset,0)\n\tFunction PoolLogic.executeDropReserve(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),address) (*)\n\t\tExpression: reserve = reservesData[asset]\n\t\tIRs:\n\t\t\tREF_900(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treserve(DataTypes.ReserveData) := REF_900(DataTypes.ReserveData)\n\t\tExpression: ValidationLogic.validateDropReserve(reservesList,reserve,asset)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateDropReserve(mapping(uint256 => address),DataTypes.ReserveData,address), arguments:['reservesList', 'reserve', 'asset'] \n\t\tExpression: reservesList[reservesData[asset].id] = address(0)\n\t\tIRs:\n\t\t\tREF_902(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\tREF_903(uint16) -> REF_902.id\n\t\t\tREF_904(address) -> reservesList[REF_903]\n\t\t\tTMP_810 = CONVERT 0 to address\n\t\t\tREF_904(address) (->reservesList) := TMP_810(address)\n\t\tExpression: delete reservesData[asset]\n\t\tIRs:\n\t\t\tREF_905(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treservesData = delete REF_905 \n\tFunction PoolLogic.executeGetUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams) (*)\n\t\tExpression: (totalCollateralBase,totalDebtBase,ltv,currentLiquidationThreshold,healthFactor,None) = GenericLogic.calculateUserAccountData(reservesData,reservesList,eModeCategories,params)\n\t\tIRs:\n\t\t\tTUPLE_25(uint256,uint256,uint256,uint256,uint256,bool) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'params'] \n\t\t\ttotalCollateralBase(uint256)= UNPACK TUPLE_25 index: 0 \n\t\t\ttotalDebtBase(uint256)= UNPACK TUPLE_25 index: 1 \n\t\t\tltv(uint256)= UNPACK TUPLE_25 index: 2 \n\t\t\tcurrentLiquidationThreshold(uint256)= UNPACK TUPLE_25 index: 3 \n\t\t\thealthFactor(uint256)= UNPACK TUPLE_25 index: 4 \n\t\tExpression: availableBorrowsBase = GenericLogic.calculateAvailableBorrows(totalCollateralBase,totalDebtBase,ltv)\n\t\tIRs:\n\t\t\tTMP_811(uint256) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateAvailableBorrows(uint256,uint256,uint256), arguments:['totalCollateralBase', 'totalDebtBase', 'ltv'] \n\t\t\tavailableBorrowsBase(uint256) := TMP_811(uint256)\n\t\tExpression: (totalCollateralBase,totalDebtBase,availableBorrowsBase,currentLiquidationThreshold,ltv,healthFactor)\n\t\tIRs:\n\t\t\tRETURN totalCollateralBase,totalDebtBase,availableBorrowsBase,currentLiquidationThreshold,ltv,healthFactor\nContract ReserveLogic\n\tFunction ReserveLogic.getNormalizedIncome(DataTypes.ReserveData) (*)\n\t\tExpression: timestamp = reserve.lastUpdateTimestamp\n\t\tIRs:\n\t\t\tREF_908(uint40) -> reserve.lastUpdateTimestamp\n\t\t\ttimestamp(uint40) := REF_908(uint40)\n\t\tExpression: timestamp == block.timestamp\n\t\tIRs:\n\t\t\tTMP_812(bool) = timestamp == block.timestamp\n\t\t\tCONDITION TMP_812\n\t\tExpression: reserve.liquidityIndex\n\t\tIRs:\n\t\t\tREF_909(uint128) -> reserve.liquidityIndex\n\t\t\tRETURN REF_909\n\t\tExpression: MathUtils.calculateLinearInterest(reserve.currentLiquidityRate,timestamp).rayMul(reserve.liquidityIndex)\n\t\tIRs:\n\t\t\tREF_911(uint128) -> reserve.currentLiquidityRate\n\t\t\tTMP_813(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateLinearInterest(uint256,uint40), arguments:['REF_911', 'timestamp'] \n\t\t\tREF_913(uint128) -> reserve.liquidityIndex\n\t\t\tTMP_814(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_813', 'REF_913'] \n\t\t\tRETURN TMP_814\n\tFunction ReserveLogic.getNormalizedDebt(DataTypes.ReserveData) (*)\n\t\tExpression: timestamp = reserve.lastUpdateTimestamp\n\t\tIRs:\n\t\t\tREF_914(uint40) -> reserve.lastUpdateTimestamp\n\t\t\ttimestamp(uint40) := REF_914(uint40)\n\t\tExpression: timestamp == block.timestamp\n\t\tIRs:\n\t\t\tTMP_815(bool) = timestamp == block.timestamp\n\t\t\tCONDITION TMP_815\n\t\tExpression: reserve.variableBorrowIndex\n\t\tIRs:\n\t\t\tREF_915(uint128) -> reserve.variableBorrowIndex\n\t\t\tRETURN REF_915\n\t\tExpression: MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate,timestamp).rayMul(reserve.variableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_917(uint128) -> reserve.currentVariableBorrowRate\n\t\t\tTMP_816(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateCompoundedInterest(uint256,uint40), arguments:['REF_917', 'timestamp'] \n\t\t\tREF_919(uint128) -> reserve.variableBorrowIndex\n\t\t\tTMP_817(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_816', 'REF_919'] \n\t\t\tRETURN TMP_817\n\tFunction ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache) (*)\n\t\tExpression: reserve.lastUpdateTimestamp == uint40(block.timestamp)\n\t\tIRs:\n\t\t\tREF_920(uint40) -> reserve.lastUpdateTimestamp\n\t\t\tTMP_818 = CONVERT block.timestamp to uint40\n\t\t\tTMP_819(bool) = REF_920 == TMP_818\n\t\t\tCONDITION TMP_819\n\t\tExpression: _updateIndexes(reserve,reserveCache)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, ReserveLogic._updateIndexes(DataTypes.ReserveData,DataTypes.ReserveCache)(reserve,reserveCache)\n\t\tExpression: _accrueToTreasury(reserve,reserveCache)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, ReserveLogic._accrueToTreasury(DataTypes.ReserveData,DataTypes.ReserveCache)(reserve,reserveCache)\n\t\tExpression: reserve.lastUpdateTimestamp = uint40(block.timestamp)\n\t\tIRs:\n\t\t\tREF_921(uint40) -> reserve.lastUpdateTimestamp\n\t\t\tTMP_822 = CONVERT block.timestamp to uint40\n\t\t\tREF_921(uint40) (->reserve) := TMP_822(uint40)\n\tFunction ReserveLogic.cumulateToLiquidityIndex(DataTypes.ReserveData,uint256,uint256) (*)\n\t\tExpression: result = (amount.wadToRay().rayDiv(totalLiquidity.wadToRay()) + WadRayMath.RAY).rayMul(reserve.liquidityIndex)\n\t\tIRs:\n\t\t\tTMP_823(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.wadToRay(uint256), arguments:['amount'] \n\t\t\tTMP_824(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.wadToRay(uint256), arguments:['totalLiquidity'] \n\t\t\tTMP_825(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['TMP_823', 'TMP_824'] \n\t\t\tREF_925(uint256) -> WadRayMath.RAY\n\t\t\tTMP_826(uint256) = TMP_825 (c)+ REF_925\n\t\t\tREF_927(uint128) -> reserve.liquidityIndex\n\t\t\tTMP_827(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_826', 'REF_927'] \n\t\t\tresult(uint256) := TMP_827(uint256)\n\t\tExpression: reserve.liquidityIndex = result.toUint128()\n\t\tIRs:\n\t\t\tREF_928(uint128) -> reserve.liquidityIndex\n\t\t\tTMP_828(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['result'] \n\t\t\tREF_928(uint128) (->reserve) := TMP_828(uint128)\n\t\tExpression: result\n\t\tIRs:\n\t\t\tRETURN result\n\tFunction ReserveLogic.init(DataTypes.ReserveData,address,address,address,address) (*)\n\t\tExpression: require(bool,string)(reserve.aTokenAddress == address(0),Errors.RESERVE_ALREADY_INITIALIZED)\n\t\tIRs:\n\t\t\tREF_930(address) -> reserve.aTokenAddress\n\t\t\tTMP_829 = CONVERT 0 to address\n\t\t\tTMP_830(bool) = REF_930 == TMP_829\n\t\t\tREF_931(string) -> Errors.RESERVE_ALREADY_INITIALIZED\n\t\t\tTMP_831(None) = SOLIDITY_CALL require(bool,string)(TMP_830,REF_931)\n\t\tExpression: reserve.liquidityIndex = uint128(WadRayMath.RAY)\n\t\tIRs:\n\t\t\tREF_932(uint128) -> reserve.liquidityIndex\n\t\t\tREF_933(uint256) -> WadRayMath.RAY\n\t\t\tTMP_832 = CONVERT REF_933 to uint128\n\t\t\tREF_932(uint128) (->reserve) := TMP_832(uint128)\n\t\tExpression: reserve.variableBorrowIndex = uint128(WadRayMath.RAY)\n\t\tIRs:\n\t\t\tREF_934(uint128) -> reserve.variableBorrowIndex\n\t\t\tREF_935(uint256) -> WadRayMath.RAY\n\t\t\tTMP_833 = CONVERT REF_935 to uint128\n\t\t\tREF_934(uint128) (->reserve) := TMP_833(uint128)\n\t\tExpression: reserve.aTokenAddress = aTokenAddress\n\t\tIRs:\n\t\t\tREF_936(address) -> reserve.aTokenAddress\n\t\t\tREF_936(address) (->reserve) := aTokenAddress(address)\n\t\tExpression: reserve.stableDebtTokenAddress = stableDebtTokenAddress\n\t\tIRs:\n\t\t\tREF_937(address) -> reserve.stableDebtTokenAddress\n\t\t\tREF_937(address) (->reserve) := stableDebtTokenAddress(address)\n\t\tExpression: reserve.variableDebtTokenAddress = variableDebtTokenAddress\n\t\tIRs:\n\t\t\tREF_938(address) -> reserve.variableDebtTokenAddress\n\t\t\tREF_938(address) (->reserve) := variableDebtTokenAddress(address)\n\t\tExpression: reserve.interestRateStrategyAddress = interestRateStrategyAddress\n\t\tIRs:\n\t\t\tREF_939(address) -> reserve.interestRateStrategyAddress\n\t\t\tREF_939(address) (->reserve) := interestRateStrategyAddress(address)\n\tFunction ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256) (*)\n\t\tExpression: vars.totalVariableDebt = reserveCache.nextScaledVariableDebt.rayMul(reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_940(uint256) -> vars.totalVariableDebt\n\t\t\tREF_941(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_943(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_834(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_941', 'REF_943'] \n\t\t\tREF_940(uint256) (->vars) := TMP_834(uint256)\n\t\tExpression: (vars.nextLiquidityRate,vars.nextStableRate,vars.nextVariableRate) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(DataTypes.CalculateInterestRatesParams({unbacked:reserve.unbacked,liquidityAdded:liquidityAdded,liquidityTaken:liquidityTaken,totalStableDebt:reserveCache.nextTotalStableDebt,totalVariableDebt:vars.totalVariableDebt,averageStableBorrowRate:reserveCache.nextAvgStableBorrowRate,reserveFactor:reserveCache.reserveFactor,reserve:reserveAddress,aToken:reserveCache.aTokenAddress}))\n\t\tIRs:\n\t\t\tREF_944(uint256) -> vars.nextLiquidityRate\n\t\t\tREF_945(uint256) -> vars.nextStableRate\n\t\t\tREF_946(uint256) -> vars.nextVariableRate\n\t\t\tREF_947(address) -> reserve.interestRateStrategyAddress\n\t\t\tTMP_835 = CONVERT REF_947 to IReserveInterestRateStrategy\n\t\t\tREF_950(uint128) -> reserve.unbacked\n\t\t\tREF_951(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_952(uint256) -> vars.totalVariableDebt\n\t\t\tREF_953(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_954(uint256) -> reserveCache.reserveFactor\n\t\t\tREF_955(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_836(DataTypes.CalculateInterestRatesParams) = new CalculateInterestRatesParams(REF_950,liquidityAdded,liquidityTaken,REF_951,REF_952,REF_953,REF_954,reserveAddress,REF_955)\n\t\t\tTUPLE_26(uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_835(IReserveInterestRateStrategy), function:calculateInterestRates, arguments:['TMP_836']  \n\t\t\tREF_944(uint256)= UNPACK TUPLE_26 index: 0 \n\t\t\tREF_945(uint256)= UNPACK TUPLE_26 index: 1 \n\t\t\tREF_946(uint256)= UNPACK TUPLE_26 index: 2 \n\t\tExpression: reserve.currentLiquidityRate = vars.nextLiquidityRate.toUint128()\n\t\tIRs:\n\t\t\tREF_956(uint128) -> reserve.currentLiquidityRate\n\t\t\tREF_957(uint256) -> vars.nextLiquidityRate\n\t\t\tTMP_837(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_957'] \n\t\t\tREF_956(uint128) (->reserve) := TMP_837(uint128)\n\t\tExpression: reserve.currentStableBorrowRate = vars.nextStableRate.toUint128()\n\t\tIRs:\n\t\t\tREF_959(uint128) -> reserve.currentStableBorrowRate\n\t\t\tREF_960(uint256) -> vars.nextStableRate\n\t\t\tTMP_838(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_960'] \n\t\t\tREF_959(uint128) (->reserve) := TMP_838(uint128)\n\t\tExpression: reserve.currentVariableBorrowRate = vars.nextVariableRate.toUint128()\n\t\tIRs:\n\t\t\tREF_962(uint128) -> reserve.currentVariableBorrowRate\n\t\t\tREF_963(uint256) -> vars.nextVariableRate\n\t\t\tTMP_839(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_963'] \n\t\t\tREF_962(uint128) (->reserve) := TMP_839(uint128)\n\t\tExpression: ReserveDataUpdated(reserveAddress,vars.nextLiquidityRate,vars.nextStableRate,vars.nextVariableRate,reserveCache.nextLiquidityIndex,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_965(uint256) -> vars.nextLiquidityRate\n\t\t\tREF_966(uint256) -> vars.nextStableRate\n\t\t\tREF_967(uint256) -> vars.nextVariableRate\n\t\t\tREF_968(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_969(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tEmit ReserveDataUpdated(reserveAddress,REF_965,REF_966,REF_967,REF_968,REF_969)\n\tFunction ReserveLogic._accrueToTreasury(DataTypes.ReserveData,DataTypes.ReserveCache) (*)\n\t\tExpression: reserveCache.reserveFactor == 0\n\t\tIRs:\n\t\t\tREF_970(uint256) -> reserveCache.reserveFactor\n\t\t\tTMP_841(bool) = REF_970 == 0\n\t\t\tCONDITION TMP_841\n\t\tExpression: vars.prevTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(reserveCache.currVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_971(uint256) -> vars.prevTotalVariableDebt\n\t\t\tREF_972(uint256) -> reserveCache.currScaledVariableDebt\n\t\t\tREF_974(uint256) -> reserveCache.currVariableBorrowIndex\n\t\t\tTMP_842(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_972', 'REF_974'] \n\t\t\tREF_971(uint256) (->vars) := TMP_842(uint256)\n\t\tExpression: vars.currTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_975(uint256) -> vars.currTotalVariableDebt\n\t\t\tREF_976(uint256) -> reserveCache.currScaledVariableDebt\n\t\t\tREF_978(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_843(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_976', 'REF_978'] \n\t\t\tREF_975(uint256) (->vars) := TMP_843(uint256)\n\t\tExpression: vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(reserveCache.currAvgStableBorrowRate,reserveCache.stableDebtLastUpdateTimestamp,reserveCache.reserveLastUpdateTimestamp)\n\t\tIRs:\n\t\t\tREF_979(uint256) -> vars.cumulatedStableInterest\n\t\t\tREF_981(uint256) -> reserveCache.currAvgStableBorrowRate\n\t\t\tREF_982(uint40) -> reserveCache.stableDebtLastUpdateTimestamp\n\t\t\tREF_983(uint40) -> reserveCache.reserveLastUpdateTimestamp\n\t\t\tTMP_844(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateCompoundedInterest(uint256,uint40,uint256), arguments:['REF_981', 'REF_982', 'REF_983'] \n\t\t\tREF_979(uint256) (->vars) := TMP_844(uint256)\n\t\tExpression: vars.prevTotalStableDebt = reserveCache.currPrincipalStableDebt.rayMul(vars.cumulatedStableInterest)\n\t\tIRs:\n\t\t\tREF_984(uint256) -> vars.prevTotalStableDebt\n\t\t\tREF_985(uint256) -> reserveCache.currPrincipalStableDebt\n\t\t\tREF_987(uint256) -> vars.cumulatedStableInterest\n\t\t\tTMP_845(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_985', 'REF_987'] \n\t\t\tREF_984(uint256) (->vars) := TMP_845(uint256)\n\t\tExpression: vars.totalDebtAccrued = vars.currTotalVariableDebt + reserveCache.currTotalStableDebt - vars.prevTotalVariableDebt - vars.prevTotalStableDebt\n\t\tIRs:\n\t\t\tREF_988(uint256) -> vars.totalDebtAccrued\n\t\t\tREF_989(uint256) -> vars.currTotalVariableDebt\n\t\t\tREF_990(uint256) -> reserveCache.currTotalStableDebt\n\t\t\tTMP_846(uint256) = REF_989 (c)+ REF_990\n\t\t\tREF_991(uint256) -> vars.prevTotalVariableDebt\n\t\t\tTMP_847(uint256) = TMP_846 (c)- REF_991\n\t\t\tREF_992(uint256) -> vars.prevTotalStableDebt\n\t\t\tTMP_848(uint256) = TMP_847 (c)- REF_992\n\t\t\tREF_988(uint256) (->vars) := TMP_848(uint256)\n\t\tExpression: vars.amountToMint = vars.totalDebtAccrued.percentMul(reserveCache.reserveFactor)\n\t\tIRs:\n\t\t\tREF_993(uint256) -> vars.amountToMint\n\t\t\tREF_994(uint256) -> vars.totalDebtAccrued\n\t\t\tREF_996(uint256) -> reserveCache.reserveFactor\n\t\t\tTMP_849(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_994', 'REF_996'] \n\t\t\tREF_993(uint256) (->vars) := TMP_849(uint256)\n\t\tExpression: vars.amountToMint != 0\n\t\tIRs:\n\t\t\tREF_997(uint256) -> vars.amountToMint\n\t\t\tTMP_850(bool) = REF_997 != 0\n\t\t\tCONDITION TMP_850\n\t\tExpression: reserve.accruedToTreasury += vars.amountToMint.rayDiv(reserveCache.nextLiquidityIndex).toUint128()\n\t\tIRs:\n\t\t\tREF_998(uint128) -> reserve.accruedToTreasury\n\t\t\tREF_999(uint256) -> vars.amountToMint\n\t\t\tREF_1001(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_851(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['REF_999', 'REF_1001'] \n\t\t\tTMP_852(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_851'] \n\t\t\tREF_998(-> reserve) = REF_998 (c)+ TMP_852\n\tFunction ReserveLogic._updateIndexes(DataTypes.ReserveData,DataTypes.ReserveCache) (*)\n\t\tExpression: reserveCache.currLiquidityRate != 0\n\t\tIRs:\n\t\t\tREF_1003(uint256) -> reserveCache.currLiquidityRate\n\t\t\tTMP_853(bool) = REF_1003 != 0\n\t\t\tCONDITION TMP_853\n\t\tExpression: cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(reserveCache.currLiquidityRate,reserveCache.reserveLastUpdateTimestamp)\n\t\tIRs:\n\t\t\tREF_1005(uint256) -> reserveCache.currLiquidityRate\n\t\t\tREF_1006(uint40) -> reserveCache.reserveLastUpdateTimestamp\n\t\t\tTMP_854(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateLinearInterest(uint256,uint40), arguments:['REF_1005', 'REF_1006'] \n\t\t\tcumulatedLiquidityInterest(uint256) := TMP_854(uint256)\n\t\tExpression: reserveCache.nextLiquidityIndex = cumulatedLiquidityInterest.rayMul(reserveCache.currLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_1007(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_1009(uint256) -> reserveCache.currLiquidityIndex\n\t\t\tTMP_855(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['cumulatedLiquidityInterest', 'REF_1009'] \n\t\t\tREF_1007(uint256) (->reserveCache) := TMP_855(uint256)\n\t\tExpression: reserve.liquidityIndex = reserveCache.nextLiquidityIndex.toUint128()\n\t\tIRs:\n\t\t\tREF_1010(uint128) -> reserve.liquidityIndex\n\t\t\tREF_1011(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_856(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_1011'] \n\t\t\tREF_1010(uint128) (->reserve) := TMP_856(uint128)\n\t\tExpression: reserveCache.currScaledVariableDebt != 0\n\t\tIRs:\n\t\t\tREF_1013(uint256) -> reserveCache.currScaledVariableDebt\n\t\t\tTMP_857(bool) = REF_1013 != 0\n\t\t\tCONDITION TMP_857\n\t\tExpression: cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(reserveCache.currVariableBorrowRate,reserveCache.reserveLastUpdateTimestamp)\n\t\tIRs:\n\t\t\tREF_1015(uint256) -> reserveCache.currVariableBorrowRate\n\t\t\tREF_1016(uint40) -> reserveCache.reserveLastUpdateTimestamp\n\t\t\tTMP_858(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateCompoundedInterest(uint256,uint40), arguments:['REF_1015', 'REF_1016'] \n\t\t\tcumulatedVariableBorrowInterest(uint256) := TMP_858(uint256)\n\t\tExpression: reserveCache.nextVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(reserveCache.currVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_1017(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tREF_1019(uint256) -> reserveCache.currVariableBorrowIndex\n\t\t\tTMP_859(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['cumulatedVariableBorrowInterest', 'REF_1019'] \n\t\t\tREF_1017(uint256) (->reserveCache) := TMP_859(uint256)\n\t\tExpression: reserve.variableBorrowIndex = reserveCache.nextVariableBorrowIndex.toUint128()\n\t\tIRs:\n\t\t\tREF_1020(uint128) -> reserve.variableBorrowIndex\n\t\t\tREF_1021(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_860(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_1021'] \n\t\t\tREF_1020(uint128) (->reserve) := TMP_860(uint128)\n\tFunction ReserveLogic.cache(DataTypes.ReserveData) (*)\n\t\tExpression: reserveCache.reserveConfiguration = reserve.configuration\n\t\tIRs:\n\t\t\tREF_1023(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tREF_1024(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tREF_1023(DataTypes.ReserveConfigurationMap) (->reserveCache) := REF_1024(DataTypes.ReserveConfigurationMap)\n\t\tExpression: reserveCache.reserveFactor = reserveCache.reserveConfiguration.getReserveFactor()\n\t\tIRs:\n\t\t\tREF_1025(uint256) -> reserveCache.reserveFactor\n\t\t\tREF_1026(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_861(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getReserveFactor(DataTypes.ReserveConfigurationMap), arguments:['REF_1026'] \n\t\t\tREF_1025(uint256) (->reserveCache) := TMP_861(uint256)\n\t\tExpression: reserveCache.currLiquidityIndex = reserveCache.nextLiquidityIndex = reserve.liquidityIndex\n\t\tIRs:\n\t\t\tREF_1028(uint256) -> reserveCache.currLiquidityIndex\n\t\t\tREF_1029(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_1030(uint128) -> reserve.liquidityIndex\n\t\t\tREF_1029(uint256) (->reserveCache) := REF_1030(uint128)\n\t\t\tREF_1028(uint256) (->reserveCache) := REF_1029(uint256)\n\t\tExpression: reserveCache.currVariableBorrowIndex = reserveCache.nextVariableBorrowIndex = reserve.variableBorrowIndex\n\t\tIRs:\n\t\t\tREF_1031(uint256) -> reserveCache.currVariableBorrowIndex\n\t\t\tREF_1032(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tREF_1033(uint128) -> reserve.variableBorrowIndex\n\t\t\tREF_1032(uint256) (->reserveCache) := REF_1033(uint128)\n\t\t\tREF_1031(uint256) (->reserveCache) := REF_1032(uint256)\n\t\tExpression: reserveCache.currLiquidityRate = reserve.currentLiquidityRate\n\t\tIRs:\n\t\t\tREF_1034(uint256) -> reserveCache.currLiquidityRate\n\t\t\tREF_1035(uint128) -> reserve.currentLiquidityRate\n\t\t\tREF_1034(uint256) (->reserveCache) := REF_1035(uint128)\n\t\tExpression: reserveCache.currVariableBorrowRate = reserve.currentVariableBorrowRate\n\t\tIRs:\n\t\t\tREF_1036(uint256) -> reserveCache.currVariableBorrowRate\n\t\t\tREF_1037(uint128) -> reserve.currentVariableBorrowRate\n\t\t\tREF_1036(uint256) (->reserveCache) := REF_1037(uint128)\n\t\tExpression: reserveCache.aTokenAddress = reserve.aTokenAddress\n\t\tIRs:\n\t\t\tREF_1038(address) -> reserveCache.aTokenAddress\n\t\t\tREF_1039(address) -> reserve.aTokenAddress\n\t\t\tREF_1038(address) (->reserveCache) := REF_1039(address)\n\t\tExpression: reserveCache.stableDebtTokenAddress = reserve.stableDebtTokenAddress\n\t\tIRs:\n\t\t\tREF_1040(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tREF_1041(address) -> reserve.stableDebtTokenAddress\n\t\t\tREF_1040(address) (->reserveCache) := REF_1041(address)\n\t\tExpression: reserveCache.variableDebtTokenAddress = reserve.variableDebtTokenAddress\n\t\tIRs:\n\t\t\tREF_1042(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tREF_1043(address) -> reserve.variableDebtTokenAddress\n\t\t\tREF_1042(address) (->reserveCache) := REF_1043(address)\n\t\tExpression: reserveCache.reserveLastUpdateTimestamp = reserve.lastUpdateTimestamp\n\t\tIRs:\n\t\t\tREF_1044(uint40) -> reserveCache.reserveLastUpdateTimestamp\n\t\t\tREF_1045(uint40) -> reserve.lastUpdateTimestamp\n\t\t\tREF_1044(uint40) (->reserveCache) := REF_1045(uint40)\n\t\tExpression: reserveCache.currScaledVariableDebt = reserveCache.nextScaledVariableDebt = IVariableDebtToken(reserveCache.variableDebtTokenAddress).scaledTotalSupply()\n\t\tIRs:\n\t\t\tREF_1046(uint256) -> reserveCache.currScaledVariableDebt\n\t\t\tREF_1047(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_1048(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_862 = CONVERT REF_1048 to IVariableDebtToken\n\t\t\tTMP_863(uint256) = HIGH_LEVEL_CALL, dest:TMP_862(IVariableDebtToken), function:scaledTotalSupply, arguments:[]  \n\t\t\tREF_1047(uint256) (->reserveCache) := TMP_863(uint256)\n\t\t\tREF_1046(uint256) (->reserveCache) := REF_1047(uint256)\n\t\tExpression: (reserveCache.currPrincipalStableDebt,reserveCache.currTotalStableDebt,reserveCache.currAvgStableBorrowRate,reserveCache.stableDebtLastUpdateTimestamp) = IStableDebtToken(reserveCache.stableDebtTokenAddress).getSupplyData()\n\t\tIRs:\n\t\t\tREF_1050(uint256) -> reserveCache.currPrincipalStableDebt\n\t\t\tREF_1051(uint256) -> reserveCache.currTotalStableDebt\n\t\t\tREF_1052(uint256) -> reserveCache.currAvgStableBorrowRate\n\t\t\tREF_1053(uint40) -> reserveCache.stableDebtLastUpdateTimestamp\n\t\t\tREF_1054(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_864 = CONVERT REF_1054 to IStableDebtToken\n\t\t\tTUPLE_27(uint256,uint256,uint256,uint40) = HIGH_LEVEL_CALL, dest:TMP_864(IStableDebtToken), function:getSupplyData, arguments:[]  \n\t\t\tREF_1050(uint256)= UNPACK TUPLE_27 index: 0 \n\t\t\tREF_1051(uint256)= UNPACK TUPLE_27 index: 1 \n\t\t\tREF_1052(uint256)= UNPACK TUPLE_27 index: 2 \n\t\t\tREF_1053(uint40)= UNPACK TUPLE_27 index: 3 \n\t\tExpression: reserveCache.nextTotalStableDebt = reserveCache.currTotalStableDebt\n\t\tIRs:\n\t\t\tREF_1056(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_1057(uint256) -> reserveCache.currTotalStableDebt\n\t\t\tREF_1056(uint256) (->reserveCache) := REF_1057(uint256)\n\t\tExpression: reserveCache.nextAvgStableBorrowRate = reserveCache.currAvgStableBorrowRate\n\t\tIRs:\n\t\t\tREF_1058(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_1059(uint256) -> reserveCache.currAvgStableBorrowRate\n\t\t\tREF_1058(uint256) (->reserveCache) := REF_1059(uint256)\n\t\tExpression: reserveCache\n\t\tIRs:\n\t\t\tRETURN reserveCache\nContract SupplyLogic\n\tFunction SupplyLogic.executeSupply(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteSupplyParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_1060(address) -> params.asset\n\t\t\tREF_1061(DataTypes.ReserveData) -> reservesData[REF_1060]\n\t\t\treserve(DataTypes.ReserveData) := REF_1061(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_865(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_865(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: ValidationLogic.validateSupply(reserveCache,reserve,params.amount)\n\t\tIRs:\n\t\t\tREF_1065(uint256) -> params.amount\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSupply(DataTypes.ReserveCache,DataTypes.ReserveData,uint256), arguments:['reserveCache', 'reserve', 'REF_1065'] \n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,params.amount,0)\n\t\tIRs:\n\t\t\tREF_1067(address) -> params.asset\n\t\t\tREF_1068(uint256) -> params.amount\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_1067', 'REF_1068', '0'] \n\t\tExpression: IERC20(params.asset).safeTransferFrom(msg.sender,reserveCache.aTokenAddress,params.amount)\n\t\tIRs:\n\t\t\tREF_1069(address) -> params.asset\n\t\t\tTMP_869 = CONVERT REF_1069 to IERC20\n\t\t\tREF_1071(address) -> reserveCache.aTokenAddress\n\t\t\tREF_1072(uint256) -> params.amount\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_869', 'msg.sender', 'REF_1071', 'REF_1072'] \n\t\tExpression: isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(msg.sender,params.onBehalfOf,params.amount,reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_1073(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_871 = CONVERT REF_1073 to IAToken\n\t\t\tREF_1075(address) -> params.onBehalfOf\n\t\t\tREF_1076(uint256) -> params.amount\n\t\t\tREF_1077(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_872(bool) = HIGH_LEVEL_CALL, dest:TMP_871(IAToken), function:mint, arguments:['msg.sender', 'REF_1075', 'REF_1076', 'REF_1077']  \n\t\t\tisFirstSupply(bool) := TMP_872(bool)\n\t\tExpression: isFirstSupply\n\t\tIRs:\n\t\t\tCONDITION isFirstSupply\n\t\tExpression: ValidationLogic.validateAutomaticUseAsCollateral(reservesData,reservesList,userConfig,reserveCache.reserveConfiguration,reserveCache.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_1079(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tREF_1080(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_873(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address), arguments:['reservesData', 'reservesList', 'userConfig', 'REF_1079', 'REF_1080'] \n\t\t\tCONDITION TMP_873\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,true)\n\t\tIRs:\n\t\t\tREF_1082(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_1082', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(params.asset,params.onBehalfOf)\n\t\tIRs:\n\t\t\tREF_1083(address) -> params.asset\n\t\t\tREF_1084(address) -> params.onBehalfOf\n\t\t\tEmit ReserveUsedAsCollateralEnabled(REF_1083,REF_1084)\n\t\tExpression: Supply(params.asset,msg.sender,params.onBehalfOf,params.amount,params.referralCode)\n\t\tIRs:\n\t\t\tREF_1085(address) -> params.asset\n\t\t\tREF_1086(address) -> params.onBehalfOf\n\t\t\tREF_1087(uint256) -> params.amount\n\t\t\tREF_1088(uint16) -> params.referralCode\n\t\t\tEmit Supply(REF_1085,msg.sender,REF_1086,REF_1087,REF_1088)\n\tFunction SupplyLogic.executeWithdraw(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteWithdrawParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_1089(address) -> params.asset\n\t\t\tREF_1090(DataTypes.ReserveData) -> reservesData[REF_1089]\n\t\t\treserve(DataTypes.ReserveData) := REF_1090(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_877(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_877(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: userBalance = IAToken(reserveCache.aTokenAddress).scaledBalanceOf(msg.sender).rayMul(reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_1093(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_879 = CONVERT REF_1093 to IAToken\n\t\t\tTMP_880(uint256) = HIGH_LEVEL_CALL, dest:TMP_879(IAToken), function:scaledBalanceOf, arguments:['msg.sender']  \n\t\t\tREF_1096(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_881(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_880', 'REF_1096'] \n\t\t\tuserBalance(uint256) := TMP_881(uint256)\n\t\tExpression: amountToWithdraw = params.amount\n\t\tIRs:\n\t\t\tREF_1097(uint256) -> params.amount\n\t\t\tamountToWithdraw(uint256) := REF_1097(uint256)\n\t\tExpression: params.amount == type()(uint256).max\n\t\tIRs:\n\t\t\tREF_1098(uint256) -> params.amount\n\t\t\tTMP_883(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tTMP_884(bool) = REF_1098 == TMP_883\n\t\t\tCONDITION TMP_884\n\t\tExpression: amountToWithdraw = userBalance\n\t\tIRs:\n\t\t\tamountToWithdraw(uint256) := userBalance(uint256)\n\t\tExpression: ValidationLogic.validateWithdraw(reserveCache,amountToWithdraw,userBalance)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateWithdraw(DataTypes.ReserveCache,uint256,uint256), arguments:['reserveCache', 'amountToWithdraw', 'userBalance'] \n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,0,amountToWithdraw)\n\t\tIRs:\n\t\t\tREF_1101(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_1101', '0', 'amountToWithdraw'] \n\t\tExpression: isCollateral = userConfig.isUsingAsCollateral(reserve.id)\n\t\tIRs:\n\t\t\tREF_1103(uint16) -> reserve.id\n\t\t\tTMP_887(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'REF_1103'] \n\t\t\tisCollateral(bool) := TMP_887(bool)\n\t\tExpression: isCollateral && amountToWithdraw == userBalance\n\t\tIRs:\n\t\t\tTMP_888(bool) = amountToWithdraw == userBalance\n\t\t\tTMP_889(bool) = isCollateral && TMP_888\n\t\t\tCONDITION TMP_889\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,false)\n\t\tIRs:\n\t\t\tREF_1105(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_1105', 'False'] \n\t\tExpression: ReserveUsedAsCollateralDisabled(params.asset,msg.sender)\n\t\tIRs:\n\t\t\tREF_1106(address) -> params.asset\n\t\t\tEmit ReserveUsedAsCollateralDisabled(REF_1106,msg.sender)\n\t\tExpression: IAToken(reserveCache.aTokenAddress).burn(msg.sender,params.to,amountToWithdraw,reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_1107(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_892 = CONVERT REF_1107 to IAToken\n\t\t\tREF_1109(address) -> params.to\n\t\t\tREF_1110(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_892(IAToken), function:burn, arguments:['msg.sender', 'REF_1109', 'amountToWithdraw', 'REF_1110']  \n\t\tExpression: isCollateral && userConfig.isBorrowingAny()\n\t\tIRs:\n\t\t\tTMP_894(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowingAny(DataTypes.UserConfigurationMap), arguments:['userConfig'] \n\t\t\tTMP_895(bool) = isCollateral && TMP_894\n\t\t\tCONDITION TMP_895\n\t\tExpression: ValidationLogic.validateHFAndLtv(reservesData,reservesList,eModeCategories,userConfig,params.asset,msg.sender,params.reservesCount,params.oracle,params.userEModeCategory)\n\t\tIRs:\n\t\t\tREF_1113(address) -> params.asset\n\t\t\tREF_1114(uint256) -> params.reservesCount\n\t\t\tREF_1115(address) -> params.oracle\n\t\t\tREF_1116(uint8) -> params.userEModeCategory\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateHFAndLtv(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,address,uint256,address,uint8), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'REF_1113', 'msg.sender', 'REF_1114', 'REF_1115', 'REF_1116'] \n\t\tExpression: Withdraw(params.asset,msg.sender,params.to,amountToWithdraw)\n\t\tIRs:\n\t\t\tREF_1117(address) -> params.asset\n\t\t\tREF_1118(address) -> params.to\n\t\t\tEmit Withdraw(REF_1117,msg.sender,REF_1118,amountToWithdraw)\n\t\tExpression: amountToWithdraw\n\t\tIRs:\n\t\t\tRETURN amountToWithdraw\n\tFunction SupplyLogic.executeFinalizeTransfer(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),mapping(address => DataTypes.UserConfigurationMap),DataTypes.FinalizeTransferParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_1119(address) -> params.asset\n\t\t\tREF_1120(DataTypes.ReserveData) -> reservesData[REF_1119]\n\t\t\treserve(DataTypes.ReserveData) := REF_1120(DataTypes.ReserveData)\n\t\tExpression: ValidationLogic.validateTransfer(reserve)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateTransfer(DataTypes.ReserveData), arguments:['reserve'] \n\t\tExpression: reserveId = reserve.id\n\t\tIRs:\n\t\t\tREF_1122(uint16) -> reserve.id\n\t\t\treserveId(uint256) := REF_1122(uint16)\n\t\tExpression: params.from != params.to && params.amount != 0\n\t\tIRs:\n\t\t\tREF_1123(address) -> params.from\n\t\t\tREF_1124(address) -> params.to\n\t\t\tTMP_899(bool) = REF_1123 != REF_1124\n\t\t\tREF_1125(uint256) -> params.amount\n\t\t\tTMP_900(bool) = REF_1125 != 0\n\t\t\tTMP_901(bool) = TMP_899 && TMP_900\n\t\t\tCONDITION TMP_901\n\t\tExpression: fromConfig = usersConfig[params.from]\n\t\tIRs:\n\t\t\tREF_1126(address) -> params.from\n\t\t\tREF_1127(DataTypes.UserConfigurationMap) -> usersConfig[REF_1126]\n\t\t\tfromConfig(DataTypes.UserConfigurationMap) := REF_1127(DataTypes.UserConfigurationMap)\n\t\tExpression: fromConfig.isUsingAsCollateral(reserveId)\n\t\tIRs:\n\t\t\tTMP_902(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['fromConfig', 'reserveId'] \n\t\t\tCONDITION TMP_902\n\t\tExpression: fromConfig.isBorrowingAny()\n\t\tIRs:\n\t\t\tTMP_903(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowingAny(DataTypes.UserConfigurationMap), arguments:['fromConfig'] \n\t\t\tCONDITION TMP_903\n\t\tExpression: ValidationLogic.validateHFAndLtv(reservesData,reservesList,eModeCategories,usersConfig[params.from],params.asset,params.from,params.reservesCount,params.oracle,params.fromEModeCategory)\n\t\tIRs:\n\t\t\tREF_1131(address) -> params.from\n\t\t\tREF_1132(DataTypes.UserConfigurationMap) -> usersConfig[REF_1131]\n\t\t\tREF_1133(address) -> params.asset\n\t\t\tREF_1134(address) -> params.from\n\t\t\tREF_1135(uint256) -> params.reservesCount\n\t\t\tREF_1136(address) -> params.oracle\n\t\t\tREF_1137(uint8) -> params.fromEModeCategory\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateHFAndLtv(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,address,uint256,address,uint8), arguments:['reservesData', 'reservesList', 'eModeCategories', 'REF_1132', 'REF_1133', 'REF_1134', 'REF_1135', 'REF_1136', 'REF_1137'] \n\t\tExpression: params.balanceFromBefore == params.amount\n\t\tIRs:\n\t\t\tREF_1138(uint256) -> params.balanceFromBefore\n\t\t\tREF_1139(uint256) -> params.amount\n\t\t\tTMP_905(bool) = REF_1138 == REF_1139\n\t\t\tCONDITION TMP_905\n\t\tExpression: fromConfig.setUsingAsCollateral(reserveId,false)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['fromConfig', 'reserveId', 'False'] \n\t\tExpression: ReserveUsedAsCollateralDisabled(params.asset,params.from)\n\t\tIRs:\n\t\t\tREF_1141(address) -> params.asset\n\t\t\tREF_1142(address) -> params.from\n\t\t\tEmit ReserveUsedAsCollateralDisabled(REF_1141,REF_1142)\n\t\tExpression: params.balanceToBefore == 0\n\t\tIRs:\n\t\t\tREF_1143(uint256) -> params.balanceToBefore\n\t\t\tTMP_908(bool) = REF_1143 == 0\n\t\t\tCONDITION TMP_908\n\t\tExpression: toConfig = usersConfig[params.to]\n\t\tIRs:\n\t\t\tREF_1144(address) -> params.to\n\t\t\tREF_1145(DataTypes.UserConfigurationMap) -> usersConfig[REF_1144]\n\t\t\ttoConfig(DataTypes.UserConfigurationMap) := REF_1145(DataTypes.UserConfigurationMap)\n\t\tExpression: ValidationLogic.validateAutomaticUseAsCollateral(reservesData,reservesList,toConfig,reserve.configuration,reserve.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_1147(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tREF_1148(address) -> reserve.aTokenAddress\n\t\t\tTMP_909(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address), arguments:['reservesData', 'reservesList', 'toConfig', 'REF_1147', 'REF_1148'] \n\t\t\tCONDITION TMP_909\n\t\tExpression: toConfig.setUsingAsCollateral(reserveId,true)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['toConfig', 'reserveId', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(params.asset,params.to)\n\t\tIRs:\n\t\t\tREF_1150(address) -> params.asset\n\t\t\tREF_1151(address) -> params.to\n\t\t\tEmit ReserveUsedAsCollateralEnabled(REF_1150,REF_1151)\n\tFunction SupplyLogic.executeUseReserveAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,bool,uint256,address,uint8) (*)\n\t\tExpression: reserve = reservesData[asset]\n\t\tIRs:\n\t\t\tREF_1152(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treserve(DataTypes.ReserveData) := REF_1152(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_912(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_912(DataTypes.ReserveCache)\n\t\tExpression: userBalance = IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender)\n\t\tIRs:\n\t\t\tREF_1154(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_913 = CONVERT REF_1154 to IERC20\n\t\t\tTMP_914(uint256) = HIGH_LEVEL_CALL, dest:TMP_913(IERC20), function:balanceOf, arguments:['msg.sender']  \n\t\t\tuserBalance(uint256) := TMP_914(uint256)\n\t\tExpression: ValidationLogic.validateSetUseReserveAsCollateral(reserveCache,userBalance)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSetUseReserveAsCollateral(DataTypes.ReserveCache,uint256), arguments:['reserveCache', 'userBalance'] \n\t\tExpression: useAsCollateral == userConfig.isUsingAsCollateral(reserve.id)\n\t\tIRs:\n\t\t\tREF_1158(uint16) -> reserve.id\n\t\t\tTMP_916(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'REF_1158'] \n\t\t\tTMP_917(bool) = useAsCollateral == TMP_916\n\t\t\tCONDITION TMP_917\n\t\tExpression: useAsCollateral\n\t\tIRs:\n\t\t\tCONDITION useAsCollateral\n\t\tExpression: require(bool,string)(ValidationLogic.validateUseAsCollateral(reservesData,reservesList,userConfig,reserveCache.reserveConfiguration),Errors.USER_IN_ISOLATION_MODE_OR_LTV_ZERO)\n\t\tIRs:\n\t\t\tREF_1160(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_918(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap), arguments:['reservesData', 'reservesList', 'userConfig', 'REF_1160'] \n\t\t\tREF_1161(string) -> Errors.USER_IN_ISOLATION_MODE_OR_LTV_ZERO\n\t\t\tTMP_919(None) = SOLIDITY_CALL require(bool,string)(TMP_918,REF_1161)\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,true)\n\t\tIRs:\n\t\t\tREF_1163(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_1163', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(asset,msg.sender)\n\t\tIRs:\n\t\t\tEmit ReserveUsedAsCollateralEnabled(asset,msg.sender)\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,false)\n\t\tIRs:\n\t\t\tREF_1165(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_1165', 'False'] \n\t\tExpression: ValidationLogic.validateHFAndLtv(reservesData,reservesList,eModeCategories,userConfig,asset,msg.sender,reservesCount,priceOracle,userEModeCategory)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateHFAndLtv(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,address,uint256,address,uint8), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'asset', 'msg.sender', 'reservesCount', 'priceOracle', 'userEModeCategory'] \n\t\tExpression: ReserveUsedAsCollateralDisabled(asset,msg.sender)\n\t\tIRs:\n\t\t\tEmit ReserveUsedAsCollateralDisabled(asset,msg.sender)\nContract ValidationLogic\n\tFunction ValidationLogic.validateSupply(DataTypes.ReserveCache,DataTypes.ReserveData,uint256) (*)\n\t\tExpression: require(bool,string)(amount != 0,Errors.INVALID_AMOUNT)\n\t\tIRs:\n\t\t\tTMP_925(bool) = amount != 0\n\t\t\tREF_1167(string) -> Errors.INVALID_AMOUNT\n\t\t\tTMP_926(None) = SOLIDITY_CALL require(bool,string)(TMP_925,REF_1167)\n\t\tExpression: (isActive,isFrozen,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1168(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_28(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1168'] \n\t\t\tisActive(bool)= UNPACK TUPLE_28 index: 0 \n\t\t\tisFrozen(bool)= UNPACK TUPLE_28 index: 1 \n\t\t\tisPaused(bool)= UNPACK TUPLE_28 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1170(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_927(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1170)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_928 = UnaryType.BANG isPaused \n\t\t\tREF_1171(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_929(None) = SOLIDITY_CALL require(bool,string)(TMP_928,REF_1171)\n\t\tExpression: require(bool,string)(! isFrozen,Errors.RESERVE_FROZEN)\n\t\tIRs:\n\t\t\tTMP_930 = UnaryType.BANG isFrozen \n\t\t\tREF_1172(string) -> Errors.RESERVE_FROZEN\n\t\t\tTMP_931(None) = SOLIDITY_CALL require(bool,string)(TMP_930,REF_1172)\n\t\tExpression: supplyCap = reserveCache.reserveConfiguration.getSupplyCap()\n\t\tIRs:\n\t\t\tREF_1173(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_932(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getSupplyCap(DataTypes.ReserveConfigurationMap), arguments:['REF_1173'] \n\t\t\tsupplyCap(uint256) := TMP_932(uint256)\n\t\tExpression: require(bool,string)(supplyCap == 0 || ((IAToken(reserveCache.aTokenAddress).scaledTotalSupply() + uint256(reserve.accruedToTreasury)).rayMul(reserveCache.nextLiquidityIndex) + amount) <= supplyCap * (10 ** reserveCache.reserveConfiguration.getDecimals()),Errors.SUPPLY_CAP_EXCEEDED)\n\t\tIRs:\n\t\t\tTMP_933(bool) = supplyCap == 0\n\t\t\tREF_1175(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_934 = CONVERT REF_1175 to IAToken\n\t\t\tTMP_935(uint256) = HIGH_LEVEL_CALL, dest:TMP_934(IAToken), function:scaledTotalSupply, arguments:[]  \n\t\t\tREF_1177(uint128) -> reserve.accruedToTreasury\n\t\t\tTMP_936 = CONVERT REF_1177 to uint256\n\t\t\tTMP_937(uint256) = TMP_935 (c)+ TMP_936\n\t\t\tREF_1179(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_938(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_937', 'REF_1179'] \n\t\t\tTMP_939(uint256) = TMP_938 (c)+ amount\n\t\t\tREF_1180(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_940(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_1180'] \n\t\t\tTMP_941(uint256) = 10 (c)** TMP_940\n\t\t\tTMP_942(uint256) = supplyCap (c)* TMP_941\n\t\t\tTMP_943(bool) = TMP_939 <= TMP_942\n\t\t\tTMP_944(bool) = TMP_933 || TMP_943\n\t\t\tREF_1182(string) -> Errors.SUPPLY_CAP_EXCEEDED\n\t\t\tTMP_945(None) = SOLIDITY_CALL require(bool,string)(TMP_944,REF_1182)\n\tFunction ValidationLogic.validateWithdraw(DataTypes.ReserveCache,uint256,uint256) (*)\n\t\tExpression: require(bool,string)(amount != 0,Errors.INVALID_AMOUNT)\n\t\tIRs:\n\t\t\tTMP_946(bool) = amount != 0\n\t\t\tREF_1183(string) -> Errors.INVALID_AMOUNT\n\t\t\tTMP_947(None) = SOLIDITY_CALL require(bool,string)(TMP_946,REF_1183)\n\t\tExpression: require(bool,string)(amount <= userBalance,Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE)\n\t\tIRs:\n\t\t\tTMP_948(bool) = amount <= userBalance\n\t\t\tREF_1184(string) -> Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE\n\t\t\tTMP_949(None) = SOLIDITY_CALL require(bool,string)(TMP_948,REF_1184)\n\t\tExpression: (isActive,None,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1185(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_29(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1185'] \n\t\t\tisActive(bool)= UNPACK TUPLE_29 index: 0 \n\t\t\tisPaused(bool)= UNPACK TUPLE_29 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1187(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_950(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1187)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_951 = UnaryType.BANG isPaused \n\t\t\tREF_1188(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_952(None) = SOLIDITY_CALL require(bool,string)(TMP_951,REF_1188)\n\tFunction ValidationLogic.validateBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.ValidateBorrowParams) (*)\n\t\tExpression: require(bool,string)(params.amount != 0,Errors.INVALID_AMOUNT)\n\t\tIRs:\n\t\t\tREF_1189(uint256) -> params.amount\n\t\t\tTMP_953(bool) = REF_1189 != 0\n\t\t\tREF_1190(string) -> Errors.INVALID_AMOUNT\n\t\t\tTMP_954(None) = SOLIDITY_CALL require(bool,string)(TMP_953,REF_1190)\n\t\tExpression: (vars.isActive,vars.isFrozen,vars.borrowingEnabled,vars.stableRateBorrowingEnabled,vars.isPaused) = params.reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1191(bool) -> vars.isActive\n\t\t\tREF_1192(bool) -> vars.isFrozen\n\t\t\tREF_1193(bool) -> vars.borrowingEnabled\n\t\t\tREF_1194(bool) -> vars.stableRateBorrowingEnabled\n\t\t\tREF_1195(bool) -> vars.isPaused\n\t\t\tREF_1196(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1197(DataTypes.ReserveConfigurationMap) -> REF_1196.reserveConfiguration\n\t\t\tTUPLE_30(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1197'] \n\t\t\tREF_1191(bool)= UNPACK TUPLE_30 index: 0 \n\t\t\tREF_1192(bool)= UNPACK TUPLE_30 index: 1 \n\t\t\tREF_1193(bool)= UNPACK TUPLE_30 index: 2 \n\t\t\tREF_1194(bool)= UNPACK TUPLE_30 index: 3 \n\t\t\tREF_1195(bool)= UNPACK TUPLE_30 index: 4 \n\t\tExpression: require(bool,string)(vars.isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1199(bool) -> vars.isActive\n\t\t\tREF_1200(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_955(None) = SOLIDITY_CALL require(bool,string)(REF_1199,REF_1200)\n\t\tExpression: require(bool,string)(! vars.isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tREF_1201(bool) -> vars.isPaused\n\t\t\tTMP_956 = UnaryType.BANG REF_1201 \n\t\t\tREF_1202(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_957(None) = SOLIDITY_CALL require(bool,string)(TMP_956,REF_1202)\n\t\tExpression: require(bool,string)(! vars.isFrozen,Errors.RESERVE_FROZEN)\n\t\tIRs:\n\t\t\tREF_1203(bool) -> vars.isFrozen\n\t\t\tTMP_958 = UnaryType.BANG REF_1203 \n\t\t\tREF_1204(string) -> Errors.RESERVE_FROZEN\n\t\t\tTMP_959(None) = SOLIDITY_CALL require(bool,string)(TMP_958,REF_1204)\n\t\tExpression: require(bool,string)(vars.borrowingEnabled,Errors.BORROWING_NOT_ENABLED)\n\t\tIRs:\n\t\t\tREF_1205(bool) -> vars.borrowingEnabled\n\t\t\tREF_1206(string) -> Errors.BORROWING_NOT_ENABLED\n\t\t\tTMP_960(None) = SOLIDITY_CALL require(bool,string)(REF_1205,REF_1206)\n\t\tExpression: require(bool,string)(params.priceOracleSentinel == address(0) || IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(),Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED)\n\t\tIRs:\n\t\t\tREF_1207(address) -> params.priceOracleSentinel\n\t\t\tTMP_961 = CONVERT 0 to address\n\t\t\tTMP_962(bool) = REF_1207 == TMP_961\n\t\t\tREF_1208(address) -> params.priceOracleSentinel\n\t\t\tTMP_963 = CONVERT REF_1208 to IPriceOracleSentinel\n\t\t\tTMP_964(bool) = HIGH_LEVEL_CALL, dest:TMP_963(IPriceOracleSentinel), function:isBorrowAllowed, arguments:[]  \n\t\t\tTMP_965(bool) = TMP_962 || TMP_964\n\t\t\tREF_1210(string) -> Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n\t\t\tTMP_966(None) = SOLIDITY_CALL require(bool,string)(TMP_965,REF_1210)\n\t\tExpression: require(bool,string)(params.interestRateMode == DataTypes.InterestRateMode.VARIABLE || params.interestRateMode == DataTypes.InterestRateMode.STABLE,Errors.INVALID_INTEREST_RATE_MODE_SELECTED)\n\t\tIRs:\n\t\t\tREF_1211(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_1212(DataTypes.InterestRateMode) -> InterestRateMode.VARIABLE\n\t\t\tTMP_967(bool) = REF_1211 == REF_1212\n\t\t\tREF_1213(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_1214(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_968(bool) = REF_1213 == REF_1214\n\t\t\tTMP_969(bool) = TMP_967 || TMP_968\n\t\t\tREF_1215(string) -> Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n\t\t\tTMP_970(None) = SOLIDITY_CALL require(bool,string)(TMP_969,REF_1215)\n\t\tExpression: vars.reserveDecimals = params.reserveCache.reserveConfiguration.getDecimals()\n\t\tIRs:\n\t\t\tREF_1216(uint256) -> vars.reserveDecimals\n\t\t\tREF_1217(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1218(DataTypes.ReserveConfigurationMap) -> REF_1217.reserveConfiguration\n\t\t\tTMP_971(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_1218'] \n\t\t\tREF_1216(uint256) (->vars) := TMP_971(uint256)\n\t\tExpression: vars.borrowCap = params.reserveCache.reserveConfiguration.getBorrowCap()\n\t\tIRs:\n\t\t\tREF_1220(uint256) -> vars.borrowCap\n\t\t\tREF_1221(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1222(DataTypes.ReserveConfigurationMap) -> REF_1221.reserveConfiguration\n\t\t\tTMP_972(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getBorrowCap(DataTypes.ReserveConfigurationMap), arguments:['REF_1222'] \n\t\t\tREF_1220(uint256) (->vars) := TMP_972(uint256)\n\t\tExpression: vars.assetUnit = 10 ** vars.reserveDecimals\n\t\tIRs:\n\t\t\tREF_1224(uint256) -> vars.assetUnit\n\t\t\tREF_1225(uint256) -> vars.reserveDecimals\n\t\t\tTMP_973(uint256) = 10 ** REF_1225\n\t\t\tREF_1224(uint256) (->vars) := TMP_973(uint256)\n\t\tExpression: vars.borrowCap != 0\n\t\tIRs:\n\t\t\tREF_1226(uint256) -> vars.borrowCap\n\t\t\tTMP_974(bool) = REF_1226 != 0\n\t\t\tCONDITION TMP_974\n\t\tExpression: vars.totalSupplyVariableDebt = params.reserveCache.currScaledVariableDebt.rayMul(params.reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_1227(uint256) -> vars.totalSupplyVariableDebt\n\t\t\tREF_1228(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1229(uint256) -> REF_1228.currScaledVariableDebt\n\t\t\tREF_1231(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1232(uint256) -> REF_1231.nextVariableBorrowIndex\n\t\t\tTMP_975(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_1229', 'REF_1232'] \n\t\t\tREF_1227(uint256) (->vars) := TMP_975(uint256)\n\t\tExpression: vars.totalDebt = params.reserveCache.currTotalStableDebt + vars.totalSupplyVariableDebt + params.amount\n\t\tIRs:\n\t\t\tREF_1233(uint256) -> vars.totalDebt\n\t\t\tREF_1234(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1235(uint256) -> REF_1234.currTotalStableDebt\n\t\t\tREF_1236(uint256) -> vars.totalSupplyVariableDebt\n\t\t\tTMP_976(uint256) = REF_1235 (c)+ REF_1236\n\t\t\tREF_1237(uint256) -> params.amount\n\t\t\tTMP_977(uint256) = TMP_976 (c)+ REF_1237\n\t\t\tREF_1233(uint256) (->vars) := TMP_977(uint256)\n\t\tExpression: require(bool,string)(vars.totalDebt <= vars.borrowCap * vars.assetUnit,Errors.BORROW_CAP_EXCEEDED)\n\t\tIRs:\n\t\t\tREF_1238(uint256) -> vars.totalDebt\n\t\t\tREF_1239(uint256) -> vars.borrowCap\n\t\t\tREF_1240(uint256) -> vars.assetUnit\n\t\t\tTMP_978(uint256) = REF_1239 * REF_1240\n\t\t\tTMP_979(bool) = REF_1238 <= TMP_978\n\t\t\tREF_1241(string) -> Errors.BORROW_CAP_EXCEEDED\n\t\t\tTMP_980(None) = SOLIDITY_CALL require(bool,string)(TMP_979,REF_1241)\n\t\tExpression: params.isolationModeActive\n\t\tIRs:\n\t\t\tREF_1242(bool) -> params.isolationModeActive\n\t\t\tCONDITION REF_1242\n\t\tExpression: require(bool,string)(params.reserveCache.reserveConfiguration.getBorrowableInIsolation(),Errors.ASSET_NOT_BORROWABLE_IN_ISOLATION)\n\t\tIRs:\n\t\t\tREF_1243(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1244(DataTypes.ReserveConfigurationMap) -> REF_1243.reserveConfiguration\n\t\t\tTMP_981(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getBorrowableInIsolation(DataTypes.ReserveConfigurationMap), arguments:['REF_1244'] \n\t\t\tREF_1246(string) -> Errors.ASSET_NOT_BORROWABLE_IN_ISOLATION\n\t\t\tTMP_982(None) = SOLIDITY_CALL require(bool,string)(TMP_981,REF_1246)\n\t\tExpression: require(bool,string)(reservesData[params.isolationModeCollateralAddress].isolationModeTotalDebt + (params.amount / 10 ** (vars.reserveDecimals - ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128() <= params.isolationModeDebtCeiling,Errors.DEBT_CEILING_EXCEEDED)\n\t\tIRs:\n\t\t\tREF_1247(address) -> params.isolationModeCollateralAddress\n\t\t\tREF_1248(DataTypes.ReserveData) -> reservesData[REF_1247]\n\t\t\tREF_1249(uint128) -> REF_1248.isolationModeTotalDebt\n\t\t\tREF_1250(uint256) -> params.amount\n\t\t\tREF_1251(uint256) -> vars.reserveDecimals\n\t\t\tREF_1252(uint256) -> ReserveConfiguration.DEBT_CEILING_DECIMALS\n\t\t\tTMP_983(uint256) = REF_1251 (c)- REF_1252\n\t\t\tTMP_984(uint256) = 10 (c)** TMP_983\n\t\t\tTMP_985(uint256) = REF_1250 (c)/ TMP_984\n\t\t\tTMP_986(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_985'] \n\t\t\tTMP_987(uint128) = REF_1249 (c)+ TMP_986\n\t\t\tREF_1254(uint256) -> params.isolationModeDebtCeiling\n\t\t\tTMP_988(bool) = TMP_987 <= REF_1254\n\t\t\tREF_1255(string) -> Errors.DEBT_CEILING_EXCEEDED\n\t\t\tTMP_989(None) = SOLIDITY_CALL require(bool,string)(TMP_988,REF_1255)\n\t\tExpression: params.userEModeCategory != 0\n\t\tIRs:\n\t\t\tREF_1256(uint8) -> params.userEModeCategory\n\t\t\tTMP_990(bool) = REF_1256 != 0\n\t\t\tCONDITION TMP_990\n\t\tExpression: require(bool,string)(params.reserveCache.reserveConfiguration.getEModeCategory() == params.userEModeCategory,Errors.INCONSISTENT_EMODE_CATEGORY)\n\t\tIRs:\n\t\t\tREF_1257(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1258(DataTypes.ReserveConfigurationMap) -> REF_1257.reserveConfiguration\n\t\t\tTMP_991(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getEModeCategory(DataTypes.ReserveConfigurationMap), arguments:['REF_1258'] \n\t\t\tREF_1260(uint8) -> params.userEModeCategory\n\t\t\tTMP_992(bool) = TMP_991 == REF_1260\n\t\t\tREF_1261(string) -> Errors.INCONSISTENT_EMODE_CATEGORY\n\t\t\tTMP_993(None) = SOLIDITY_CALL require(bool,string)(TMP_992,REF_1261)\n\t\tExpression: vars.eModePriceSource = eModeCategories[params.userEModeCategory].priceSource\n\t\tIRs:\n\t\t\tREF_1262(address) -> vars.eModePriceSource\n\t\t\tREF_1263(uint8) -> params.userEModeCategory\n\t\t\tREF_1264(DataTypes.EModeCategory) -> eModeCategories[REF_1263]\n\t\t\tREF_1265(address) -> REF_1264.priceSource\n\t\t\tREF_1262(address) (->vars) := REF_1265(address)\n\t\tExpression: (vars.userCollateralInBaseCurrency,vars.userDebtInBaseCurrency,vars.currentLtv,None,vars.healthFactor,None) = GenericLogic.calculateUserAccountData(reservesData,reservesList,eModeCategories,DataTypes.CalculateUserAccountDataParams({userConfig:params.userConfig,reservesCount:params.reservesCount,user:params.userAddress,oracle:params.oracle,userEModeCategory:params.userEModeCategory}))\n\t\tIRs:\n\t\t\tREF_1266(uint256) -> vars.userCollateralInBaseCurrency\n\t\t\tREF_1267(uint256) -> vars.userDebtInBaseCurrency\n\t\t\tREF_1268(uint256) -> vars.currentLtv\n\t\t\tREF_1269(uint256) -> vars.healthFactor\n\t\t\tREF_1272(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_1273(uint256) -> params.reservesCount\n\t\t\tREF_1274(address) -> params.userAddress\n\t\t\tREF_1275(address) -> params.oracle\n\t\t\tREF_1276(uint8) -> params.userEModeCategory\n\t\t\tTMP_994(DataTypes.CalculateUserAccountDataParams) = new CalculateUserAccountDataParams(REF_1272,REF_1273,REF_1274,REF_1275,REF_1276)\n\t\t\tTUPLE_31(uint256,uint256,uint256,uint256,uint256,bool) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'TMP_994'] \n\t\t\tREF_1266(uint256)= UNPACK TUPLE_31 index: 0 \n\t\t\tREF_1267(uint256)= UNPACK TUPLE_31 index: 1 \n\t\t\tREF_1268(uint256)= UNPACK TUPLE_31 index: 2 \n\t\t\tREF_1269(uint256)= UNPACK TUPLE_31 index: 4 \n\t\tExpression: require(bool,string)(vars.userCollateralInBaseCurrency != 0,Errors.COLLATERAL_BALANCE_IS_ZERO)\n\t\tIRs:\n\t\t\tREF_1277(uint256) -> vars.userCollateralInBaseCurrency\n\t\t\tTMP_995(bool) = REF_1277 != 0\n\t\t\tREF_1278(string) -> Errors.COLLATERAL_BALANCE_IS_ZERO\n\t\t\tTMP_996(None) = SOLIDITY_CALL require(bool,string)(TMP_995,REF_1278)\n\t\tExpression: require(bool,string)(vars.currentLtv != 0,Errors.LTV_VALIDATION_FAILED)\n\t\tIRs:\n\t\t\tREF_1279(uint256) -> vars.currentLtv\n\t\t\tTMP_997(bool) = REF_1279 != 0\n\t\t\tREF_1280(string) -> Errors.LTV_VALIDATION_FAILED\n\t\t\tTMP_998(None) = SOLIDITY_CALL require(bool,string)(TMP_997,REF_1280)\n\t\tExpression: require(bool,string)(vars.healthFactor > HEALTH_FACTOR_LIQUIDATION_THRESHOLD,Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD)\n\t\tIRs:\n\t\t\tREF_1281(uint256) -> vars.healthFactor\n\t\t\tTMP_999(bool) = REF_1281 > HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n\t\t\tREF_1282(string) -> Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n\t\t\tTMP_1000(None) = SOLIDITY_CALL require(bool,string)(TMP_999,REF_1282)\n\t\tExpression: vars.amountInBaseCurrency /= vars.assetUnit\n\t\tIRs:\n\t\t\tREF_1283(uint256) -> vars.amountInBaseCurrency\n\t\t\tREF_1284(uint256) -> vars.assetUnit\n\t\t\tREF_1283(-> vars) = REF_1283 / REF_1284\n\t\tExpression: vars.collateralNeededInBaseCurrency = (vars.userDebtInBaseCurrency + vars.amountInBaseCurrency).percentDiv(vars.currentLtv)\n\t\tIRs:\n\t\t\tREF_1285(uint256) -> vars.collateralNeededInBaseCurrency\n\t\t\tREF_1286(uint256) -> vars.userDebtInBaseCurrency\n\t\t\tREF_1287(uint256) -> vars.amountInBaseCurrency\n\t\t\tTMP_1001(uint256) = REF_1286 (c)+ REF_1287\n\t\t\tREF_1289(uint256) -> vars.currentLtv\n\t\t\tTMP_1002(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentDiv(uint256,uint256), arguments:['TMP_1001', 'REF_1289'] \n\t\t\tREF_1285(uint256) (->vars) := TMP_1002(uint256)\n\t\tExpression: require(bool,string)(vars.collateralNeededInBaseCurrency <= vars.userCollateralInBaseCurrency,Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW)\n\t\tIRs:\n\t\t\tREF_1290(uint256) -> vars.collateralNeededInBaseCurrency\n\t\t\tREF_1291(uint256) -> vars.userCollateralInBaseCurrency\n\t\t\tTMP_1003(bool) = REF_1290 <= REF_1291\n\t\t\tREF_1292(string) -> Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW\n\t\t\tTMP_1004(None) = SOLIDITY_CALL require(bool,string)(TMP_1003,REF_1292)\n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_1293(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_1294(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_1005(bool) = REF_1293 == REF_1294\n\t\t\tCONDITION TMP_1005\n\t\tExpression: require(bool,string)(vars.stableRateBorrowingEnabled,Errors.STABLE_BORROWING_NOT_ENABLED)\n\t\tIRs:\n\t\t\tREF_1295(bool) -> vars.stableRateBorrowingEnabled\n\t\t\tREF_1296(string) -> Errors.STABLE_BORROWING_NOT_ENABLED\n\t\t\tTMP_1006(None) = SOLIDITY_CALL require(bool,string)(REF_1295,REF_1296)\n\t\tExpression: require(bool,string)(! params.userConfig.isUsingAsCollateral(reservesData[params.asset].id) || params.reserveCache.reserveConfiguration.getLtv() == 0 || params.amount > IERC20(params.reserveCache.aTokenAddress).balanceOf(params.userAddress),Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY)\n\t\tIRs:\n\t\t\tREF_1297(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_1299(address) -> params.asset\n\t\t\tREF_1300(DataTypes.ReserveData) -> reservesData[REF_1299]\n\t\t\tREF_1301(uint16) -> REF_1300.id\n\t\t\tTMP_1007(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['REF_1297', 'REF_1301'] \n\t\t\tTMP_1008 = UnaryType.BANG TMP_1007 \n\t\t\tREF_1302(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1303(DataTypes.ReserveConfigurationMap) -> REF_1302.reserveConfiguration\n\t\t\tTMP_1009(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap), arguments:['REF_1303'] \n\t\t\tTMP_1010(bool) = TMP_1009 == 0\n\t\t\tTMP_1011(bool) = TMP_1008 || TMP_1010\n\t\t\tREF_1305(uint256) -> params.amount\n\t\t\tREF_1306(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1307(address) -> REF_1306.aTokenAddress\n\t\t\tTMP_1012 = CONVERT REF_1307 to IERC20\n\t\t\tREF_1309(address) -> params.userAddress\n\t\t\tTMP_1013(uint256) = HIGH_LEVEL_CALL, dest:TMP_1012(IERC20), function:balanceOf, arguments:['REF_1309']  \n\t\t\tTMP_1014(bool) = REF_1305 > TMP_1013\n\t\t\tTMP_1015(bool) = TMP_1011 || TMP_1014\n\t\t\tREF_1310(string) -> Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n\t\t\tTMP_1016(None) = SOLIDITY_CALL require(bool,string)(TMP_1015,REF_1310)\n\t\tExpression: vars.availableLiquidity = IERC20(params.asset).balanceOf(params.reserveCache.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_1311(uint256) -> vars.availableLiquidity\n\t\t\tREF_1312(address) -> params.asset\n\t\t\tTMP_1017 = CONVERT REF_1312 to IERC20\n\t\t\tREF_1314(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1315(address) -> REF_1314.aTokenAddress\n\t\t\tTMP_1018(uint256) = HIGH_LEVEL_CALL, dest:TMP_1017(IERC20), function:balanceOf, arguments:['REF_1315']  \n\t\t\tREF_1311(uint256) (->vars) := TMP_1018(uint256)\n\t\tExpression: maxLoanSizeStable = vars.availableLiquidity.percentMul(params.maxStableLoanPercent)\n\t\tIRs:\n\t\t\tREF_1316(uint256) -> vars.availableLiquidity\n\t\t\tREF_1318(uint256) -> params.maxStableLoanPercent\n\t\t\tTMP_1019(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_1316', 'REF_1318'] \n\t\t\tmaxLoanSizeStable(uint256) := TMP_1019(uint256)\n\t\tExpression: require(bool,string)(params.amount <= maxLoanSizeStable,Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE)\n\t\tIRs:\n\t\t\tREF_1319(uint256) -> params.amount\n\t\t\tTMP_1020(bool) = REF_1319 <= maxLoanSizeStable\n\t\t\tREF_1320(string) -> Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE\n\t\t\tTMP_1021(None) = SOLIDITY_CALL require(bool,string)(TMP_1020,REF_1320)\n\t\tExpression: params.userConfig.isBorrowingAny()\n\t\tIRs:\n\t\t\tREF_1321(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tTMP_1022(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowingAny(DataTypes.UserConfigurationMap), arguments:['REF_1321'] \n\t\t\tCONDITION TMP_1022\n\t\tExpression: (vars.siloedBorrowingEnabled,vars.siloedBorrowingAddress) = params.userConfig.getSiloedBorrowingState(reservesData,reservesList)\n\t\tIRs:\n\t\t\tREF_1323(bool) -> vars.siloedBorrowingEnabled\n\t\t\tREF_1324(address) -> vars.siloedBorrowingAddress\n\t\t\tREF_1325(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tTUPLE_32(bool,address) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.getSiloedBorrowingState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)), arguments:['REF_1325', 'reservesData', 'reservesList'] \n\t\t\tREF_1323(bool)= UNPACK TUPLE_32 index: 0 \n\t\t\tREF_1324(address)= UNPACK TUPLE_32 index: 1 \n\t\tExpression: vars.siloedBorrowingEnabled\n\t\tIRs:\n\t\t\tREF_1327(bool) -> vars.siloedBorrowingEnabled\n\t\t\tCONDITION REF_1327\n\t\tExpression: require(bool,string)(vars.siloedBorrowingAddress == params.asset,Errors.SILOED_BORROWING_VIOLATION)\n\t\tIRs:\n\t\t\tREF_1328(address) -> vars.siloedBorrowingAddress\n\t\t\tREF_1329(address) -> params.asset\n\t\t\tTMP_1023(bool) = REF_1328 == REF_1329\n\t\t\tREF_1330(string) -> Errors.SILOED_BORROWING_VIOLATION\n\t\t\tTMP_1024(None) = SOLIDITY_CALL require(bool,string)(TMP_1023,REF_1330)\n\t\tExpression: require(bool,string)(! params.reserveCache.reserveConfiguration.getSiloedBorrowing(),Errors.SILOED_BORROWING_VIOLATION)\n\t\tIRs:\n\t\t\tREF_1331(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1332(DataTypes.ReserveConfigurationMap) -> REF_1331.reserveConfiguration\n\t\t\tTMP_1025(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getSiloedBorrowing(DataTypes.ReserveConfigurationMap), arguments:['REF_1332'] \n\t\t\tTMP_1026 = UnaryType.BANG TMP_1025 \n\t\t\tREF_1334(string) -> Errors.SILOED_BORROWING_VIOLATION\n\t\t\tTMP_1027(None) = SOLIDITY_CALL require(bool,string)(TMP_1026,REF_1334)\n\t\tExpression: vars.eModePriceSource != address(0)\n\t\tIRs:\n\t\t\tREF_1335(address) -> vars.eModePriceSource\n\t\t\tTMP_1028 = CONVERT 0 to address\n\t\t\tTMP_1029(bool) = REF_1335 != TMP_1028\n\t\t\tCONDITION TMP_1029\n\t\tExpression: vars.amountInBaseCurrency = IPriceOracleGetter(params.oracle).getAssetPrice(vars.eModePriceSource) * params.amount\n\t\tIRs:\n\t\t\tREF_1336(uint256) -> vars.amountInBaseCurrency\n\t\t\tREF_1337(address) -> params.oracle\n\t\t\tTMP_1030 = CONVERT REF_1337 to IPriceOracleGetter\n\t\t\tREF_1339(address) -> vars.eModePriceSource\n\t\t\tTMP_1031(uint256) = HIGH_LEVEL_CALL, dest:TMP_1030(IPriceOracleGetter), function:getAssetPrice, arguments:['REF_1339']  \n\t\t\tREF_1340(uint256) -> params.amount\n\t\t\tTMP_1032(uint256) = TMP_1031 (c)* REF_1340\n\t\t\tREF_1336(uint256) (->vars) := TMP_1032(uint256)\n\t\tExpression: vars.amountInBaseCurrency = IPriceOracleGetter(params.oracle).getAssetPrice(params.asset) * params.amount\n\t\tIRs:\n\t\t\tREF_1341(uint256) -> vars.amountInBaseCurrency\n\t\t\tREF_1342(address) -> params.oracle\n\t\t\tTMP_1033 = CONVERT REF_1342 to IPriceOracleGetter\n\t\t\tREF_1344(address) -> params.asset\n\t\t\tTMP_1034(uint256) = HIGH_LEVEL_CALL, dest:TMP_1033(IPriceOracleGetter), function:getAssetPrice, arguments:['REF_1344']  \n\t\t\tREF_1345(uint256) -> params.amount\n\t\t\tTMP_1035(uint256) = TMP_1034 (c)* REF_1345\n\t\t\tREF_1341(uint256) (->vars) := TMP_1035(uint256)\n\tFunction ValidationLogic.validateRepay(DataTypes.ReserveCache,uint256,DataTypes.InterestRateMode,address,uint256,uint256) (*)\n\t\tExpression: require(bool,string)(amountSent != 0,Errors.INVALID_AMOUNT)\n\t\tIRs:\n\t\t\tTMP_1036(bool) = amountSent != 0\n\t\t\tREF_1346(string) -> Errors.INVALID_AMOUNT\n\t\t\tTMP_1037(None) = SOLIDITY_CALL require(bool,string)(TMP_1036,REF_1346)\n\t\tExpression: require(bool,string)(amountSent != type()(uint256).max || msg.sender == onBehalfOf,Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF)\n\t\tIRs:\n\t\t\tTMP_1039(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tTMP_1040(bool) = amountSent != TMP_1039\n\t\t\tTMP_1041(bool) = msg.sender == onBehalfOf\n\t\t\tTMP_1042(bool) = TMP_1040 || TMP_1041\n\t\t\tREF_1347(string) -> Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n\t\t\tTMP_1043(None) = SOLIDITY_CALL require(bool,string)(TMP_1042,REF_1347)\n\t\tExpression: (isActive,None,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1348(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_33(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1348'] \n\t\t\tisActive(bool)= UNPACK TUPLE_33 index: 0 \n\t\t\tisPaused(bool)= UNPACK TUPLE_33 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1350(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1044(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1350)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1045 = UnaryType.BANG isPaused \n\t\t\tREF_1351(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1046(None) = SOLIDITY_CALL require(bool,string)(TMP_1045,REF_1351)\n\t\tExpression: require(bool,string)((stableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.STABLE) || (variableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.VARIABLE),Errors.NO_DEBT_OF_SELECTED_TYPE)\n\t\tIRs:\n\t\t\tTMP_1047(bool) = stableDebt != 0\n\t\t\tREF_1352(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_1048(bool) = interestRateMode == REF_1352\n\t\t\tTMP_1049(bool) = TMP_1047 && TMP_1048\n\t\t\tTMP_1050(bool) = variableDebt != 0\n\t\t\tREF_1353(DataTypes.InterestRateMode) -> InterestRateMode.VARIABLE\n\t\t\tTMP_1051(bool) = interestRateMode == REF_1353\n\t\t\tTMP_1052(bool) = TMP_1050 && TMP_1051\n\t\t\tTMP_1053(bool) = TMP_1049 || TMP_1052\n\t\t\tREF_1354(string) -> Errors.NO_DEBT_OF_SELECTED_TYPE\n\t\t\tTMP_1054(None) = SOLIDITY_CALL require(bool,string)(TMP_1053,REF_1354)\n\tFunction ValidationLogic.validateSwapRateMode(DataTypes.ReserveData,DataTypes.ReserveCache,DataTypes.UserConfigurationMap,uint256,uint256,DataTypes.InterestRateMode) (*)\n\t\tExpression: (isActive,isFrozen,None,stableRateEnabled,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1355(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_34(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1355'] \n\t\t\tisActive(bool)= UNPACK TUPLE_34 index: 0 \n\t\t\tisFrozen(bool)= UNPACK TUPLE_34 index: 1 \n\t\t\tstableRateEnabled(bool)= UNPACK TUPLE_34 index: 3 \n\t\t\tisPaused(bool)= UNPACK TUPLE_34 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1357(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1055(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1357)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1056 = UnaryType.BANG isPaused \n\t\t\tREF_1358(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1057(None) = SOLIDITY_CALL require(bool,string)(TMP_1056,REF_1358)\n\t\tExpression: require(bool,string)(! isFrozen,Errors.RESERVE_FROZEN)\n\t\tIRs:\n\t\t\tTMP_1058 = UnaryType.BANG isFrozen \n\t\t\tREF_1359(string) -> Errors.RESERVE_FROZEN\n\t\t\tTMP_1059(None) = SOLIDITY_CALL require(bool,string)(TMP_1058,REF_1359)\n\t\tExpression: currentRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_1360(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_1060(bool) = currentRateMode == REF_1360\n\t\t\tCONDITION TMP_1060\n\t\tExpression: require(bool,string)(stableDebt != 0,Errors.NO_OUTSTANDING_STABLE_DEBT)\n\t\tIRs:\n\t\t\tTMP_1061(bool) = stableDebt != 0\n\t\t\tREF_1361(string) -> Errors.NO_OUTSTANDING_STABLE_DEBT\n\t\t\tTMP_1062(None) = SOLIDITY_CALL require(bool,string)(TMP_1061,REF_1361)\n\t\tExpression: currentRateMode == DataTypes.InterestRateMode.VARIABLE\n\t\tIRs:\n\t\t\tREF_1362(DataTypes.InterestRateMode) -> InterestRateMode.VARIABLE\n\t\t\tTMP_1063(bool) = currentRateMode == REF_1362\n\t\t\tCONDITION TMP_1063\n\t\tExpression: require(bool,string)(variableDebt != 0,Errors.NO_OUTSTANDING_VARIABLE_DEBT)\n\t\tIRs:\n\t\t\tTMP_1064(bool) = variableDebt != 0\n\t\t\tREF_1363(string) -> Errors.NO_OUTSTANDING_VARIABLE_DEBT\n\t\t\tTMP_1065(None) = SOLIDITY_CALL require(bool,string)(TMP_1064,REF_1363)\n\t\tExpression: require(bool,string)(stableRateEnabled,Errors.STABLE_BORROWING_NOT_ENABLED)\n\t\tIRs:\n\t\t\tREF_1364(string) -> Errors.STABLE_BORROWING_NOT_ENABLED\n\t\t\tTMP_1066(None) = SOLIDITY_CALL require(bool,string)(stableRateEnabled,REF_1364)\n\t\tExpression: require(bool,string)(! userConfig.isUsingAsCollateral(reserve.id) || reserveCache.reserveConfiguration.getLtv() == 0 || stableDebt + variableDebt > IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender),Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY)\n\t\tIRs:\n\t\t\tREF_1366(uint16) -> reserve.id\n\t\t\tTMP_1067(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'REF_1366'] \n\t\t\tTMP_1068 = UnaryType.BANG TMP_1067 \n\t\t\tREF_1367(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_1069(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap), arguments:['REF_1367'] \n\t\t\tTMP_1070(bool) = TMP_1069 == 0\n\t\t\tTMP_1071(bool) = TMP_1068 || TMP_1070\n\t\t\tTMP_1072(uint256) = stableDebt (c)+ variableDebt\n\t\t\tREF_1369(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_1073 = CONVERT REF_1369 to IERC20\n\t\t\tTMP_1074(uint256) = HIGH_LEVEL_CALL, dest:TMP_1073(IERC20), function:balanceOf, arguments:['msg.sender']  \n\t\t\tTMP_1075(bool) = TMP_1072 > TMP_1074\n\t\t\tTMP_1076(bool) = TMP_1071 || TMP_1075\n\t\t\tREF_1371(string) -> Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n\t\t\tTMP_1077(None) = SOLIDITY_CALL require(bool,string)(TMP_1076,REF_1371)\n\t\tExpression: revert(string)(Errors.INVALID_INTEREST_RATE_MODE_SELECTED)\n\t\tIRs:\n\t\t\tREF_1372(string) -> Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n\t\t\tTMP_1078(None) = SOLIDITY_CALL revert(string)(REF_1372)\n\tFunction ValidationLogic.validateRebalanceStableBorrowRate(DataTypes.ReserveData,DataTypes.ReserveCache,address) (*)\n\t\tExpression: (isActive,None,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1373(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_35(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1373'] \n\t\t\tisActive(bool)= UNPACK TUPLE_35 index: 0 \n\t\t\tisPaused(bool)= UNPACK TUPLE_35 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1375(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1079(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1375)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1080 = UnaryType.BANG isPaused \n\t\t\tREF_1376(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1081(None) = SOLIDITY_CALL require(bool,string)(TMP_1080,REF_1376)\n\t\tExpression: totalDebt = IERC20(reserveCache.stableDebtTokenAddress).totalSupply() + IERC20(reserveCache.variableDebtTokenAddress).totalSupply()\n\t\tIRs:\n\t\t\tREF_1377(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_1082 = CONVERT REF_1377 to IERC20\n\t\t\tTMP_1083(uint256) = HIGH_LEVEL_CALL, dest:TMP_1082(IERC20), function:totalSupply, arguments:[]  \n\t\t\tREF_1379(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_1084 = CONVERT REF_1379 to IERC20\n\t\t\tTMP_1085(uint256) = HIGH_LEVEL_CALL, dest:TMP_1084(IERC20), function:totalSupply, arguments:[]  \n\t\t\tTMP_1086(uint256) = TMP_1083 (c)+ TMP_1085\n\t\t\ttotalDebt(uint256) := TMP_1086(uint256)\n\t\tExpression: (liquidityRateVariableDebtOnly,None,None) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(DataTypes.CalculateInterestRatesParams({unbacked:reserve.unbacked,liquidityAdded:0,liquidityTaken:0,totalStableDebt:0,totalVariableDebt:totalDebt,averageStableBorrowRate:0,reserveFactor:reserveCache.reserveFactor,reserve:reserveAddress,aToken:reserveCache.aTokenAddress}))\n\t\tIRs:\n\t\t\tREF_1381(address) -> reserve.interestRateStrategyAddress\n\t\t\tTMP_1087 = CONVERT REF_1381 to IReserveInterestRateStrategy\n\t\t\tREF_1384(uint128) -> reserve.unbacked\n\t\t\tREF_1385(uint256) -> reserveCache.reserveFactor\n\t\t\tREF_1386(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_1088(DataTypes.CalculateInterestRatesParams) = new CalculateInterestRatesParams(REF_1384,0,0,0,totalDebt,0,REF_1385,reserveAddress,REF_1386)\n\t\t\tTUPLE_36(uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_1087(IReserveInterestRateStrategy), function:calculateInterestRates, arguments:['TMP_1088']  \n\t\t\tliquidityRateVariableDebtOnly(uint256)= UNPACK TUPLE_36 index: 0 \n\t\tExpression: require(bool,string)(reserveCache.currLiquidityRate <= liquidityRateVariableDebtOnly.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET)\n\t\tIRs:\n\t\t\tREF_1387(uint256) -> reserveCache.currLiquidityRate\n\t\t\tTMP_1089(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['liquidityRateVariableDebtOnly', 'REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD'] \n\t\t\tTMP_1090(bool) = REF_1387 <= TMP_1089\n\t\t\tREF_1389(string) -> Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n\t\t\tTMP_1091(None) = SOLIDITY_CALL require(bool,string)(TMP_1090,REF_1389)\n\tFunction ValidationLogic.validateSetUseReserveAsCollateral(DataTypes.ReserveCache,uint256) (*)\n\t\tExpression: require(bool,string)(userBalance != 0,Errors.UNDERLYING_BALANCE_ZERO)\n\t\tIRs:\n\t\t\tTMP_1092(bool) = userBalance != 0\n\t\t\tREF_1390(string) -> Errors.UNDERLYING_BALANCE_ZERO\n\t\t\tTMP_1093(None) = SOLIDITY_CALL require(bool,string)(TMP_1092,REF_1390)\n\t\tExpression: (isActive,None,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1391(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_37(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1391'] \n\t\t\tisActive(bool)= UNPACK TUPLE_37 index: 0 \n\t\t\tisPaused(bool)= UNPACK TUPLE_37 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1393(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1094(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1393)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1095 = UnaryType.BANG isPaused \n\t\t\tREF_1394(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1096(None) = SOLIDITY_CALL require(bool,string)(TMP_1095,REF_1394)\n\tFunction ValidationLogic.validateFlashloan(mapping(address => DataTypes.ReserveData),address[],uint256[]) (*)\n\t\tExpression: require(bool,string)(assets.length == amounts.length,Errors.INCONSISTENT_FLASHLOAN_PARAMS)\n\t\tIRs:\n\t\t\tREF_1395 -> LENGTH assets\n\t\t\tREF_1396 -> LENGTH amounts\n\t\t\tTMP_1097(bool) = REF_1395 == REF_1396\n\t\t\tREF_1397(string) -> Errors.INCONSISTENT_FLASHLOAN_PARAMS\n\t\t\tTMP_1098(None) = SOLIDITY_CALL require(bool,string)(TMP_1097,REF_1397)\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint256) := 0(uint256)\n\t\tExpression: i < assets.length\n\t\tIRs:\n\t\t\tREF_1398 -> LENGTH assets\n\t\t\tTMP_1099(bool) = i < REF_1398\n\t\t\tCONDITION TMP_1099\n\t\tExpression: validateFlashloanSimple(reservesData[assets[i]])\n\t\tIRs:\n\t\t\tREF_1399(address) -> assets[i]\n\t\t\tREF_1400(DataTypes.ReserveData) -> reservesData[REF_1399]\n\t\t\tINTERNAL_CALL, ValidationLogic.validateFlashloanSimple(DataTypes.ReserveData)(REF_1400)\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_1101(uint256) := i(uint256)\n\t\t\ti(uint256) = i (c)+ 1\n\tFunction ValidationLogic.validateFlashloanSimple(DataTypes.ReserveData) (*)\n\t\tExpression: configuration = reserve.configuration\n\t\tIRs:\n\t\t\tREF_1401(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tconfiguration(DataTypes.ReserveConfigurationMap) := REF_1401(DataTypes.ReserveConfigurationMap)\n\t\tExpression: require(bool,string)(! configuration.getPaused(),Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1102(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getPaused(DataTypes.ReserveConfigurationMap), arguments:['configuration'] \n\t\t\tTMP_1103 = UnaryType.BANG TMP_1102 \n\t\t\tREF_1403(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1104(None) = SOLIDITY_CALL require(bool,string)(TMP_1103,REF_1403)\n\t\tExpression: require(bool,string)(configuration.getActive(),Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tTMP_1105(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getActive(DataTypes.ReserveConfigurationMap), arguments:['configuration'] \n\t\t\tREF_1405(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1106(None) = SOLIDITY_CALL require(bool,string)(TMP_1105,REF_1405)\n\t\tExpression: require(bool,string)(configuration.getFlashLoanEnabled(),Errors.FLASHLOAN_DISABLED)\n\t\tIRs:\n\t\t\tTMP_1107(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlashLoanEnabled(DataTypes.ReserveConfigurationMap), arguments:['configuration'] \n\t\t\tREF_1407(string) -> Errors.FLASHLOAN_DISABLED\n\t\t\tTMP_1108(None) = SOLIDITY_CALL require(bool,string)(TMP_1107,REF_1407)\n\tFunction ValidationLogic.validateLiquidationCall(DataTypes.UserConfigurationMap,DataTypes.ReserveData,DataTypes.ValidateLiquidationCallParams) (*)\n\t\tExpression: (vars.collateralReserveActive,None,None,None,vars.collateralReservePaused) = collateralReserve.configuration.getFlags()\n\t\tIRs:\n\t\t\tREF_1408(bool) -> vars.collateralReserveActive\n\t\t\tREF_1409(bool) -> vars.collateralReservePaused\n\t\t\tREF_1410(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTUPLE_38(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1410'] \n\t\t\tREF_1408(bool)= UNPACK TUPLE_38 index: 0 \n\t\t\tREF_1409(bool)= UNPACK TUPLE_38 index: 4 \n\t\tExpression: (vars.principalReserveActive,None,None,None,vars.principalReservePaused) = params.debtReserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1412(bool) -> vars.principalReserveActive\n\t\t\tREF_1413(bool) -> vars.principalReservePaused\n\t\t\tREF_1414(DataTypes.ReserveCache) -> params.debtReserveCache\n\t\t\tREF_1415(DataTypes.ReserveConfigurationMap) -> REF_1414.reserveConfiguration\n\t\t\tTUPLE_39(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1415'] \n\t\t\tREF_1412(bool)= UNPACK TUPLE_39 index: 0 \n\t\t\tREF_1413(bool)= UNPACK TUPLE_39 index: 4 \n\t\tExpression: require(bool,string)(vars.collateralReserveActive && vars.principalReserveActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1417(bool) -> vars.collateralReserveActive\n\t\t\tREF_1418(bool) -> vars.principalReserveActive\n\t\t\tTMP_1109(bool) = REF_1417 && REF_1418\n\t\t\tREF_1419(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1110(None) = SOLIDITY_CALL require(bool,string)(TMP_1109,REF_1419)\n\t\tExpression: require(bool,string)(! vars.collateralReservePaused && ! vars.principalReservePaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tREF_1420(bool) -> vars.collateralReservePaused\n\t\t\tTMP_1111 = UnaryType.BANG REF_1420 \n\t\t\tREF_1421(bool) -> vars.principalReservePaused\n\t\t\tTMP_1112 = UnaryType.BANG REF_1421 \n\t\t\tTMP_1113(bool) = TMP_1111 && TMP_1112\n\t\t\tREF_1422(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1114(None) = SOLIDITY_CALL require(bool,string)(TMP_1113,REF_1422)\n\t\tExpression: require(bool,string)(params.priceOracleSentinel == address(0) || params.healthFactor < MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD || IPriceOracleSentinel(params.priceOracleSentinel).isLiquidationAllowed(),Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED)\n\t\tIRs:\n\t\t\tREF_1423(address) -> params.priceOracleSentinel\n\t\t\tTMP_1115 = CONVERT 0 to address\n\t\t\tTMP_1116(bool) = REF_1423 == TMP_1115\n\t\t\tREF_1424(uint256) -> params.healthFactor\n\t\t\tTMP_1117(bool) = REF_1424 < MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n\t\t\tTMP_1118(bool) = TMP_1116 || TMP_1117\n\t\t\tREF_1425(address) -> params.priceOracleSentinel\n\t\t\tTMP_1119 = CONVERT REF_1425 to IPriceOracleSentinel\n\t\t\tTMP_1120(bool) = HIGH_LEVEL_CALL, dest:TMP_1119(IPriceOracleSentinel), function:isLiquidationAllowed, arguments:[]  \n\t\t\tTMP_1121(bool) = TMP_1118 || TMP_1120\n\t\t\tREF_1427(string) -> Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n\t\t\tTMP_1122(None) = SOLIDITY_CALL require(bool,string)(TMP_1121,REF_1427)\n\t\tExpression: require(bool,string)(params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD,Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD)\n\t\tIRs:\n\t\t\tREF_1428(uint256) -> params.healthFactor\n\t\t\tTMP_1123(bool) = REF_1428 < HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n\t\t\tREF_1429(string) -> Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n\t\t\tTMP_1124(None) = SOLIDITY_CALL require(bool,string)(TMP_1123,REF_1429)\n\t\tExpression: vars.isCollateralEnabled = collateralReserve.configuration.getLiquidationThreshold() != 0 && userConfig.isUsingAsCollateral(collateralReserve.id)\n\t\tIRs:\n\t\t\tREF_1430(bool) -> vars.isCollateralEnabled\n\t\t\tREF_1431(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_1125(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLiquidationThreshold(DataTypes.ReserveConfigurationMap), arguments:['REF_1431'] \n\t\t\tTMP_1126(bool) = TMP_1125 != 0\n\t\t\tREF_1434(uint16) -> collateralReserve.id\n\t\t\tTMP_1127(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'REF_1434'] \n\t\t\tTMP_1128(bool) = TMP_1126 && TMP_1127\n\t\t\tREF_1430(bool) (->vars) := TMP_1128(bool)\n\t\tExpression: require(bool,string)(vars.isCollateralEnabled,Errors.COLLATERAL_CANNOT_BE_LIQUIDATED)\n\t\tIRs:\n\t\t\tREF_1435(bool) -> vars.isCollateralEnabled\n\t\t\tREF_1436(string) -> Errors.COLLATERAL_CANNOT_BE_LIQUIDATED\n\t\t\tTMP_1129(None) = SOLIDITY_CALL require(bool,string)(REF_1435,REF_1436)\n\t\tExpression: require(bool,string)(params.totalDebt != 0,Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER)\n\t\tIRs:\n\t\t\tREF_1437(uint256) -> params.totalDebt\n\t\t\tTMP_1130(bool) = REF_1437 != 0\n\t\t\tREF_1438(string) -> Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n\t\t\tTMP_1131(None) = SOLIDITY_CALL require(bool,string)(TMP_1130,REF_1438)\n\tFunction ValidationLogic.validateHealthFactor(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,uint8,uint256,address) (*)\n\t\tExpression: (None,None,None,None,healthFactor,hasZeroLtvCollateral) = GenericLogic.calculateUserAccountData(reservesData,reservesList,eModeCategories,DataTypes.CalculateUserAccountDataParams({userConfig:userConfig,reservesCount:reservesCount,user:user,oracle:oracle,userEModeCategory:userEModeCategory}))\n\t\tIRs:\n\t\t\tTMP_1132(DataTypes.CalculateUserAccountDataParams) = new CalculateUserAccountDataParams(userConfig,reservesCount,user,oracle,userEModeCategory)\n\t\t\tTUPLE_40(uint256,uint256,uint256,uint256,uint256,bool) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'TMP_1132'] \n\t\t\thealthFactor(uint256)= UNPACK TUPLE_40 index: 4 \n\t\t\thasZeroLtvCollateral(bool)= UNPACK TUPLE_40 index: 5 \n\t\tExpression: require(bool,string)(healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD,Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD)\n\t\tIRs:\n\t\t\tTMP_1133(bool) = healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n\t\t\tREF_1441(string) -> Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n\t\t\tTMP_1134(None) = SOLIDITY_CALL require(bool,string)(TMP_1133,REF_1441)\n\t\tExpression: (healthFactor,hasZeroLtvCollateral)\n\t\tIRs:\n\t\t\tRETURN healthFactor,hasZeroLtvCollateral\n\tFunction ValidationLogic.validateHFAndLtv(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,address,uint256,address,uint8) (*)\n\t\tExpression: reserve = reservesData[asset]\n\t\tIRs:\n\t\t\tREF_1442(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treserve(DataTypes.ReserveData) := REF_1442(DataTypes.ReserveData)\n\t\tExpression: (None,hasZeroLtvCollateral) = validateHealthFactor(reservesData,reservesList,eModeCategories,userConfig,from,userEModeCategory,reservesCount,oracle)\n\t\tIRs:\n\t\t\tTUPLE_41(uint256,bool) = INTERNAL_CALL, ValidationLogic.validateHealthFactor(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,uint8,uint256,address)(reservesData,reservesList,eModeCategories,userConfig,from,userEModeCategory,reservesCount,oracle)\n\t\t\thasZeroLtvCollateral(bool)= UNPACK TUPLE_41 index: 1 \n\t\tExpression: require(bool,string)(! hasZeroLtvCollateral || reserve.configuration.getLtv() == 0,Errors.LTV_VALIDATION_FAILED)\n\t\tIRs:\n\t\t\tTMP_1135 = UnaryType.BANG hasZeroLtvCollateral \n\t\t\tREF_1443(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tTMP_1136(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap), arguments:['REF_1443'] \n\t\t\tTMP_1137(bool) = TMP_1136 == 0\n\t\t\tTMP_1138(bool) = TMP_1135 || TMP_1137\n\t\t\tREF_1445(string) -> Errors.LTV_VALIDATION_FAILED\n\t\t\tTMP_1139(None) = SOLIDITY_CALL require(bool,string)(TMP_1138,REF_1445)\n\tFunction ValidationLogic.validateTransfer(DataTypes.ReserveData) (*)\n\t\tExpression: require(bool,string)(! reserve.configuration.getPaused(),Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tREF_1446(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tTMP_1140(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getPaused(DataTypes.ReserveConfigurationMap), arguments:['REF_1446'] \n\t\t\tTMP_1141 = UnaryType.BANG TMP_1140 \n\t\t\tREF_1448(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1142(None) = SOLIDITY_CALL require(bool,string)(TMP_1141,REF_1448)\n\tFunction ValidationLogic.validateDropReserve(mapping(uint256 => address),DataTypes.ReserveData,address) (*)\n\t\tExpression: require(bool,string)(asset != address(0),Errors.ZERO_ADDRESS_NOT_VALID)\n\t\tIRs:\n\t\t\tTMP_1143 = CONVERT 0 to address\n\t\t\tTMP_1144(bool) = asset != TMP_1143\n\t\t\tREF_1449(string) -> Errors.ZERO_ADDRESS_NOT_VALID\n\t\t\tTMP_1145(None) = SOLIDITY_CALL require(bool,string)(TMP_1144,REF_1449)\n\t\tExpression: require(bool,string)(reserve.id != 0 || reservesList[0] == asset,Errors.ASSET_NOT_LISTED)\n\t\tIRs:\n\t\t\tREF_1450(uint16) -> reserve.id\n\t\t\tTMP_1146(bool) = REF_1450 != 0\n\t\t\tREF_1451(address) -> reservesList[0]\n\t\t\tTMP_1147(bool) = REF_1451 == asset\n\t\t\tTMP_1148(bool) = TMP_1146 || TMP_1147\n\t\t\tREF_1452(string) -> Errors.ASSET_NOT_LISTED\n\t\t\tTMP_1149(None) = SOLIDITY_CALL require(bool,string)(TMP_1148,REF_1452)\n\t\tExpression: require(bool,string)(IERC20(reserve.stableDebtTokenAddress).totalSupply() == 0,Errors.STABLE_DEBT_NOT_ZERO)\n\t\tIRs:\n\t\t\tREF_1453(address) -> reserve.stableDebtTokenAddress\n\t\t\tTMP_1150 = CONVERT REF_1453 to IERC20\n\t\t\tTMP_1151(uint256) = HIGH_LEVEL_CALL, dest:TMP_1150(IERC20), function:totalSupply, arguments:[]  \n\t\t\tTMP_1152(bool) = TMP_1151 == 0\n\t\t\tREF_1455(string) -> Errors.STABLE_DEBT_NOT_ZERO\n\t\t\tTMP_1153(None) = SOLIDITY_CALL require(bool,string)(TMP_1152,REF_1455)\n\t\tExpression: require(bool,string)(IERC20(reserve.variableDebtTokenAddress).totalSupply() == 0,Errors.VARIABLE_DEBT_SUPPLY_NOT_ZERO)\n\t\tIRs:\n\t\t\tREF_1456(address) -> reserve.variableDebtTokenAddress\n\t\t\tTMP_1154 = CONVERT REF_1456 to IERC20\n\t\t\tTMP_1155(uint256) = HIGH_LEVEL_CALL, dest:TMP_1154(IERC20), function:totalSupply, arguments:[]  \n\t\t\tTMP_1156(bool) = TMP_1155 == 0\n\t\t\tREF_1458(string) -> Errors.VARIABLE_DEBT_SUPPLY_NOT_ZERO\n\t\t\tTMP_1157(None) = SOLIDITY_CALL require(bool,string)(TMP_1156,REF_1458)\n\t\tExpression: require(bool,string)(IERC20(reserve.aTokenAddress).totalSupply() == 0 && reserve.accruedToTreasury == 0,Errors.UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO)\n\t\tIRs:\n\t\t\tREF_1459(address) -> reserve.aTokenAddress\n\t\t\tTMP_1158 = CONVERT REF_1459 to IERC20\n\t\t\tTMP_1159(uint256) = HIGH_LEVEL_CALL, dest:TMP_1158(IERC20), function:totalSupply, arguments:[]  \n\t\t\tTMP_1160(bool) = TMP_1159 == 0\n\t\t\tREF_1461(uint128) -> reserve.accruedToTreasury\n\t\t\tTMP_1161(bool) = REF_1461 == 0\n\t\t\tTMP_1162(bool) = TMP_1160 && TMP_1161\n\t\t\tREF_1462(string) -> Errors.UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO\n\t\t\tTMP_1163(None) = SOLIDITY_CALL require(bool,string)(TMP_1162,REF_1462)\n\tFunction ValidationLogic.validateSetUserEMode(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,uint256,uint8) (*)\n\t\tExpression: require(bool,string)(categoryId == 0 || eModeCategories[categoryId].liquidationThreshold != 0,Errors.INCONSISTENT_EMODE_CATEGORY)\n\t\tIRs:\n\t\t\tTMP_1164(bool) = categoryId == 0\n\t\t\tREF_1463(DataTypes.EModeCategory) -> eModeCategories[categoryId]\n\t\t\tREF_1464(uint16) -> REF_1463.liquidationThreshold\n\t\t\tTMP_1165(bool) = REF_1464 != 0\n\t\t\tTMP_1166(bool) = TMP_1164 || TMP_1165\n\t\t\tREF_1465(string) -> Errors.INCONSISTENT_EMODE_CATEGORY\n\t\t\tTMP_1167(None) = SOLIDITY_CALL require(bool,string)(TMP_1166,REF_1465)\n\t\tExpression: userConfig.isEmpty()\n\t\tIRs:\n\t\t\tTMP_1168(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isEmpty(DataTypes.UserConfigurationMap), arguments:['userConfig'] \n\t\t\tCONDITION TMP_1168\n\t\tExpression: categoryId != 0\n\t\tIRs:\n\t\t\tTMP_1169(bool) = categoryId != 0\n\t\t\tCONDITION TMP_1169\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint256) := 0(uint256)\n\t\tExpression: i < reservesCount\n\t\tIRs:\n\t\t\tTMP_1170(bool) = i < reservesCount\n\t\t\tCONDITION TMP_1170\n\t\tExpression: userConfig.isBorrowing(i)\n\t\tIRs:\n\t\t\tTMP_1171(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowing(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'i'] \n\t\t\tCONDITION TMP_1171\n\t\tExpression: configuration = reservesData[reservesList[i]].configuration\n\t\tIRs:\n\t\t\tREF_1468(address) -> reservesList[i]\n\t\t\tREF_1469(DataTypes.ReserveData) -> reservesData[REF_1468]\n\t\t\tREF_1470(DataTypes.ReserveConfigurationMap) -> REF_1469.configuration\n\t\t\tconfiguration(DataTypes.ReserveConfigurationMap) := REF_1470(DataTypes.ReserveConfigurationMap)\n\t\tExpression: require(bool,string)(configuration.getEModeCategory() == categoryId,Errors.INCONSISTENT_EMODE_CATEGORY)\n\t\tIRs:\n\t\t\tTMP_1172(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getEModeCategory(DataTypes.ReserveConfigurationMap), arguments:['configuration'] \n\t\t\tTMP_1173(bool) = TMP_1172 == categoryId\n\t\t\tREF_1472(string) -> Errors.INCONSISTENT_EMODE_CATEGORY\n\t\t\tTMP_1174(None) = SOLIDITY_CALL require(bool,string)(TMP_1173,REF_1472)\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_1175(uint256) := i(uint256)\n\t\t\ti(uint256) = i + 1\n\tFunction ValidationLogic.validateUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: reserveConfig.getLtv() == 0\n\t\tIRs:\n\t\t\tTMP_1176(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap), arguments:['reserveConfig'] \n\t\t\tTMP_1177(bool) = TMP_1176 == 0\n\t\t\tCONDITION TMP_1177\n\t\tExpression: false\n\t\tIRs:\n\t\t\tRETURN False\n\t\tExpression: ! userConfig.isUsingAsCollateralAny()\n\t\tIRs:\n\t\t\tTMP_1178(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateralAny(DataTypes.UserConfigurationMap), arguments:['userConfig'] \n\t\t\tTMP_1179 = UnaryType.BANG TMP_1178 \n\t\t\tCONDITION TMP_1179\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\t\tExpression: (isolationModeActive,None,None) = userConfig.getIsolationModeState(reservesData,reservesList)\n\t\tIRs:\n\t\t\tTUPLE_42(bool,address,uint256) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.getIsolationModeState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)), arguments:['userConfig', 'reservesData', 'reservesList'] \n\t\t\tisolationModeActive(bool)= UNPACK TUPLE_42 index: 0 \n\t\tExpression: (! isolationModeActive && reserveConfig.getDebtCeiling() == 0)\n\t\tIRs:\n\t\t\tTMP_1180 = UnaryType.BANG isolationModeActive \n\t\t\tTMP_1181(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap), arguments:['reserveConfig'] \n\t\t\tTMP_1182(bool) = TMP_1181 == 0\n\t\t\tTMP_1183(bool) = TMP_1180 && TMP_1182\n\t\t\tRETURN TMP_1183\n\tFunction ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address) (*)\n\t\tExpression: reserveConfig.getDebtCeiling() != 0\n\t\tIRs:\n\t\t\tTMP_1184(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap), arguments:['reserveConfig'] \n\t\t\tTMP_1185(bool) = TMP_1184 != 0\n\t\t\tCONDITION TMP_1185\n\t\tExpression: addressesProvider = IncentivizedERC20(aTokenAddress).POOL().ADDRESSES_PROVIDER()\n\t\tIRs:\n\t\t\tTMP_1186 = CONVERT aTokenAddress to IncentivizedERC20\n\t\t\tTMP_1187(IPool) = HIGH_LEVEL_CALL, dest:TMP_1186(IncentivizedERC20), function:POOL, arguments:[]  \n\t\t\tTMP_1188(IPoolAddressesProvider) = HIGH_LEVEL_CALL, dest:TMP_1187(IPool), function:ADDRESSES_PROVIDER, arguments:[]  \n\t\t\taddressesProvider(IPoolAddressesProvider) := TMP_1188(IPoolAddressesProvider)\n\t\tExpression: ! IAccessControl(addressesProvider.getACLManager()).hasRole(ISOLATED_COLLATERAL_SUPPLIER_ROLE,msg.sender)\n\t\tIRs:\n\t\t\tTMP_1189(address) = HIGH_LEVEL_CALL, dest:addressesProvider(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1190 = CONVERT TMP_1189 to IAccessControl\n\t\t\tTMP_1191(bool) = HIGH_LEVEL_CALL, dest:TMP_1190(IAccessControl), function:hasRole, arguments:['ISOLATED_COLLATERAL_SUPPLIER_ROLE', 'msg.sender']  \n\t\t\tTMP_1192 = UnaryType.BANG TMP_1191 \n\t\t\tCONDITION TMP_1192\n\t\tExpression: false\n\t\tIRs:\n\t\t\tRETURN False\n\t\tExpression: validateUseAsCollateral(reservesData,reservesList,userConfig,reserveConfig)\n\t\tIRs:\n\t\t\tTMP_1193(bool) = INTERNAL_CALL, ValidationLogic.validateUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap)(reservesData,reservesList,userConfig,reserveConfig)\n\t\t\tRETURN TMP_1193\n\tFunction ValidationLogic.slitherConstructorConstantVariables() (*)\n\t\tExpression: REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 0.9e4\n\t\tIRs:\n\t\t\tREBALANCE_UP_LIQUIDITY_RATE_THRESHOLD(uint256) := 9000(uint256)\n\t\tExpression: MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 0.95e18\n\t\tIRs:\n\t\t\tMINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD(uint256) := 950000000000000000(uint256)\n\t\tExpression: HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18\n\t\tIRs:\n\t\t\tHEALTH_FACTOR_LIQUIDATION_THRESHOLD(uint256) := 1000000000000000000(uint256)\n\t\tExpression: ISOLATED_COLLATERAL_SUPPLIER_ROLE = keccak256(bytes)(ISOLATED_COLLATERAL_SUPPLIER)\n\t\tIRs:\n\t\t\tTMP_1194(bytes32) = SOLIDITY_CALL keccak256(bytes)(ISOLATED_COLLATERAL_SUPPLIER)\n\t\t\tISOLATED_COLLATERAL_SUPPLIER_ROLE(bytes32) := TMP_1194(bytes32)\nContract MathUtils\n\tFunction MathUtils.calculateLinearInterest(uint256,uint40) (*)\n\t\tExpression: result = rate * (block.timestamp - uint256(lastUpdateTimestamp))\n\t\tIRs:\n\t\t\tTMP_1195 = CONVERT lastUpdateTimestamp to uint256\n\t\t\tTMP_1196(uint256) = block.timestamp (c)- TMP_1195\n\t\t\tTMP_1197(uint256) = rate (c)* TMP_1196\n\t\t\tresult(uint256) := TMP_1197(uint256)\n\t\tExpression: result = result / SECONDS_PER_YEAR\n\t\tIRs:\n\t\t\tTMP_1198(uint256) = result / SECONDS_PER_YEAR\n\t\t\tresult(uint256) := TMP_1198(uint256)\n\t\tExpression: WadRayMath.RAY + result\n\t\tIRs:\n\t\t\tREF_1482(uint256) -> WadRayMath.RAY\n\t\t\tTMP_1199(uint256) = REF_1482 (c)+ result\n\t\t\tRETURN TMP_1199\n\tFunction MathUtils.calculateCompoundedInterest(uint256,uint40,uint256) (*)\n\t\tExpression: exp = currentTimestamp - uint256(lastUpdateTimestamp)\n\t\tIRs:\n\t\t\tTMP_1200 = CONVERT lastUpdateTimestamp to uint256\n\t\t\tTMP_1201(uint256) = currentTimestamp (c)- TMP_1200\n\t\t\texp(uint256) := TMP_1201(uint256)\n\t\tExpression: exp == 0\n\t\tIRs:\n\t\t\tTMP_1202(bool) = exp == 0\n\t\t\tCONDITION TMP_1202\n\t\tExpression: WadRayMath.RAY\n\t\tIRs:\n\t\t\tREF_1483(uint256) -> WadRayMath.RAY\n\t\t\tRETURN REF_1483\n\t\tExpression: expMinusOne = exp - 1\n\t\tIRs:\n\t\t\tTMP_1203(uint256) = exp - 1\n\t\t\texpMinusOne(uint256) := TMP_1203(uint256)\n\t\tExpression: basePowerTwo = rate.rayMul(rate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR)\n\t\tIRs:\n\t\t\tTMP_1204(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['rate', 'rate'] \n\t\t\tTMP_1205(uint256) = SECONDS_PER_YEAR * SECONDS_PER_YEAR\n\t\t\tTMP_1206(uint256) = TMP_1204 / TMP_1205\n\t\t\tbasePowerTwo(uint256) := TMP_1206(uint256)\n\t\tExpression: basePowerThree = basePowerTwo.rayMul(rate) / SECONDS_PER_YEAR\n\t\tIRs:\n\t\t\tTMP_1207(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['basePowerTwo', 'rate'] \n\t\t\tTMP_1208(uint256) = TMP_1207 / SECONDS_PER_YEAR\n\t\t\tbasePowerThree(uint256) := TMP_1208(uint256)\n\t\tExpression: secondTerm = exp * expMinusOne * basePowerTwo\n\t\tIRs:\n\t\t\tTMP_1209(uint256) = exp (c)* expMinusOne\n\t\t\tTMP_1210(uint256) = TMP_1209 (c)* basePowerTwo\n\t\t\tsecondTerm(uint256) := TMP_1210(uint256)\n\t\tExpression: secondTerm /= 2\n\t\tIRs:\n\t\t\tsecondTerm(uint256) = secondTerm / 2\n\t\tExpression: thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree\n\t\tIRs:\n\t\t\tTMP_1211(uint256) = exp (c)* expMinusOne\n\t\t\tTMP_1212(uint256) = TMP_1211 (c)* expMinusTwo\n\t\t\tTMP_1213(uint256) = TMP_1212 (c)* basePowerThree\n\t\t\tthirdTerm(uint256) := TMP_1213(uint256)\n\t\tExpression: thirdTerm /= 6\n\t\tIRs:\n\t\t\tthirdTerm(uint256) = thirdTerm / 6\n\t\tExpression: WadRayMath.RAY + (rate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm\n\t\tIRs:\n\t\t\tREF_1486(uint256) -> WadRayMath.RAY\n\t\t\tTMP_1214(uint256) = rate (c)* exp\n\t\t\tTMP_1215(uint256) = TMP_1214 (c)/ SECONDS_PER_YEAR\n\t\t\tTMP_1216(uint256) = REF_1486 (c)+ TMP_1215\n\t\t\tTMP_1217(uint256) = TMP_1216 (c)+ secondTerm\n\t\t\tTMP_1218(uint256) = TMP_1217 (c)+ thirdTerm\n\t\t\tRETURN TMP_1218\n\t\tExpression: exp > 2\n\t\tIRs:\n\t\t\tTMP_1219(bool) = exp > 2\n\t\t\tCONDITION TMP_1219\n\t\tExpression: expMinusTwo = exp - 2\n\t\tIRs:\n\t\t\tTMP_1220(uint256) = exp - 2\n\t\t\texpMinusTwo(uint256) := TMP_1220(uint256)\n\t\tExpression: expMinusTwo = 0\n\t\tIRs:\n\t\t\texpMinusTwo(uint256) := 0(uint256)\n\tFunction MathUtils.calculateCompoundedInterest(uint256,uint40) (*)\n\t\tExpression: calculateCompoundedInterest(rate,lastUpdateTimestamp,block.timestamp)\n\t\tIRs:\n\t\t\tTMP_1221(uint256) = INTERNAL_CALL, MathUtils.calculateCompoundedInterest(uint256,uint40,uint256)(rate,lastUpdateTimestamp,block.timestamp)\n\t\t\tRETURN TMP_1221\n\tFunction MathUtils.slitherConstructorConstantVariables() (*)\n\t\tExpression: SECONDS_PER_YEAR = 31536000\n\t\tIRs:\n\t\t\tSECONDS_PER_YEAR(uint256) := 31536000(uint256)\nContract PercentageMath\n\tFunction PercentageMath.percentMul(uint256,uint256) (*)\n\t\tExpression: ! ! percentage | ! value > ~ 0 - HALF_PERCENTAGE_FACTOR / percentage\n\t\tIRs:\n\t\t\tTMP_1222 = UnaryType.BANG percentage \n\t\t\tTMP_1223 = UnaryType.TILD 0 \n\t\t\tTMP_1224(uint256) = TMP_1223 - HALF_PERCENTAGE_FACTOR\n\t\t\tTMP_1225(uint256) = TMP_1224 / percentage\n\t\t\tTMP_1226(bool) = value > TMP_1225\n\t\t\tTMP_1227 = UnaryType.BANG TMP_1226 \n\t\t\tTMP_1228(uint256) = TMP_1222 | TMP_1227\n\t\t\tTMP_1229 = UnaryType.BANG TMP_1228 \n\t\t\tCONDITION TMP_1229\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1230(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: result = value * percentage + HALF_PERCENTAGE_FACTOR / PERCENTAGE_FACTOR\n\t\tIRs:\n\t\t\tTMP_1231(uint256) = value * percentage\n\t\t\tTMP_1232(uint256) = TMP_1231 + HALF_PERCENTAGE_FACTOR\n\t\t\tTMP_1233(uint256) = TMP_1232 / PERCENTAGE_FACTOR\n\t\t\tresult(uint256) := TMP_1233(uint256)\n\t\tExpression: result\n\t\tIRs:\n\t\t\tRETURN result\n\tFunction PercentageMath.percentDiv(uint256,uint256) (*)\n\t\tExpression: ! percentage | ! ! value > ~ 0 - percentage / 2 / PERCENTAGE_FACTOR\n\t\tIRs:\n\t\t\tTMP_1234 = UnaryType.BANG percentage \n\t\t\tTMP_1235 = UnaryType.TILD 0 \n\t\t\tTMP_1236(uint256) = percentage / 2\n\t\t\tTMP_1237(uint256) = TMP_1235 - TMP_1236\n\t\t\tTMP_1238(uint256) = TMP_1237 / PERCENTAGE_FACTOR\n\t\t\tTMP_1239(bool) = value > TMP_1238\n\t\t\tTMP_1240 = UnaryType.BANG TMP_1239 \n\t\t\tTMP_1241 = UnaryType.BANG TMP_1240 \n\t\t\tTMP_1242(uint256) = TMP_1234 | TMP_1241\n\t\t\tCONDITION TMP_1242\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1243(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: result = value * PERCENTAGE_FACTOR + percentage / 2 / percentage\n\t\tIRs:\n\t\t\tTMP_1244(uint256) = value * PERCENTAGE_FACTOR\n\t\t\tTMP_1245(uint256) = percentage / 2\n\t\t\tTMP_1246(uint256) = TMP_1244 + TMP_1245\n\t\t\tTMP_1247(uint256) = TMP_1246 / percentage\n\t\t\tresult(uint256) := TMP_1247(uint256)\n\t\tExpression: result\n\t\tIRs:\n\t\t\tRETURN result\n\tFunction PercentageMath.slitherConstructorConstantVariables() (*)\n\t\tExpression: PERCENTAGE_FACTOR = 1e4\n\t\tIRs:\n\t\t\tPERCENTAGE_FACTOR(uint256) := 10000(uint256)\n\t\tExpression: HALF_PERCENTAGE_FACTOR = 0.5e4\n\t\tIRs:\n\t\t\tHALF_PERCENTAGE_FACTOR(uint256) := 5000(uint256)\nContract WadRayMath\n\tFunction WadRayMath.wadMul(uint256,uint256) (*)\n\t\tExpression: ! ! b | ! a > ~ 0 - HALF_WAD / b\n\t\tIRs:\n\t\t\tTMP_1248 = UnaryType.BANG b \n\t\t\tTMP_1249 = UnaryType.TILD 0 \n\t\t\tTMP_1250(uint256) = TMP_1249 - HALF_WAD\n\t\t\tTMP_1251(uint256) = TMP_1250 / b\n\t\t\tTMP_1252(bool) = a > TMP_1251\n\t\t\tTMP_1253 = UnaryType.BANG TMP_1252 \n\t\t\tTMP_1254(uint256) = TMP_1248 | TMP_1253\n\t\t\tTMP_1255 = UnaryType.BANG TMP_1254 \n\t\t\tCONDITION TMP_1255\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1256(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: c = a * b + HALF_WAD / WAD\n\t\tIRs:\n\t\t\tTMP_1257(uint256) = a * b\n\t\t\tTMP_1258(uint256) = TMP_1257 + HALF_WAD\n\t\t\tTMP_1259(uint256) = TMP_1258 / WAD\n\t\t\tc(uint256) := TMP_1259(uint256)\n\t\tExpression: c\n\t\tIRs:\n\t\t\tRETURN c\n\tFunction WadRayMath.wadDiv(uint256,uint256) (*)\n\t\tExpression: ! b | ! ! a > ~ 0 - b / 2 / WAD\n\t\tIRs:\n\t\t\tTMP_1260 = UnaryType.BANG b \n\t\t\tTMP_1261 = UnaryType.TILD 0 \n\t\t\tTMP_1262(uint256) = b / 2\n\t\t\tTMP_1263(uint256) = TMP_1261 - TMP_1262\n\t\t\tTMP_1264(uint256) = TMP_1263 / WAD\n\t\t\tTMP_1265(bool) = a > TMP_1264\n\t\t\tTMP_1266 = UnaryType.BANG TMP_1265 \n\t\t\tTMP_1267 = UnaryType.BANG TMP_1266 \n\t\t\tTMP_1268(uint256) = TMP_1260 | TMP_1267\n\t\t\tCONDITION TMP_1268\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1269(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: c = a * WAD + b / 2 / b\n\t\tIRs:\n\t\t\tTMP_1270(uint256) = a * WAD\n\t\t\tTMP_1271(uint256) = b / 2\n\t\t\tTMP_1272(uint256) = TMP_1270 + TMP_1271\n\t\t\tTMP_1273(uint256) = TMP_1272 / b\n\t\t\tc(uint256) := TMP_1273(uint256)\n\t\tExpression: c\n\t\tIRs:\n\t\t\tRETURN c\n\tFunction WadRayMath.rayMul(uint256,uint256) (*)\n\t\tExpression: ! ! b | ! a > ~ 0 - HALF_RAY / b\n\t\tIRs:\n\t\t\tTMP_1274 = UnaryType.BANG b \n\t\t\tTMP_1275 = UnaryType.TILD 0 \n\t\t\tTMP_1276(uint256) = TMP_1275 - HALF_RAY\n\t\t\tTMP_1277(uint256) = TMP_1276 / b\n\t\t\tTMP_1278(bool) = a > TMP_1277\n\t\t\tTMP_1279 = UnaryType.BANG TMP_1278 \n\t\t\tTMP_1280(uint256) = TMP_1274 | TMP_1279\n\t\t\tTMP_1281 = UnaryType.BANG TMP_1280 \n\t\t\tCONDITION TMP_1281\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1282(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: c = a * b + HALF_RAY / RAY\n\t\tIRs:\n\t\t\tTMP_1283(uint256) = a * b\n\t\t\tTMP_1284(uint256) = TMP_1283 + HALF_RAY\n\t\t\tTMP_1285(uint256) = TMP_1284 / RAY\n\t\t\tc(uint256) := TMP_1285(uint256)\n\t\tExpression: c\n\t\tIRs:\n\t\t\tRETURN c\n\tFunction WadRayMath.rayDiv(uint256,uint256) (*)\n\t\tExpression: ! b | ! ! a > ~ 0 - b / 2 / RAY\n\t\tIRs:\n\t\t\tTMP_1286 = UnaryType.BANG b \n\t\t\tTMP_1287 = UnaryType.TILD 0 \n\t\t\tTMP_1288(uint256) = b / 2\n\t\t\tTMP_1289(uint256) = TMP_1287 - TMP_1288\n\t\t\tTMP_1290(uint256) = TMP_1289 / RAY\n\t\t\tTMP_1291(bool) = a > TMP_1290\n\t\t\tTMP_1292 = UnaryType.BANG TMP_1291 \n\t\t\tTMP_1293 = UnaryType.BANG TMP_1292 \n\t\t\tTMP_1294(uint256) = TMP_1286 | TMP_1293\n\t\t\tCONDITION TMP_1294\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1295(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: c = a * RAY + b / 2 / b\n\t\tIRs:\n\t\t\tTMP_1296(uint256) = a * RAY\n\t\t\tTMP_1297(uint256) = b / 2\n\t\t\tTMP_1298(uint256) = TMP_1296 + TMP_1297\n\t\t\tTMP_1299(uint256) = TMP_1298 / b\n\t\t\tc(uint256) := TMP_1299(uint256)\n\t\tExpression: c\n\t\tIRs:\n\t\t\tRETURN c\n\tFunction WadRayMath.rayToWad(uint256) (*)\n\t\tExpression: b = a / WAD_RAY_RATIO\n\t\tIRs:\n\t\t\tTMP_1300(uint256) = a / WAD_RAY_RATIO\n\t\t\tb(uint256) := TMP_1300(uint256)\n\t\tExpression: remainder_rayToWad_asm_0 = a % WAD_RAY_RATIO\n\t\tIRs:\n\t\t\tTMP_1301(uint256) = a % WAD_RAY_RATIO\n\t\t\tremainder_rayToWad_asm_0(uint256) := TMP_1301(uint256)\n\t\tExpression: ! remainder_rayToWad_asm_0 < WAD_RAY_RATIO / 2\n\t\tIRs:\n\t\t\tTMP_1302(uint256) = WAD_RAY_RATIO / 2\n\t\t\tTMP_1303(bool) = remainder_rayToWad_asm_0 < TMP_1302\n\t\t\tTMP_1304 = UnaryType.BANG TMP_1303 \n\t\t\tCONDITION TMP_1304\n\t\tExpression: b = b + 1\n\t\tIRs:\n\t\t\tTMP_1305(uint256) = b + 1\n\t\t\tb(uint256) := TMP_1305(uint256)\n\t\tExpression: b\n\t\tIRs:\n\t\t\tRETURN b\n\tFunction WadRayMath.wadToRay(uint256) (*)\n\t\tExpression: b = a * WAD_RAY_RATIO\n\t\tIRs:\n\t\t\tTMP_1306(uint256) = a * WAD_RAY_RATIO\n\t\t\tb(uint256) := TMP_1306(uint256)\n\t\tExpression: ! b / WAD_RAY_RATIO == a\n\t\tIRs:\n\t\t\tTMP_1307(uint256) = b / WAD_RAY_RATIO\n\t\t\tTMP_1308(bool) = TMP_1307 == a\n\t\t\tTMP_1309 = UnaryType.BANG TMP_1308 \n\t\t\tCONDITION TMP_1309\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1310(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: b\n\t\tIRs:\n\t\t\tRETURN b\n\tFunction WadRayMath.slitherConstructorConstantVariables() (*)\n\t\tExpression: WAD = 1e18\n\t\tIRs:\n\t\t\tWAD(uint256) := 1000000000000000000(uint256)\n\t\tExpression: HALF_WAD = 0.5e18\n\t\tIRs:\n\t\t\tHALF_WAD(uint256) := 500000000000000000(uint256)\n\t\tExpression: RAY = 1e27\n\t\tIRs:\n\t\t\tRAY(uint256) := 1000000000000000000000000000(uint256)\n\t\tExpression: HALF_RAY = 0.5e27\n\t\tIRs:\n\t\t\tHALF_RAY(uint256) := 500000000000000000000000000(uint256)\n\t\tExpression: WAD_RAY_RATIO = 1e9\n\t\tIRs:\n\t\t\tWAD_RAY_RATIO(uint256) := 1000000000(uint256)\nContract DataTypes\nContract Pool\n\tFunction IPool.mintUnbacked(address,uint256,address,uint16) \n\tFunction IPool.backUnbacked(address,uint256,uint256) \n\tFunction IPool.supply(address,uint256,address,uint16) \n\tFunction IPool.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) \n\tFunction IPool.withdraw(address,uint256,address) \n\tFunction IPool.borrow(address,uint256,uint256,uint16,address) \n\tFunction IPool.repay(address,uint256,uint256,address) \n\tFunction IPool.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) \n\tFunction IPool.repayWithATokens(address,uint256,uint256) \n\tFunction IPool.swapBorrowRateMode(address,uint256) \n\tFunction IPool.rebalanceStableBorrowRate(address,address) \n\tFunction IPool.setUserUseReserveAsCollateral(address,bool) \n\tFunction IPool.liquidationCall(address,address,address,uint256,bool) \n\tFunction IPool.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) \n\tFunction IPool.flashLoanSimple(address,address,uint256,bytes,uint16) \n\tFunction IPool.getUserAccountData(address) \n\tFunction IPool.initReserve(address,address,address,address,address) \n\tFunction IPool.dropReserve(address) \n\tFunction IPool.setReserveInterestRateStrategyAddress(address,address) \n\tFunction IPool.setConfiguration(address,DataTypes.ReserveConfigurationMap) \n\tFunction IPool.getConfiguration(address) \n\tFunction IPool.getUserConfiguration(address) \n\tFunction IPool.getReserveNormalizedIncome(address) \n\tFunction IPool.getReserveNormalizedVariableDebt(address) \n\tFunction IPool.getReserveData(address) \n\tFunction IPool.finalizeTransfer(address,address,address,uint256,uint256,uint256) \n\tFunction IPool.getReservesList() \n\tFunction IPool.getReserveAddressById(uint16) \n\tFunction IPool.ADDRESSES_PROVIDER() (*)\n\tFunction IPool.updateBridgeProtocolFee(uint256) \n\tFunction IPool.updateFlashloanPremiums(uint128,uint128) \n\tFunction IPool.configureEModeCategory(uint8,DataTypes.EModeCategory) \n\tFunction IPool.getEModeCategoryData(uint8) \n\tFunction IPool.setUserEMode(uint8) \n\tFunction IPool.getUserEMode(address) \n\tFunction IPool.resetIsolationModeTotalDebt(address) \n\tFunction IPool.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() \n\tFunction IPool.FLASHLOAN_PREMIUM_TOTAL() \n\tFunction IPool.BRIDGE_PROTOCOL_FEE() \n\tFunction IPool.FLASHLOAN_PREMIUM_TO_PROTOCOL() \n\tFunction IPool.MAX_NUMBER_RESERVES() \n\tFunction IPool.mintToTreasury(address[]) \n\tFunction IPool.rescueTokens(address,address,uint256) \n\tFunction IPool.deposit(address,uint256,address,uint16) \n\tFunction VersionedInitializable.getRevision() \n\tFunction VersionedInitializable.isConstructor() (*)\n\t\tExpression: cs = extcodesize(uint256)(address()())\n\t\tIRs:\n\t\t\tTMP_1311 = CONVERT this to address\n\t\t\tREF_1487 -> CODESIZE TMP_1311\n\t\t\tcs(uint256) := REF_1487(uint256)\n\t\tExpression: cs == 0\n\t\tIRs:\n\t\t\tTMP_1312(bool) = cs == 0\n\t\t\tRETURN TMP_1312\n\tFunction Pool._onlyPoolConfigurator() (*)\n\t\tExpression: require(bool,string)(ADDRESSES_PROVIDER.getPoolConfigurator() == msg.sender,Errors.CALLER_NOT_POOL_CONFIGURATOR)\n\t\tIRs:\n\t\t\tTMP_1313(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPoolConfigurator, arguments:[]  \n\t\t\tTMP_1314(bool) = TMP_1313 == msg.sender\n\t\t\tREF_1489(string) -> Errors.CALLER_NOT_POOL_CONFIGURATOR\n\t\t\tTMP_1315(None) = SOLIDITY_CALL require(bool,string)(TMP_1314,REF_1489)\n\tFunction Pool._onlyPoolAdmin() (*)\n\t\tExpression: require(bool,string)(IACLManager(ADDRESSES_PROVIDER.getACLManager()).isPoolAdmin(msg.sender),Errors.CALLER_NOT_POOL_ADMIN)\n\t\tIRs:\n\t\t\tTMP_1316(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1317 = CONVERT TMP_1316 to IACLManager\n\t\t\tTMP_1318(bool) = HIGH_LEVEL_CALL, dest:TMP_1317(IACLManager), function:isPoolAdmin, arguments:['msg.sender']  \n\t\t\tREF_1492(string) -> Errors.CALLER_NOT_POOL_ADMIN\n\t\t\tTMP_1319(None) = SOLIDITY_CALL require(bool,string)(TMP_1318,REF_1492)\n\tFunction Pool._onlyBridge() (*)\n\t\tExpression: require(bool,string)(IACLManager(ADDRESSES_PROVIDER.getACLManager()).isBridge(msg.sender),Errors.CALLER_NOT_BRIDGE)\n\t\tIRs:\n\t\t\tTMP_1320(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1321 = CONVERT TMP_1320 to IACLManager\n\t\t\tTMP_1322(bool) = HIGH_LEVEL_CALL, dest:TMP_1321(IACLManager), function:isBridge, arguments:['msg.sender']  \n\t\t\tREF_1495(string) -> Errors.CALLER_NOT_BRIDGE\n\t\t\tTMP_1323(None) = SOLIDITY_CALL require(bool,string)(TMP_1322,REF_1495)\n\tFunction Pool.getRevision() (*)\n\t\tExpression: POOL_REVISION\n\t\tIRs:\n\t\t\tRETURN POOL_REVISION\n\tFunction Pool.constructor(IPoolAddressesProvider) (*)\n\t\tExpression: ADDRESSES_PROVIDER = provider\n\t\tIRs:\n\t\t\tADDRESSES_PROVIDER(IPoolAddressesProvider) := provider(IPoolAddressesProvider)\n\tFunction Pool.initialize(IPoolAddressesProvider) (*)\n\t\tExpression: require(bool,string)(provider == ADDRESSES_PROVIDER,Errors.INVALID_ADDRESSES_PROVIDER)\n\t\tIRs:\n\t\t\tTMP_1324(bool) = provider == ADDRESSES_PROVIDER\n\t\t\tREF_1496(string) -> Errors.INVALID_ADDRESSES_PROVIDER\n\t\t\tTMP_1325(None) = SOLIDITY_CALL require(bool,string)(TMP_1324,REF_1496)\n\t\tExpression: _maxStableRateBorrowSizePercent = 0.25e4\n\t\tIRs:\n\t\t\t_maxStableRateBorrowSizePercent(uint64) := 2500(uint256)\n\t\tExpression: initializer()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, VersionedInitializable.initializer()()\n\tFunction Pool.mintUnbacked(address,uint256,address,uint16) (*)\n\t\tExpression: BridgeLogic.executeMintUnbacked(_reserves,_reservesList,_usersConfig[onBehalfOf],asset,amount,onBehalfOf,referralCode)\n\t\tIRs:\n\t\t\tREF_1498(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tLIBRARY_CALL, dest:BridgeLogic, function:BridgeLogic.executeMintUnbacked(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,address,uint256,address,uint16), arguments:['_reserves', '_reservesList', 'REF_1498', 'asset', 'amount', 'onBehalfOf', 'referralCode'] \n\t\tExpression: onlyBridge()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyBridge()()\n\tFunction Pool.backUnbacked(address,uint256,uint256) (*)\n\t\tExpression: BridgeLogic.executeBackUnbacked(_reserves[asset],asset,amount,fee,_bridgeProtocolFee)\n\t\tIRs:\n\t\t\tREF_1500(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tTMP_1329(uint256) = LIBRARY_CALL, dest:BridgeLogic, function:BridgeLogic.executeBackUnbacked(DataTypes.ReserveData,address,uint256,uint256,uint256), arguments:['REF_1500', 'asset', 'amount', 'fee', '_bridgeProtocolFee'] \n\t\t\tRETURN TMP_1329\n\t\tExpression: onlyBridge()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyBridge()()\n\tFunction Pool.supply(address,uint256,address,uint16) (*)\n\t\tExpression: SupplyLogic.executeSupply(_reserves,_reservesList,_usersConfig[onBehalfOf],DataTypes.ExecuteSupplyParams({asset:asset,amount:amount,onBehalfOf:onBehalfOf,referralCode:referralCode}))\n\t\tIRs:\n\t\t\tREF_1502(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1331(DataTypes.ExecuteSupplyParams) = new ExecuteSupplyParams(asset,amount,onBehalfOf,referralCode)\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeSupply(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteSupplyParams), arguments:['_reserves', '_reservesList', 'REF_1502', 'TMP_1331'] \n\tFunction Pool.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) (*)\n\t\tExpression: IERC20WithPermit(asset).permit(msg.sender,address(this),amount,deadline,permitV,permitR,permitS)\n\t\tIRs:\n\t\t\tTMP_1333 = CONVERT asset to IERC20WithPermit\n\t\t\tTMP_1334 = CONVERT this to address\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_1333(IERC20WithPermit), function:permit, arguments:['msg.sender', 'TMP_1334', 'amount', 'deadline', 'permitV', 'permitR', 'permitS']  \n\t\tExpression: SupplyLogic.executeSupply(_reserves,_reservesList,_usersConfig[onBehalfOf],DataTypes.ExecuteSupplyParams({asset:asset,amount:amount,onBehalfOf:onBehalfOf,referralCode:referralCode}))\n\t\tIRs:\n\t\t\tREF_1506(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1336(DataTypes.ExecuteSupplyParams) = new ExecuteSupplyParams(asset,amount,onBehalfOf,referralCode)\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeSupply(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteSupplyParams), arguments:['_reserves', '_reservesList', 'REF_1506', 'TMP_1336'] \n\tFunction Pool.withdraw(address,uint256,address) (*)\n\t\tExpression: SupplyLogic.executeWithdraw(_reserves,_reservesList,_eModeCategories,_usersConfig[msg.sender],DataTypes.ExecuteWithdrawParams({asset:asset,amount:amount,to:to,reservesCount:_reservesCount,oracle:ADDRESSES_PROVIDER.getPriceOracle(),userEModeCategory:_usersEModeCategory[msg.sender]}))\n\t\tIRs:\n\t\t\tREF_1509(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1338(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1512(uint8) -> _usersEModeCategory[msg.sender]\n\t\t\tTMP_1339(DataTypes.ExecuteWithdrawParams) = new ExecuteWithdrawParams(asset,amount,to,_reservesCount,TMP_1338,REF_1512)\n\t\t\tTMP_1340(uint256) = LIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeWithdraw(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteWithdrawParams), arguments:['_reserves', '_reservesList', '_eModeCategories', 'REF_1509', 'TMP_1339'] \n\t\t\tRETURN TMP_1340\n\tFunction Pool.borrow(address,uint256,uint256,uint16,address) (*)\n\t\tExpression: BorrowLogic.executeBorrow(_reserves,_reservesList,_eModeCategories,_usersConfig[onBehalfOf],DataTypes.ExecuteBorrowParams({asset:asset,user:msg.sender,onBehalfOf:onBehalfOf,amount:amount,interestRateMode:DataTypes.InterestRateMode(interestRateMode),referralCode:referralCode,releaseUnderlying:true,maxStableRateBorrowSizePercent:_maxStableRateBorrowSizePercent,reservesCount:_reservesCount,oracle:ADDRESSES_PROVIDER.getPriceOracle(),userEModeCategory:_usersEModeCategory[onBehalfOf],priceOracleSentinel:ADDRESSES_PROVIDER.getPriceOracleSentinel()}))\n\t\tIRs:\n\t\t\tREF_1514(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1341 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tTMP_1342(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1517(uint8) -> _usersEModeCategory[onBehalfOf]\n\t\t\tTMP_1343(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracleSentinel, arguments:[]  \n\t\t\tTMP_1344(DataTypes.ExecuteBorrowParams) = new ExecuteBorrowParams(asset,msg.sender,onBehalfOf,amount,TMP_1341,referralCode,True,_maxStableRateBorrowSizePercent,_reservesCount,TMP_1342,REF_1517,TMP_1343)\n\t\t\tLIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteBorrowParams), arguments:['_reserves', '_reservesList', '_eModeCategories', 'REF_1514', 'TMP_1344'] \n\tFunction Pool.repay(address,uint256,uint256,address) (*)\n\t\tExpression: BorrowLogic.executeRepay(_reserves,_reservesList,_usersConfig[onBehalfOf],DataTypes.ExecuteRepayParams({asset:asset,amount:amount,interestRateMode:DataTypes.InterestRateMode(interestRateMode),onBehalfOf:onBehalfOf,useATokens:false}))\n\t\tIRs:\n\t\t\tREF_1520(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1346 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tTMP_1347(DataTypes.ExecuteRepayParams) = new ExecuteRepayParams(asset,amount,TMP_1346,onBehalfOf,False)\n\t\t\tTMP_1348(uint256) = LIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeRepay(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteRepayParams), arguments:['_reserves', '_reservesList', 'REF_1520', 'TMP_1347'] \n\t\t\tRETURN TMP_1348\n\tFunction Pool.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) (*)\n\t\tExpression: IERC20WithPermit(asset).permit(msg.sender,address(this),amount,deadline,permitV,permitR,permitS)\n\t\tIRs:\n\t\t\tTMP_1349 = CONVERT asset to IERC20WithPermit\n\t\t\tTMP_1350 = CONVERT this to address\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_1349(IERC20WithPermit), function:permit, arguments:['msg.sender', 'TMP_1350', 'amount', 'deadline', 'permitV', 'permitR', 'permitS']  \n\t\tExpression: params = DataTypes.ExecuteRepayParams({asset:asset,amount:amount,interestRateMode:DataTypes.InterestRateMode(interestRateMode),onBehalfOf:onBehalfOf,useATokens:false})\n\t\tIRs:\n\t\t\tTMP_1352 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tTMP_1353(DataTypes.ExecuteRepayParams) = new ExecuteRepayParams(asset,amount,TMP_1352,onBehalfOf,False)\n\t\t\tparams(DataTypes.ExecuteRepayParams) := TMP_1353(DataTypes.ExecuteRepayParams)\n\t\tExpression: BorrowLogic.executeRepay(_reserves,_reservesList,_usersConfig[onBehalfOf],params)\n\t\tIRs:\n\t\t\tREF_1525(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1354(uint256) = LIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeRepay(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteRepayParams), arguments:['_reserves', '_reservesList', 'REF_1525', 'params'] \n\t\t\tRETURN TMP_1354\n\tFunction Pool.repayWithATokens(address,uint256,uint256) (*)\n\t\tExpression: BorrowLogic.executeRepay(_reserves,_reservesList,_usersConfig[msg.sender],DataTypes.ExecuteRepayParams({asset:asset,amount:amount,interestRateMode:DataTypes.InterestRateMode(interestRateMode),onBehalfOf:msg.sender,useATokens:true}))\n\t\tIRs:\n\t\t\tREF_1527(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1355 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tTMP_1356(DataTypes.ExecuteRepayParams) = new ExecuteRepayParams(asset,amount,TMP_1355,msg.sender,True)\n\t\t\tTMP_1357(uint256) = LIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeRepay(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteRepayParams), arguments:['_reserves', '_reservesList', 'REF_1527', 'TMP_1356'] \n\t\t\tRETURN TMP_1357\n\tFunction Pool.swapBorrowRateMode(address,uint256) (*)\n\t\tExpression: BorrowLogic.executeSwapBorrowRateMode(_reserves[asset],_usersConfig[msg.sender],asset,DataTypes.InterestRateMode(interestRateMode))\n\t\tIRs:\n\t\t\tREF_1530(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1531(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1358 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tLIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeSwapBorrowRateMode(DataTypes.ReserveData,DataTypes.UserConfigurationMap,address,DataTypes.InterestRateMode), arguments:['REF_1530', 'REF_1531', 'asset', 'TMP_1358'] \n\tFunction Pool.rebalanceStableBorrowRate(address,address) (*)\n\t\tExpression: BorrowLogic.executeRebalanceStableBorrowRate(_reserves[asset],asset,user)\n\t\tIRs:\n\t\t\tREF_1533(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tLIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeRebalanceStableBorrowRate(DataTypes.ReserveData,address,address), arguments:['REF_1533', 'asset', 'user'] \n\tFunction Pool.setUserUseReserveAsCollateral(address,bool) (*)\n\t\tExpression: SupplyLogic.executeUseReserveAsCollateral(_reserves,_reservesList,_eModeCategories,_usersConfig[msg.sender],asset,useAsCollateral,_reservesCount,ADDRESSES_PROVIDER.getPriceOracle(),_usersEModeCategory[msg.sender])\n\t\tIRs:\n\t\t\tREF_1535(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1361(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1537(uint8) -> _usersEModeCategory[msg.sender]\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeUseReserveAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,bool,uint256,address,uint8), arguments:['_reserves', '_reservesList', '_eModeCategories', 'REF_1535', 'asset', 'useAsCollateral', '_reservesCount', 'TMP_1361', 'REF_1537'] \n\tFunction Pool.liquidationCall(address,address,address,uint256,bool) (*)\n\t\tExpression: LiquidationLogic.executeLiquidationCall(_reserves,_reservesList,_usersConfig,_eModeCategories,DataTypes.ExecuteLiquidationCallParams({reservesCount:_reservesCount,debtToCover:debtToCover,collateralAsset:collateralAsset,debtAsset:debtAsset,user:user,receiveAToken:receiveAToken,priceOracle:ADDRESSES_PROVIDER.getPriceOracle(),userEModeCategory:_usersEModeCategory[user],priceOracleSentinel:ADDRESSES_PROVIDER.getPriceOracleSentinel()}))\n\t\tIRs:\n\t\t\tTMP_1363(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1541(uint8) -> _usersEModeCategory[user]\n\t\t\tTMP_1364(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracleSentinel, arguments:[]  \n\t\t\tTMP_1365(DataTypes.ExecuteLiquidationCallParams) = new ExecuteLiquidationCallParams(_reservesCount,debtToCover,collateralAsset,debtAsset,user,receiveAToken,TMP_1363,REF_1541,TMP_1364)\n\t\t\tLIBRARY_CALL, dest:LiquidationLogic, function:LiquidationLogic.executeLiquidationCall(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(address => DataTypes.UserConfigurationMap),mapping(uint8 => DataTypes.EModeCategory),DataTypes.ExecuteLiquidationCallParams), arguments:['_reserves', '_reservesList', '_usersConfig', '_eModeCategories', 'TMP_1365'] \n\tFunction Pool.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) (*)\n\t\tExpression: flashParams = DataTypes.FlashloanParams({receiverAddress:receiverAddress,assets:assets,amounts:amounts,interestRateModes:interestRateModes,onBehalfOf:onBehalfOf,params:params,referralCode:referralCode,flashLoanPremiumToProtocol:_flashLoanPremiumToProtocol,flashLoanPremiumTotal:_flashLoanPremiumTotal,maxStableRateBorrowSizePercent:_maxStableRateBorrowSizePercent,reservesCount:_reservesCount,addressesProvider:address(ADDRESSES_PROVIDER),userEModeCategory:_usersEModeCategory[onBehalfOf],isAuthorizedFlashBorrower:IACLManager(ADDRESSES_PROVIDER.getACLManager()).isFlashBorrower(msg.sender)})\n\t\tIRs:\n\t\t\tTMP_1367 = CONVERT ADDRESSES_PROVIDER to address\n\t\t\tREF_1544(uint8) -> _usersEModeCategory[onBehalfOf]\n\t\t\tTMP_1368(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1369 = CONVERT TMP_1368 to IACLManager\n\t\t\tTMP_1370(bool) = HIGH_LEVEL_CALL, dest:TMP_1369(IACLManager), function:isFlashBorrower, arguments:['msg.sender']  \n\t\t\tTMP_1371(DataTypes.FlashloanParams) = new FlashloanParams(receiverAddress,assets,amounts,interestRateModes,onBehalfOf,params,referralCode,_flashLoanPremiumToProtocol,_flashLoanPremiumTotal,_maxStableRateBorrowSizePercent,_reservesCount,TMP_1367,REF_1544,TMP_1370)\n\t\t\tflashParams(DataTypes.FlashloanParams) := TMP_1371(DataTypes.FlashloanParams)\n\t\tExpression: FlashLoanLogic.executeFlashLoan(_reserves,_reservesList,_eModeCategories,_usersConfig[onBehalfOf],flashParams)\n\t\tIRs:\n\t\t\tREF_1548(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tLIBRARY_CALL, dest:FlashLoanLogic, function:FlashLoanLogic.executeFlashLoan(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.FlashloanParams), arguments:['_reserves', '_reservesList', '_eModeCategories', 'REF_1548', 'flashParams'] \n\tFunction Pool.flashLoanSimple(address,address,uint256,bytes,uint16) (*)\n\t\tExpression: flashParams = DataTypes.FlashloanSimpleParams({receiverAddress:receiverAddress,asset:asset,amount:amount,params:params,referralCode:referralCode,flashLoanPremiumToProtocol:_flashLoanPremiumToProtocol,flashLoanPremiumTotal:_flashLoanPremiumTotal})\n\t\tIRs:\n\t\t\tTMP_1373(DataTypes.FlashloanSimpleParams) = new FlashloanSimpleParams(receiverAddress,asset,amount,params,referralCode,_flashLoanPremiumToProtocol,_flashLoanPremiumTotal)\n\t\t\tflashParams(DataTypes.FlashloanSimpleParams) := TMP_1373(DataTypes.FlashloanSimpleParams)\n\t\tExpression: FlashLoanLogic.executeFlashLoanSimple(_reserves[asset],flashParams)\n\t\tIRs:\n\t\t\tREF_1551(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tLIBRARY_CALL, dest:FlashLoanLogic, function:FlashLoanLogic.executeFlashLoanSimple(DataTypes.ReserveData,DataTypes.FlashloanSimpleParams), arguments:['REF_1551', 'flashParams'] \n\tFunction Pool.mintToTreasury(address[]) (*)\n\t\tExpression: PoolLogic.executeMintToTreasury(_reserves,assets)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeMintToTreasury(mapping(address => DataTypes.ReserveData),address[]), arguments:['_reserves', 'assets'] \n\tFunction Pool.getReserveData(address) (*)\n\t\tExpression: _reserves[asset]\n\t\tIRs:\n\t\t\tREF_1553(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tRETURN REF_1553\n\tFunction Pool.getUserAccountData(address) (*)\n\t\tExpression: PoolLogic.executeGetUserAccountData(_reserves,_reservesList,_eModeCategories,DataTypes.CalculateUserAccountDataParams({userConfig:_usersConfig[user],reservesCount:_reservesCount,user:user,oracle:ADDRESSES_PROVIDER.getPriceOracle(),userEModeCategory:_usersEModeCategory[user]}))\n\t\tIRs:\n\t\t\tREF_1556(DataTypes.UserConfigurationMap) -> _usersConfig[user]\n\t\t\tTMP_1376(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1558(uint8) -> _usersEModeCategory[user]\n\t\t\tTMP_1377(DataTypes.CalculateUserAccountDataParams) = new CalculateUserAccountDataParams(REF_1556,_reservesCount,user,TMP_1376,REF_1558)\n\t\t\tTUPLE_43(uint256,uint256,uint256,uint256,uint256,uint256) = LIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeGetUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['_reserves', '_reservesList', '_eModeCategories', 'TMP_1377'] \n\t\t\tRETURN TUPLE_43\n\t\tExpression: (totalCollateralBase,totalDebtBase,availableBorrowsBase,currentLiquidationThreshold,ltv,healthFactor)\n\t\tIRs:\n\t\t\tRETURN totalCollateralBase,totalDebtBase,availableBorrowsBase,currentLiquidationThreshold,ltv,healthFactor\n\tFunction Pool.getConfiguration(address) (*)\n\t\tExpression: _reserves[asset].configuration\n\t\tIRs:\n\t\t\tREF_1559(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1560(DataTypes.ReserveConfigurationMap) -> REF_1559.configuration\n\t\t\tRETURN REF_1560\n\tFunction Pool.getUserConfiguration(address) (*)\n\t\tExpression: _usersConfig[user]\n\t\tIRs:\n\t\t\tREF_1561(DataTypes.UserConfigurationMap) -> _usersConfig[user]\n\t\t\tRETURN REF_1561\n\tFunction Pool.getReserveNormalizedIncome(address) (*)\n\t\tExpression: _reserves[asset].getNormalizedIncome()\n\t\tIRs:\n\t\t\tREF_1562(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tTMP_1378(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedIncome(DataTypes.ReserveData), arguments:['REF_1562'] \n\t\t\tRETURN TMP_1378\n\tFunction Pool.getReserveNormalizedVariableDebt(address) (*)\n\t\tExpression: _reserves[asset].getNormalizedDebt()\n\t\tIRs:\n\t\t\tREF_1564(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tTMP_1379(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedDebt(DataTypes.ReserveData), arguments:['REF_1564'] \n\t\t\tRETURN TMP_1379\n\tFunction Pool.getReservesList() (*)\n\t\tExpression: reservesListCount = _reservesCount\n\t\tIRs:\n\t\t\treservesListCount(uint256) := _reservesCount(uint16)\n\t\tExpression: droppedReservesCount = 0\n\t\tIRs:\n\t\t\tdroppedReservesCount(uint256) := 0(uint256)\n\t\tExpression: reservesList = new address[](reservesListCount)\n\t\tIRs:\n\t\t\tTMP_1381(address[])  = new address[](reservesListCount)\n\t\t\treservesList(address[]) = ['TMP_1381(address[])']\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint256) := 0(uint256)\n\t\tExpression: i < reservesListCount\n\t\tIRs:\n\t\t\tTMP_1382(bool) = i < reservesListCount\n\t\t\tCONDITION TMP_1382\n\t\tExpression: _reservesList[i] != address(0)\n\t\tIRs:\n\t\t\tREF_1566(address) -> _reservesList[i]\n\t\t\tTMP_1383 = CONVERT 0 to address\n\t\t\tTMP_1384(bool) = REF_1566 != TMP_1383\n\t\t\tCONDITION TMP_1384\n\t\tExpression: reservesList[i - droppedReservesCount] = _reservesList[i]\n\t\tIRs:\n\t\t\tTMP_1385(uint256) = i (c)- droppedReservesCount\n\t\t\tREF_1567(address) -> reservesList[TMP_1385]\n\t\t\tREF_1568(address) -> _reservesList[i]\n\t\t\tREF_1567(address) (->reservesList) := REF_1568(address)\n\t\tExpression: droppedReservesCount ++\n\t\tIRs:\n\t\t\tTMP_1386(uint256) := droppedReservesCount(uint256)\n\t\t\tdroppedReservesCount(uint256) = droppedReservesCount (c)+ 1\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_1387(uint256) := i(uint256)\n\t\t\ti(uint256) = i (c)+ 1\n\t\tExpression: mstore(uint256,uint256)(reservesList,reservesListCount - droppedReservesCount)\n\t\tIRs:\n\t\t\tTMP_1388(uint256) = reservesListCount - droppedReservesCount\n\t\t\tTMP_1389(None) = SOLIDITY_CALL mstore(uint256,uint256)(reservesList,TMP_1388)\n\t\tExpression: reservesList\n\t\tIRs:\n\t\t\tRETURN reservesList\n\tFunction Pool.getReserveAddressById(uint16) (*)\n\t\tExpression: _reservesList[id]\n\t\tIRs:\n\t\t\tREF_1569(address) -> _reservesList[id]\n\t\t\tRETURN REF_1569\n\tFunction Pool.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() (*)\n\t\tExpression: _maxStableRateBorrowSizePercent\n\t\tIRs:\n\t\t\tRETURN _maxStableRateBorrowSizePercent\n\tFunction Pool.BRIDGE_PROTOCOL_FEE() (*)\n\t\tExpression: _bridgeProtocolFee\n\t\tIRs:\n\t\t\tRETURN _bridgeProtocolFee\n\tFunction Pool.FLASHLOAN_PREMIUM_TOTAL() (*)\n\t\tExpression: _flashLoanPremiumTotal\n\t\tIRs:\n\t\t\tRETURN _flashLoanPremiumTotal\n\tFunction Pool.FLASHLOAN_PREMIUM_TO_PROTOCOL() (*)\n\t\tExpression: _flashLoanPremiumToProtocol\n\t\tIRs:\n\t\t\tRETURN _flashLoanPremiumToProtocol\n\tFunction Pool.MAX_NUMBER_RESERVES() (*)\n\t\tExpression: ReserveConfiguration.MAX_RESERVES_COUNT\n\t\tIRs:\n\t\t\tREF_1570(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tRETURN REF_1570\n\tFunction Pool.finalizeTransfer(address,address,address,uint256,uint256,uint256) (*)\n\t\tExpression: require(bool,string)(msg.sender == _reserves[asset].aTokenAddress,Errors.CALLER_NOT_ATOKEN)\n\t\tIRs:\n\t\t\tREF_1571(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1572(address) -> REF_1571.aTokenAddress\n\t\t\tTMP_1390(bool) = msg.sender == REF_1572\n\t\t\tREF_1573(string) -> Errors.CALLER_NOT_ATOKEN\n\t\t\tTMP_1391(None) = SOLIDITY_CALL require(bool,string)(TMP_1390,REF_1573)\n\t\tExpression: SupplyLogic.executeFinalizeTransfer(_reserves,_reservesList,_eModeCategories,_usersConfig,DataTypes.FinalizeTransferParams({asset:asset,from:from,to:to,amount:amount,balanceFromBefore:balanceFromBefore,balanceToBefore:balanceToBefore,reservesCount:_reservesCount,oracle:ADDRESSES_PROVIDER.getPriceOracle(),fromEModeCategory:_usersEModeCategory[from]}))\n\t\tIRs:\n\t\t\tTMP_1392(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1577(uint8) -> _usersEModeCategory[from]\n\t\t\tTMP_1393(DataTypes.FinalizeTransferParams) = new FinalizeTransferParams(asset,from,to,amount,balanceFromBefore,balanceToBefore,_reservesCount,TMP_1392,REF_1577)\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeFinalizeTransfer(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),mapping(address => DataTypes.UserConfigurationMap),DataTypes.FinalizeTransferParams), arguments:['_reserves', '_reservesList', '_eModeCategories', '_usersConfig', 'TMP_1393'] \n\tFunction Pool.initReserve(address,address,address,address,address) (*)\n\t\tExpression: PoolLogic.executeInitReserve(_reserves,_reservesList,DataTypes.InitReserveParams({asset:asset,aTokenAddress:aTokenAddress,stableDebtAddress:stableDebtAddress,variableDebtAddress:variableDebtAddress,interestRateStrategyAddress:interestRateStrategyAddress,reservesCount:_reservesCount,maxNumberReserves:MAX_NUMBER_RESERVES()}))\n\t\tIRs:\n\t\t\tTMP_1395(uint16) = INTERNAL_CALL, Pool.MAX_NUMBER_RESERVES()()\n\t\t\tTMP_1396(DataTypes.InitReserveParams) = new InitReserveParams(asset,aTokenAddress,stableDebtAddress,variableDebtAddress,interestRateStrategyAddress,_reservesCount,TMP_1395)\n\t\t\tTMP_1397(bool) = LIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeInitReserve(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.InitReserveParams), arguments:['_reserves', '_reservesList', 'TMP_1396'] \n\t\t\tCONDITION TMP_1397\n\t\tExpression: _reservesCount ++\n\t\tIRs:\n\t\t\tTMP_1398(uint16) := _reservesCount(uint16)\n\t\t\t_reservesCount(uint16) = _reservesCount (c)+ 1\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.dropReserve(address) (*)\n\t\tExpression: PoolLogic.executeDropReserve(_reserves,_reservesList,asset)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeDropReserve(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),address), arguments:['_reserves', '_reservesList', 'asset'] \n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.setReserveInterestRateStrategyAddress(address,address) (*)\n\t\tExpression: require(bool,string)(asset != address(0),Errors.ZERO_ADDRESS_NOT_VALID)\n\t\tIRs:\n\t\t\tTMP_1402 = CONVERT 0 to address\n\t\t\tTMP_1403(bool) = asset != TMP_1402\n\t\t\tREF_1581(string) -> Errors.ZERO_ADDRESS_NOT_VALID\n\t\t\tTMP_1404(None) = SOLIDITY_CALL require(bool,string)(TMP_1403,REF_1581)\n\t\tExpression: require(bool,string)(_reserves[asset].id != 0 || _reservesList[0] == asset,Errors.ASSET_NOT_LISTED)\n\t\tIRs:\n\t\t\tREF_1582(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1583(uint16) -> REF_1582.id\n\t\t\tTMP_1405(bool) = REF_1583 != 0\n\t\t\tREF_1584(address) -> _reservesList[0]\n\t\t\tTMP_1406(bool) = REF_1584 == asset\n\t\t\tTMP_1407(bool) = TMP_1405 || TMP_1406\n\t\t\tREF_1585(string) -> Errors.ASSET_NOT_LISTED\n\t\t\tTMP_1408(None) = SOLIDITY_CALL require(bool,string)(TMP_1407,REF_1585)\n\t\tExpression: _reserves[asset].interestRateStrategyAddress = rateStrategyAddress\n\t\tIRs:\n\t\t\tREF_1586(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1587(address) -> REF_1586.interestRateStrategyAddress\n\t\t\tREF_1587(address) (->_reserves) := rateStrategyAddress(address)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.setConfiguration(address,DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: require(bool,string)(asset != address(0),Errors.ZERO_ADDRESS_NOT_VALID)\n\t\tIRs:\n\t\t\tTMP_1410 = CONVERT 0 to address\n\t\t\tTMP_1411(bool) = asset != TMP_1410\n\t\t\tREF_1588(string) -> Errors.ZERO_ADDRESS_NOT_VALID\n\t\t\tTMP_1412(None) = SOLIDITY_CALL require(bool,string)(TMP_1411,REF_1588)\n\t\tExpression: require(bool,string)(_reserves[asset].id != 0 || _reservesList[0] == asset,Errors.ASSET_NOT_LISTED)\n\t\tIRs:\n\t\t\tREF_1589(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1590(uint16) -> REF_1589.id\n\t\t\tTMP_1413(bool) = REF_1590 != 0\n\t\t\tREF_1591(address) -> _reservesList[0]\n\t\t\tTMP_1414(bool) = REF_1591 == asset\n\t\t\tTMP_1415(bool) = TMP_1413 || TMP_1414\n\t\t\tREF_1592(string) -> Errors.ASSET_NOT_LISTED\n\t\t\tTMP_1416(None) = SOLIDITY_CALL require(bool,string)(TMP_1415,REF_1592)\n\t\tExpression: _reserves[asset].configuration = configuration\n\t\tIRs:\n\t\t\tREF_1593(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1594(DataTypes.ReserveConfigurationMap) -> REF_1593.configuration\n\t\t\tREF_1594(DataTypes.ReserveConfigurationMap) (->_reserves) := configuration(DataTypes.ReserveConfigurationMap)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.updateBridgeProtocolFee(uint256) (*)\n\t\tExpression: _bridgeProtocolFee = protocolFee\n\t\tIRs:\n\t\t\t_bridgeProtocolFee(uint256) := protocolFee(uint256)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.updateFlashloanPremiums(uint128,uint128) (*)\n\t\tExpression: _flashLoanPremiumTotal = flashLoanPremiumTotal\n\t\tIRs:\n\t\t\t_flashLoanPremiumTotal(uint128) := flashLoanPremiumTotal(uint128)\n\t\tExpression: _flashLoanPremiumToProtocol = flashLoanPremiumToProtocol\n\t\tIRs:\n\t\t\t_flashLoanPremiumToProtocol(uint128) := flashLoanPremiumToProtocol(uint128)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.configureEModeCategory(uint8,DataTypes.EModeCategory) (*)\n\t\tExpression: require(bool,string)(id != 0,Errors.EMODE_CATEGORY_RESERVED)\n\t\tIRs:\n\t\t\tTMP_1420(bool) = id != 0\n\t\t\tREF_1595(string) -> Errors.EMODE_CATEGORY_RESERVED\n\t\t\tTMP_1421(None) = SOLIDITY_CALL require(bool,string)(TMP_1420,REF_1595)\n\t\tExpression: _eModeCategories[id] = category\n\t\tIRs:\n\t\t\tREF_1596(DataTypes.EModeCategory) -> _eModeCategories[id]\n\t\t\tREF_1596(DataTypes.EModeCategory) (->_eModeCategories) := category(DataTypes.EModeCategory)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.getEModeCategoryData(uint8) (*)\n\t\tExpression: _eModeCategories[id]\n\t\tIRs:\n\t\t\tREF_1597(DataTypes.EModeCategory) -> _eModeCategories[id]\n\t\t\tRETURN REF_1597\n\tFunction Pool.setUserEMode(uint8) (*)\n\t\tExpression: EModeLogic.executeSetUserEMode(_reserves,_reservesList,_eModeCategories,_usersEModeCategory,_usersConfig[msg.sender],DataTypes.ExecuteSetUserEModeParams({reservesCount:_reservesCount,oracle:ADDRESSES_PROVIDER.getPriceOracle(),categoryId:categoryId}))\n\t\tIRs:\n\t\t\tREF_1599(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1423(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tTMP_1424(DataTypes.ExecuteSetUserEModeParams) = new ExecuteSetUserEModeParams(_reservesCount,TMP_1423,categoryId)\n\t\t\tLIBRARY_CALL, dest:EModeLogic, function:EModeLogic.executeSetUserEMode(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),mapping(address => uint8),DataTypes.UserConfigurationMap,DataTypes.ExecuteSetUserEModeParams), arguments:['_reserves', '_reservesList', '_eModeCategories', '_usersEModeCategory', 'REF_1599', 'TMP_1424'] \n\tFunction Pool.getUserEMode(address) (*)\n\t\tExpression: _usersEModeCategory[user]\n\t\tIRs:\n\t\t\tREF_1602(uint8) -> _usersEModeCategory[user]\n\t\t\tRETURN REF_1602\n\tFunction Pool.resetIsolationModeTotalDebt(address) (*)\n\t\tExpression: PoolLogic.executeResetIsolationModeTotalDebt(_reserves,asset)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeResetIsolationModeTotalDebt(mapping(address => DataTypes.ReserveData),address), arguments:['_reserves', 'asset'] \n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.rescueTokens(address,address,uint256) (*)\n\t\tExpression: PoolLogic.executeRescueTokens(token,to,amount)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeRescueTokens(address,address,uint256), arguments:['token', 'to', 'amount'] \n\t\tExpression: onlyPoolAdmin()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolAdmin()()\n\tFunction Pool.deposit(address,uint256,address,uint16) (*)\n\t\tExpression: SupplyLogic.executeSupply(_reserves,_reservesList,_usersConfig[onBehalfOf],DataTypes.ExecuteSupplyParams({asset:asset,amount:amount,onBehalfOf:onBehalfOf,referralCode:referralCode}))\n\t\tIRs:\n\t\t\tREF_1606(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1430(DataTypes.ExecuteSupplyParams) = new ExecuteSupplyParams(asset,amount,onBehalfOf,referralCode)\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeSupply(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteSupplyParams), arguments:['_reserves', '_reservesList', 'REF_1606', 'TMP_1430'] \n\tFunction Pool.slitherConstructorConstantVariables() (*)\n\t\tExpression: POOL_REVISION = 0x1\n\t\tIRs:\n\t\t\tPOOL_REVISION(uint256) := 1(uint256)\n\tModifier VersionedInitializable.initializer()\n\t\tExpression: revision = getRevision()\n\t\tIRs:\n\t\t\tTMP_1432(uint256) = INTERNAL_CALL, Pool.getRevision()()\n\t\t\trevision(uint256) := TMP_1432(uint256)\n\t\tExpression: require(bool,string)(initializing || isConstructor() || revision > lastInitializedRevision,Contract instance has already been initialized)\n\t\tIRs:\n\t\t\tTMP_1433(bool) = INTERNAL_CALL, VersionedInitializable.isConstructor()()\n\t\t\tTMP_1434(bool) = initializing || TMP_1433\n\t\t\tTMP_1435(bool) = revision > lastInitializedRevision\n\t\t\tTMP_1436(bool) = TMP_1434 || TMP_1435\n\t\t\tTMP_1437(None) = SOLIDITY_CALL require(bool,string)(TMP_1436,Contract instance has already been initialized)\n\t\tExpression: isTopLevelCall = ! initializing\n\t\tIRs:\n\t\t\tTMP_1438 = UnaryType.BANG initializing \n\t\t\tisTopLevelCall(bool) := TMP_1438(bool)\n\t\tExpression: isTopLevelCall\n\t\tIRs:\n\t\t\tCONDITION isTopLevelCall\n\t\tExpression: initializing = true\n\t\tIRs:\n\t\t\tinitializing(bool) := True(bool)\n\t\tExpression: lastInitializedRevision = revision\n\t\tIRs:\n\t\t\tlastInitializedRevision(uint256) := revision(uint256)\n\t\tExpression: isTopLevelCall\n\t\tIRs:\n\t\t\tCONDITION isTopLevelCall\n\t\tExpression: initializing = false\n\t\tIRs:\n\t\t\tinitializing(bool) := False(bool)\n\tModifier Pool.onlyPoolConfigurator()\n\t\tExpression: _onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tINTERNAL_CALL, Pool._onlyPoolConfigurator()()\n\tModifier Pool.onlyPoolAdmin()\n\t\tExpression: _onlyPoolAdmin()\n\t\tIRs:\n\t\t\tINTERNAL_CALL, Pool._onlyPoolAdmin()()\n\tModifier Pool.onlyBridge()\n\t\tExpression: _onlyBridge()\n\t\tIRs:\n\t\t\tINTERNAL_CALL, Pool._onlyBridge()()\nContract PoolStorage\nContract IncentivizedERC20\n\tFunction IERC20Detailed.name() \n\tFunction IERC20Detailed.symbol() \n\tFunction IERC20Detailed.decimals() \n\tFunction IERC20.totalSupply() \n\tFunction IERC20.balanceOf(address) \n\tFunction IERC20.transfer(address,uint256) \n\tFunction IERC20.allowance(address,address) \n\tFunction IERC20.approve(address,uint256) \n\tFunction IERC20.transferFrom(address,address,uint256) \n\tFunction Context._msgSender() (*)\n\t\tExpression: address(msg.sender)\n\t\tIRs:\n\t\t\tTMP_1442 = CONVERT msg.sender to address\n\t\t\tRETURN TMP_1442\n\tFunction Context._msgData() (*)\n\t\tExpression: this\n\t\tIRs:\n\t\tExpression: msg.data\n\t\tIRs:\n\t\t\tRETURN msg.data\n\tFunction IncentivizedERC20.constructor(IPool,string,string,uint8) (*)\n\t\tExpression: _addressesProvider = pool.ADDRESSES_PROVIDER()\n\t\tIRs:\n\t\t\tTMP_1443(IPoolAddressesProvider) = HIGH_LEVEL_CALL, dest:pool(IPool), function:ADDRESSES_PROVIDER, arguments:[]  \n\t\t\t_addressesProvider(IPoolAddressesProvider) := TMP_1443(IPoolAddressesProvider)\n\t\tExpression: _name = name\n\t\tIRs:\n\t\t\t_name(string) := name(string)\n\t\tExpression: _symbol = symbol\n\t\tIRs:\n\t\t\t_symbol(string) := symbol(string)\n\t\tExpression: _decimals = decimals\n\t\tIRs:\n\t\t\t_decimals(uint8) := decimals(uint8)\n\t\tExpression: POOL = pool\n\t\tIRs:\n\t\t\tPOOL(IPool) := pool(IPool)\n\tFunction IncentivizedERC20.name() (*)\n\t\tExpression: _name\n\t\tIRs:\n\t\t\tRETURN _name\n\tFunction IncentivizedERC20.symbol() (*)\n\t\tExpression: _symbol\n\t\tIRs:\n\t\t\tRETURN _symbol\n\tFunction IncentivizedERC20.decimals() (*)\n\t\tExpression: _decimals\n\t\tIRs:\n\t\t\tRETURN _decimals\n\tFunction IncentivizedERC20.totalSupply() (*)\n\t\tExpression: _totalSupply\n\t\tIRs:\n\t\t\tRETURN _totalSupply\n\tFunction IncentivizedERC20.balanceOf(address) (*)\n\t\tExpression: _userState[account].balance\n\t\tIRs:\n\t\t\tREF_1609(IncentivizedERC20.UserState) -> _userState[account]\n\t\t\tREF_1610(uint128) -> REF_1609.balance\n\t\t\tRETURN REF_1610\n\tFunction IncentivizedERC20.getIncentivesController() (*)\n\t\tExpression: _incentivesController\n\t\tIRs:\n\t\t\tRETURN _incentivesController\n\tFunction IncentivizedERC20.setIncentivesController(IAaveIncentivesController) (*)\n\t\tExpression: _incentivesController = controller\n\t\tIRs:\n\t\t\t_incentivesController(IAaveIncentivesController) := controller(IAaveIncentivesController)\n\t\tExpression: onlyPoolAdmin()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, IncentivizedERC20.onlyPoolAdmin()()\n\tFunction IncentivizedERC20.transfer(address,uint256) (*)\n\t\tExpression: castAmount = amount.toUint128()\n\t\tIRs:\n\t\t\tTMP_1445(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['amount'] \n\t\t\tcastAmount(uint128) := TMP_1445(uint128)\n\t\tExpression: _transfer(_msgSender(),recipient,castAmount)\n\t\tIRs:\n\t\t\tTMP_1446(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tINTERNAL_CALL, IncentivizedERC20._transfer(address,address,uint128)(TMP_1446,recipient,castAmount)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20.allowance(address,address) (*)\n\t\tExpression: _allowances[owner][spender]\n\t\tIRs:\n\t\t\tREF_1612(mapping(address => uint256)) -> _allowances[owner]\n\t\t\tREF_1613(uint256) -> REF_1612[spender]\n\t\t\tRETURN REF_1613\n\tFunction IncentivizedERC20.approve(address,uint256) (*)\n\t\tExpression: _approve(_msgSender(),spender,amount)\n\t\tIRs:\n\t\t\tTMP_1448(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tINTERNAL_CALL, IncentivizedERC20._approve(address,address,uint256)(TMP_1448,spender,amount)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20.transferFrom(address,address,uint256) (*)\n\t\tExpression: castAmount = amount.toUint128()\n\t\tIRs:\n\t\t\tTMP_1450(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['amount'] \n\t\t\tcastAmount(uint128) := TMP_1450(uint128)\n\t\tExpression: _approve(sender,_msgSender(),_allowances[sender][_msgSender()] - castAmount)\n\t\tIRs:\n\t\t\tTMP_1451(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tREF_1615(mapping(address => uint256)) -> _allowances[sender]\n\t\t\tTMP_1452(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tREF_1616(uint256) -> REF_1615[TMP_1452]\n\t\t\tTMP_1453(uint256) = REF_1616 (c)- castAmount\n\t\t\tINTERNAL_CALL, IncentivizedERC20._approve(address,address,uint256)(sender,TMP_1451,TMP_1453)\n\t\tExpression: _transfer(sender,recipient,castAmount)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, IncentivizedERC20._transfer(address,address,uint128)(sender,recipient,castAmount)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20.increaseAllowance(address,uint256) (*)\n\t\tExpression: _approve(_msgSender(),spender,_allowances[_msgSender()][spender] + addedValue)\n\t\tIRs:\n\t\t\tTMP_1456(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tTMP_1457(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tREF_1617(mapping(address => uint256)) -> _allowances[TMP_1457]\n\t\t\tREF_1618(uint256) -> REF_1617[spender]\n\t\t\tTMP_1458(uint256) = REF_1618 (c)+ addedValue\n\t\t\tINTERNAL_CALL, IncentivizedERC20._approve(address,address,uint256)(TMP_1456,spender,TMP_1458)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20.decreaseAllowance(address,uint256) (*)\n\t\tExpression: _approve(_msgSender(),spender,_allowances[_msgSender()][spender] - subtractedValue)\n\t\tIRs:\n\t\t\tTMP_1460(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tTMP_1461(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tREF_1619(mapping(address => uint256)) -> _allowances[TMP_1461]\n\t\t\tREF_1620(uint256) -> REF_1619[spender]\n\t\t\tTMP_1462(uint256) = REF_1620 (c)- subtractedValue\n\t\t\tINTERNAL_CALL, IncentivizedERC20._approve(address,address,uint256)(TMP_1460,spender,TMP_1462)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20._transfer(address,address,uint128) (*)\n\t\tExpression: oldSenderBalance = _userState[sender].balance\n\t\tIRs:\n\t\t\tREF_1621(IncentivizedERC20.UserState) -> _userState[sender]\n\t\t\tREF_1622(uint128) -> REF_1621.balance\n\t\t\toldSenderBalance(uint128) := REF_1622(uint128)\n\t\tExpression: _userState[sender].balance = oldSenderBalance - amount\n\t\tIRs:\n\t\t\tREF_1623(IncentivizedERC20.UserState) -> _userState[sender]\n\t\t\tREF_1624(uint128) -> REF_1623.balance\n\t\t\tTMP_1464(uint128) = oldSenderBalance (c)- amount\n\t\t\tREF_1624(uint128) (->_userState) := TMP_1464(uint128)\n\t\tExpression: oldRecipientBalance = _userState[recipient].balance\n\t\tIRs:\n\t\t\tREF_1625(IncentivizedERC20.UserState) -> _userState[recipient]\n\t\t\tREF_1626(uint128) -> REF_1625.balance\n\t\t\toldRecipientBalance(uint128) := REF_1626(uint128)\n\t\tExpression: _userState[recipient].balance = oldRecipientBalance + amount\n\t\tIRs:\n\t\t\tREF_1627(IncentivizedERC20.UserState) -> _userState[recipient]\n\t\t\tREF_1628(uint128) -> REF_1627.balance\n\t\t\tTMP_1465(uint128) = oldRecipientBalance (c)+ amount\n\t\t\tREF_1628(uint128) (->_userState) := TMP_1465(uint128)\n\t\tExpression: incentivesControllerLocal = _incentivesController\n\t\tIRs:\n\t\t\tincentivesControllerLocal(IAaveIncentivesController) := _incentivesController(IAaveIncentivesController)\n\t\tExpression: address(incentivesControllerLocal) != address(0)\n\t\tIRs:\n\t\t\tTMP_1466 = CONVERT incentivesControllerLocal to address\n\t\t\tTMP_1467 = CONVERT 0 to address\n\t\t\tTMP_1468(bool) = TMP_1466 != TMP_1467\n\t\t\tCONDITION TMP_1468\n\t\tExpression: currentTotalSupply = _totalSupply\n\t\tIRs:\n\t\t\tcurrentTotalSupply(uint256) := _totalSupply(uint256)\n\t\tExpression: incentivesControllerLocal.handleAction(sender,currentTotalSupply,oldSenderBalance)\n\t\tIRs:\n\t\t\tHIGH_LEVEL_CALL, dest:incentivesControllerLocal(IAaveIncentivesController), function:handleAction, arguments:['sender', 'currentTotalSupply', 'oldSenderBalance']  \n\t\tExpression: sender != recipient\n\t\tIRs:\n\t\t\tTMP_1470(bool) = sender != recipient\n\t\t\tCONDITION TMP_1470\n\t\tExpression: incentivesControllerLocal.handleAction(recipient,currentTotalSupply,oldRecipientBalance)\n\t\tIRs:\n\t\t\tHIGH_LEVEL_CALL, dest:incentivesControllerLocal(IAaveIncentivesController), function:handleAction, arguments:['recipient', 'currentTotalSupply', 'oldRecipientBalance']  \n\tFunction IncentivizedERC20._approve(address,address,uint256) (*)\n\t\tExpression: _allowances[owner][spender] = amount\n\t\tIRs:\n\t\t\tREF_1631(mapping(address => uint256)) -> _allowances[owner]\n\t\t\tREF_1632(uint256) -> REF_1631[spender]\n\t\t\tREF_1632(uint256) (->_allowances) := amount(uint256)\n\t\tExpression: Approval(owner,spender,amount)\n\t\tIRs:\n\t\t\tEmit Approval(owner,spender,amount)\n\tFunction IncentivizedERC20._setName(string) (*)\n\t\tExpression: _name = newName\n\t\tIRs:\n\t\t\t_name(string) := newName(string)\n\tFunction IncentivizedERC20._setSymbol(string) (*)\n\t\tExpression: _symbol = newSymbol\n\t\tIRs:\n\t\t\t_symbol(string) := newSymbol(string)\n\tFunction IncentivizedERC20._setDecimals(uint8) (*)\n\t\tExpression: _decimals = newDecimals\n\t\tIRs:\n\t\t\t_decimals(uint8) := newDecimals(uint8)\n\tModifier IncentivizedERC20.onlyPoolAdmin()\n\t\tExpression: aclManager = IACLManager(_addressesProvider.getACLManager())\n\t\tIRs:\n\t\t\tTMP_1473(address) = HIGH_LEVEL_CALL, dest:_addressesProvider(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1474 = CONVERT TMP_1473 to IACLManager\n\t\t\taclManager(IACLManager) := TMP_1474(IACLManager)\n\t\tExpression: require(bool,string)(aclManager.isPoolAdmin(msg.sender),Errors.CALLER_NOT_POOL_ADMIN)\n\t\tIRs:\n\t\t\tTMP_1475(bool) = HIGH_LEVEL_CALL, dest:aclManager(IACLManager), function:isPoolAdmin, arguments:['msg.sender']  \n\t\t\tREF_1635(string) -> Errors.CALLER_NOT_POOL_ADMIN\n\t\t\tTMP_1476(None) = SOLIDITY_CALL require(bool,string)(TMP_1475,REF_1635)\n\tModifier IncentivizedERC20.onlyPool()\n\t\tExpression: require(bool,string)(_msgSender() == address(POOL),Errors.CALLER_MUST_BE_POOL)\n\t\tIRs:\n\t\t\tTMP_1477(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tTMP_1478 = CONVERT POOL to address\n\t\t\tTMP_1479(bool) = TMP_1477 == TMP_1478\n\t\t\tREF_1636(string) -> Errors.CALLER_MUST_BE_POOL\n\t\t\tTMP_1480(None) = SOLIDITY_CALL require(bool,string)(TMP_1479,REF_1636)\n",
        "markdown": "Contract GPv2SafeERC20\n\tFunction GPv2SafeERC20.safeTransfer(IERC20,address,uint256) (*)\n\t\tExpression: selector_ = token.transfer.selector\n\t\tIRs:\n\t\t\tREF_1(bytes4) (->None) := 2835717307(bytes4)\n\t\t\tselector_(bytes4) := REF_1(bytes4)\n\t\tExpression: freeMemoryPointer_safeTransfer_asm_0 = mload(uint256)(0x40)\n\t\tIRs:\n\t\t\tTMP_0(uint256) = SOLIDITY_CALL mload(uint256)(64)\n\t\t\tfreeMemoryPointer_safeTransfer_asm_0(uint256) := TMP_0(uint256)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransfer_asm_0,selector_)\n\t\tIRs:\n\t\t\tTMP_1(None) = SOLIDITY_CALL mstore(uint256,uint256)(freeMemoryPointer_safeTransfer_asm_0,selector_)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransfer_asm_0 + 4,to & 0xffffffffffffffffffffffffffffffffffffffff)\n\t\tIRs:\n\t\t\tTMP_2(uint256) = freeMemoryPointer_safeTransfer_asm_0 + 4\n\t\t\tTMP_3(address) = to & 1461501637330902918203684832716283019655932542975\n\t\t\tTMP_4(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_2,TMP_3)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransfer_asm_0 + 36,value)\n\t\tIRs:\n\t\t\tTMP_5(uint256) = freeMemoryPointer_safeTransfer_asm_0 + 36\n\t\t\tTMP_6(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_5,value)\n\t\tExpression: ! call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,freeMemoryPointer_safeTransfer_asm_0,68,0,0)\n\t\tIRs:\n\t\t\tTMP_7(uint256) = SOLIDITY_CALL gas()()\n\t\t\tTMP_8(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_7,token,0,freeMemoryPointer_safeTransfer_asm_0,68,0,0)\n\t\t\tTMP_9 = UnaryType.BANG TMP_8 \n\t\t\tCONDITION TMP_9\n\t\tExpression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_10(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_11(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_10)\n\t\tExpression: revert(uint256,uint256)(0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_12(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_13(None) = SOLIDITY_CALL revert(uint256,uint256)(0,TMP_12)\n\t\tExpression: require(bool,string)(getLastTransferResult(token),GPv2: failed transfer)\n\t\tIRs:\n\t\t\tTMP_14(bool) = INTERNAL_CALL, GPv2SafeERC20.getLastTransferResult(IERC20)(token)\n\t\t\tTMP_15(None) = SOLIDITY_CALL require(bool,string)(TMP_14,GPv2: failed transfer)\n\tFunction GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256) (*)\n\t\tExpression: selector_ = token.transferFrom.selector\n\t\tIRs:\n\t\t\tREF_3(bytes4) (->None) := 599290589(bytes4)\n\t\t\tselector_(bytes4) := REF_3(bytes4)\n\t\tExpression: freeMemoryPointer_safeTransferFrom_asm_0 = mload(uint256)(0x40)\n\t\tIRs:\n\t\t\tTMP_16(uint256) = SOLIDITY_CALL mload(uint256)(64)\n\t\t\tfreeMemoryPointer_safeTransferFrom_asm_0(uint256) := TMP_16(uint256)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0,selector_)\n\t\tIRs:\n\t\t\tTMP_17(None) = SOLIDITY_CALL mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0,selector_)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0 + 4,from & 0xffffffffffffffffffffffffffffffffffffffff)\n\t\tIRs:\n\t\t\tTMP_18(uint256) = freeMemoryPointer_safeTransferFrom_asm_0 + 4\n\t\t\tTMP_19(address) = from & 1461501637330902918203684832716283019655932542975\n\t\t\tTMP_20(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_18,TMP_19)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0 + 36,to & 0xffffffffffffffffffffffffffffffffffffffff)\n\t\tIRs:\n\t\t\tTMP_21(uint256) = freeMemoryPointer_safeTransferFrom_asm_0 + 36\n\t\t\tTMP_22(address) = to & 1461501637330902918203684832716283019655932542975\n\t\t\tTMP_23(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_21,TMP_22)\n\t\tExpression: mstore(uint256,uint256)(freeMemoryPointer_safeTransferFrom_asm_0 + 68,value)\n\t\tIRs:\n\t\t\tTMP_24(uint256) = freeMemoryPointer_safeTransferFrom_asm_0 + 68\n\t\t\tTMP_25(None) = SOLIDITY_CALL mstore(uint256,uint256)(TMP_24,value)\n\t\tExpression: ! call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(gas()(),token,0,freeMemoryPointer_safeTransferFrom_asm_0,100,0,0)\n\t\tIRs:\n\t\t\tTMP_26(uint256) = SOLIDITY_CALL gas()()\n\t\t\tTMP_27(uint256) = SOLIDITY_CALL call(uint256,uint256,uint256,uint256,uint256,uint256,uint256)(TMP_26,token,0,freeMemoryPointer_safeTransferFrom_asm_0,100,0,0)\n\t\t\tTMP_28 = UnaryType.BANG TMP_27 \n\t\t\tCONDITION TMP_28\n\t\tExpression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_29(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_30(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_29)\n\t\tExpression: revert(uint256,uint256)(0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_31(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_32(None) = SOLIDITY_CALL revert(uint256,uint256)(0,TMP_31)\n\t\tExpression: require(bool,string)(getLastTransferResult(token),GPv2: failed transferFrom)\n\t\tIRs:\n\t\t\tTMP_33(bool) = INTERNAL_CALL, GPv2SafeERC20.getLastTransferResult(IERC20)(token)\n\t\t\tTMP_34(None) = SOLIDITY_CALL require(bool,string)(TMP_33,GPv2: failed transferFrom)\n\tFunction GPv2SafeERC20.getLastTransferResult(IERC20) (*)\n\t\tExpression: switch_expr_3538_1174_0_getLastTransferResult_asm_0 = returndatasize()()\n\t\tIRs:\n\t\t\tTMP_35(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tswitch_expr_3538_1174_0_getLastTransferResult_asm_0(uint256) := TMP_35(uint256)\n\t\tExpression: switch_expr_3538_1174_0_getLastTransferResult_asm_0 == 0\n\t\tIRs:\n\t\t\tTMP_36(bool) = switch_expr_3538_1174_0_getLastTransferResult_asm_0 == 0\n\t\t\tCONDITION TMP_36\n\t\tExpression: ! extcodesize(uint256)(token)\n\t\tIRs:\n\t\t\tREF_4(None) -> token.codesize\n\t\t\tTMP_37 = UnaryType.BANG REF_4 \n\t\t\tCONDITION TMP_37\n\t\tExpression: revertWithMessage(20,GPv2: not a contract)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, GPv2SafeERC20.getLastTransferResult.asm_0.revertWithMessage()(20,GPv2: not a contract)\n\t\tExpression: success = 1\n\t\tIRs:\n\t\t\tsuccess(bool) := 1(uint256)\n\t\tExpression: switch_expr_3538_1174_0_getLastTransferResult_asm_0 == 32\n\t\tIRs:\n\t\t\tTMP_39(bool) = switch_expr_3538_1174_0_getLastTransferResult_asm_0 == 32\n\t\t\tCONDITION TMP_39\n\t\tExpression: returndatacopy(uint256,uint256,uint256)(0,0,returndatasize()())\n\t\tIRs:\n\t\t\tTMP_40(uint256) = SOLIDITY_CALL returndatasize()()\n\t\t\tTMP_41(None) = SOLIDITY_CALL returndatacopy(uint256,uint256,uint256)(0,0,TMP_40)\n\t\tExpression: success = ! ! mload(uint256)(0)\n\t\tIRs:\n\t\t\tTMP_42(uint256) = SOLIDITY_CALL mload(uint256)(0)\n\t\t\tTMP_43 = UnaryType.BANG TMP_42 \n\t\t\tTMP_44 = UnaryType.BANG TMP_43 \n\t\t\tsuccess(bool) := TMP_44(uint256)\n\t\tExpression: revertWithMessage(31,GPv2: malformed transfer result)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, GPv2SafeERC20.getLastTransferResult.asm_0.revertWithMessage()(31,GPv2: malformed transfer result)\n\t\tExpression: success\n\t\tIRs:\n\t\t\tRETURN success\n\tFunction GPv2SafeERC20.getLastTransferResult.asm_0.revertWithMessage() (*)\n\t\tExpression: mstore(uint256,uint256)(0x00,08c379a0)\n\t\tIRs:\n\t\t\tTMP_46(None) = SOLIDITY_CALL mstore(uint256,uint256)(0,08c379a0)\n\t\tExpression: mstore(uint256,uint256)(0x04,0x20)\n\t\tIRs:\n\t\t\tTMP_47(None) = SOLIDITY_CALL mstore(uint256,uint256)(4,32)\n\t\tExpression: mstore(uint256,uint256)(0x24,length_getLastTransferResult_asm_0_revertWithMessage)\n\t\tIRs:\n\t\t\tTMP_48(None) = SOLIDITY_CALL mstore(uint256,uint256)(36,length_getLastTransferResult_asm_0_revertWithMessage)\n\t\tExpression: mstore(uint256,uint256)(0x44,message_getLastTransferResult_asm_0_revertWithMessage)\n\t\tIRs:\n\t\t\tTMP_49(None) = SOLIDITY_CALL mstore(uint256,uint256)(68,message_getLastTransferResult_asm_0_revertWithMessage)\n\t\tExpression: revert(uint256,uint256)(0x00,0x64)\n\t\tIRs:\n\t\t\tTMP_50(None) = SOLIDITY_CALL revert(uint256,uint256)(0,100)\nContract Address\n\tFunction Address.isContract(address) (*)\n\t\tExpression: size = extcodesize(uint256)(account)\n\t\tIRs:\n\t\t\tREF_5 -> CODESIZE account\n\t\t\tsize(uint256) := REF_5(uint256)\n\t\tExpression: size > 0\n\t\tIRs:\n\t\t\tTMP_51(bool) = size > 0\n\t\t\tRETURN TMP_51\n\tFunction Address.sendValue(address,uint256) (*)\n\t\tExpression: require(bool,string)(address(this).balance >= amount,Address: insufficient balance)\n\t\tIRs:\n\t\t\tTMP_52 = CONVERT this to address\n\t\t\tTMP_53(uint256) = SOLIDITY_CALL balance(address)(TMP_52)\n\t\t\tTMP_54(bool) = TMP_53 >= amount\n\t\t\tTMP_55(None) = SOLIDITY_CALL require(bool,string)(TMP_54,Address: insufficient balance)\n\t\tExpression: (success,None) = recipient.call{value: amount}()\n\t\tIRs:\n\t\t\tTUPLE_0(bool,bytes) = LOW_LEVEL_CALL, dest:recipient, function:call, arguments:[''] value:amount \n\t\t\tsuccess(bool)= UNPACK TUPLE_0 index: 0 \n\t\tExpression: require(bool,string)(success,Address: unable to send value, recipient may have reverted)\n\t\tIRs:\n\t\t\tTMP_56(None) = SOLIDITY_CALL require(bool,string)(success,Address: unable to send value, recipient may have reverted)\n\tFunction Address.functionCall(address,bytes) (*)\n\t\tExpression: functionCall(target,data,Address: low-level call failed)\n\t\tIRs:\n\t\t\tTMP_57(bytes) = INTERNAL_CALL, Address.functionCall(address,bytes,string)(target,data,Address: low-level call failed)\n\t\t\tRETURN TMP_57\n\tFunction Address.functionCall(address,bytes,string) (*)\n\t\tExpression: functionCallWithValue(target,data,0,errorMessage)\n\t\tIRs:\n\t\t\tTMP_58(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,0,errorMessage)\n\t\t\tRETURN TMP_58\n\tFunction Address.functionCallWithValue(address,bytes,uint256) (*)\n\t\tExpression: functionCallWithValue(target,data,value,Address: low-level call with value failed)\n\t\tIRs:\n\t\t\tTMP_59(bytes) = INTERNAL_CALL, Address.functionCallWithValue(address,bytes,uint256,string)(target,data,value,Address: low-level call with value failed)\n\t\t\tRETURN TMP_59\n\tFunction Address.functionCallWithValue(address,bytes,uint256,string) (*)\n\t\tExpression: require(bool,string)(address(this).balance >= value,Address: insufficient balance for call)\n\t\tIRs:\n\t\t\tTMP_60 = CONVERT this to address\n\t\t\tTMP_61(uint256) = SOLIDITY_CALL balance(address)(TMP_60)\n\t\t\tTMP_62(bool) = TMP_61 >= value\n\t\t\tTMP_63(None) = SOLIDITY_CALL require(bool,string)(TMP_62,Address: insufficient balance for call)\n\t\tExpression: require(bool,string)(isContract(target),Address: call to non-contract)\n\t\tIRs:\n\t\t\tTMP_64(bool) = INTERNAL_CALL, Address.isContract(address)(target)\n\t\t\tTMP_65(None) = SOLIDITY_CALL require(bool,string)(TMP_64,Address: call to non-contract)\n\t\tExpression: (success,returndata) = target.call{value: value}(data)\n\t\tIRs:\n\t\t\tTUPLE_1(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:value \n\t\t\tsuccess(bool)= UNPACK TUPLE_1 index: 0 \n\t\t\treturndata(bytes)= UNPACK TUPLE_1 index: 1 \n\t\tExpression: verifyCallResult(success,returndata,errorMessage)\n\t\tIRs:\n\t\t\tTMP_66(bytes) = INTERNAL_CALL, Address.verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)\n\t\t\tRETURN TMP_66\n\tFunction Address.functionStaticCall(address,bytes) (*)\n\t\tExpression: functionStaticCall(target,data,Address: low-level static call failed)\n\t\tIRs:\n\t\t\tTMP_67(bytes) = INTERNAL_CALL, Address.functionStaticCall(address,bytes,string)(target,data,Address: low-level static call failed)\n\t\t\tRETURN TMP_67\n\tFunction Address.functionStaticCall(address,bytes,string) (*)\n\t\tExpression: require(bool,string)(isContract(target),Address: static call to non-contract)\n\t\tIRs:\n\t\t\tTMP_68(bool) = INTERNAL_CALL, Address.isContract(address)(target)\n\t\t\tTMP_69(None) = SOLIDITY_CALL require(bool,string)(TMP_68,Address: static call to non-contract)\n\t\tExpression: (success,returndata) = target.staticcall(data)\n\t\tIRs:\n\t\t\tTUPLE_2(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:staticcall, arguments:['data']  \n\t\t\tsuccess(bool)= UNPACK TUPLE_2 index: 0 \n\t\t\treturndata(bytes)= UNPACK TUPLE_2 index: 1 \n\t\tExpression: verifyCallResult(success,returndata,errorMessage)\n\t\tIRs:\n\t\t\tTMP_70(bytes) = INTERNAL_CALL, Address.verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)\n\t\t\tRETURN TMP_70\n\tFunction Address.functionDelegateCall(address,bytes) (*)\n\t\tExpression: functionDelegateCall(target,data,Address: low-level delegate call failed)\n\t\tIRs:\n\t\t\tTMP_71(bytes) = INTERNAL_CALL, Address.functionDelegateCall(address,bytes,string)(target,data,Address: low-level delegate call failed)\n\t\t\tRETURN TMP_71\n\tFunction Address.functionDelegateCall(address,bytes,string) (*)\n\t\tExpression: require(bool,string)(isContract(target),Address: delegate call to non-contract)\n\t\tIRs:\n\t\t\tTMP_72(bool) = INTERNAL_CALL, Address.isContract(address)(target)\n\t\t\tTMP_73(None) = SOLIDITY_CALL require(bool,string)(TMP_72,Address: delegate call to non-contract)\n\t\tExpression: (success,returndata) = target.delegatecall(data)\n\t\tIRs:\n\t\t\tTUPLE_3(bool,bytes) = LOW_LEVEL_CALL, dest:target, function:delegatecall, arguments:['data']  \n\t\t\tsuccess(bool)= UNPACK TUPLE_3 index: 0 \n\t\t\treturndata(bytes)= UNPACK TUPLE_3 index: 1 \n\t\tExpression: verifyCallResult(success,returndata,errorMessage)\n\t\tIRs:\n\t\t\tTMP_74(bytes) = INTERNAL_CALL, Address.verifyCallResult(bool,bytes,string)(success,returndata,errorMessage)\n\t\t\tRETURN TMP_74\n\tFunction Address.verifyCallResult(bool,bytes,string) (*)\n\t\tExpression: success\n\t\tIRs:\n\t\t\tCONDITION success\n\t\tExpression: returndata\n\t\tIRs:\n\t\t\tRETURN returndata\n\t\tExpression: returndata.length > 0\n\t\tIRs:\n\t\t\tREF_10 -> LENGTH returndata\n\t\t\tTMP_75(bool) = REF_10 > 0\n\t\t\tCONDITION TMP_75\n\t\tExpression: returndata_size_verifyCallResult_asm_0 = mload(uint256)(returndata)\n\t\tIRs:\n\t\t\tTMP_76(uint256) = SOLIDITY_CALL mload(uint256)(returndata)\n\t\t\treturndata_size_verifyCallResult_asm_0(uint256) := TMP_76(uint256)\n\t\tExpression: revert(uint256,uint256)(32 + returndata,returndata_size_verifyCallResult_asm_0)\n\t\tIRs:\n\t\t\tTMP_77(uint256) = 32 + returndata\n\t\t\tTMP_78(None) = SOLIDITY_CALL revert(uint256,uint256)(TMP_77,returndata_size_verifyCallResult_asm_0)\n\t\tExpression: revert(string)(errorMessage)\n\t\tIRs:\n\t\t\tTMP_79(None) = SOLIDITY_CALL revert(string)(errorMessage)\nContract Context\n\tFunction Context._msgSender() (*)\n\t\tExpression: address(msg.sender)\n\t\tIRs:\n\t\t\tTMP_80 = CONVERT msg.sender to address\n\t\t\tRETURN TMP_80\n\tFunction Context._msgData() (*)\n\t\tExpression: this\n\t\tIRs:\n\t\tExpression: msg.data\n\t\tIRs:\n\t\t\tRETURN msg.data\nContract IAccessControl\n\tFunction IAccessControl.hasRole(bytes32,address) (*)\n\tFunction IAccessControl.getRoleAdmin(bytes32) (*)\n\tFunction IAccessControl.grantRole(bytes32,address) (*)\n\tFunction IAccessControl.revokeRole(bytes32,address) (*)\n\tFunction IAccessControl.renounceRole(bytes32,address) (*)\nContract IERC20\n\tFunction IERC20.totalSupply() (*)\n\tFunction IERC20.balanceOf(address) (*)\n\tFunction IERC20.transfer(address,uint256) (*)\n\tFunction IERC20.allowance(address,address) (*)\n\tFunction IERC20.approve(address,uint256) (*)\n\tFunction IERC20.transferFrom(address,address,uint256) (*)\nContract IERC20Detailed\n\tFunction IERC20.totalSupply() (*)\n\tFunction IERC20.balanceOf(address) (*)\n\tFunction IERC20.transfer(address,uint256) (*)\n\tFunction IERC20.allowance(address,address) (*)\n\tFunction IERC20.approve(address,uint256) (*)\n\tFunction IERC20.transferFrom(address,address,uint256) (*)\n\tFunction IERC20Detailed.name() (*)\n\tFunction IERC20Detailed.symbol() (*)\n\tFunction IERC20Detailed.decimals() (*)\nContract SafeCast\n\tFunction SafeCast.toUint224(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint224).max,SafeCast: value doesn't fit in 224 bits)\n\t\tIRs:\n\t\t\tTMP_82(uint224) := 26959946667150639794667015087019630673637144422540572481103610249215(uint224)\n\t\t\tTMP_83(bool) = value <= TMP_82\n\t\t\tTMP_84(None) = SOLIDITY_CALL require(bool,string)(TMP_83,SafeCast: value doesn't fit in 224 bits)\n\t\tExpression: uint224(value)\n\t\tIRs:\n\t\t\tTMP_85 = CONVERT value to uint224\n\t\t\tRETURN TMP_85\n\tFunction SafeCast.toUint128(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint128).max,SafeCast: value doesn't fit in 128 bits)\n\t\tIRs:\n\t\t\tTMP_87(uint128) := 340282366920938463463374607431768211455(uint128)\n\t\t\tTMP_88(bool) = value <= TMP_87\n\t\t\tTMP_89(None) = SOLIDITY_CALL require(bool,string)(TMP_88,SafeCast: value doesn't fit in 128 bits)\n\t\tExpression: uint128(value)\n\t\tIRs:\n\t\t\tTMP_90 = CONVERT value to uint128\n\t\t\tRETURN TMP_90\n\tFunction SafeCast.toUint96(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint96).max,SafeCast: value doesn't fit in 96 bits)\n\t\tIRs:\n\t\t\tTMP_92(uint96) := 79228162514264337593543950335(uint96)\n\t\t\tTMP_93(bool) = value <= TMP_92\n\t\t\tTMP_94(None) = SOLIDITY_CALL require(bool,string)(TMP_93,SafeCast: value doesn't fit in 96 bits)\n\t\tExpression: uint96(value)\n\t\tIRs:\n\t\t\tTMP_95 = CONVERT value to uint96\n\t\t\tRETURN TMP_95\n\tFunction SafeCast.toUint64(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint64).max,SafeCast: value doesn't fit in 64 bits)\n\t\tIRs:\n\t\t\tTMP_97(uint64) := 18446744073709551615(uint64)\n\t\t\tTMP_98(bool) = value <= TMP_97\n\t\t\tTMP_99(None) = SOLIDITY_CALL require(bool,string)(TMP_98,SafeCast: value doesn't fit in 64 bits)\n\t\tExpression: uint64(value)\n\t\tIRs:\n\t\t\tTMP_100 = CONVERT value to uint64\n\t\t\tRETURN TMP_100\n\tFunction SafeCast.toUint32(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint32).max,SafeCast: value doesn't fit in 32 bits)\n\t\tIRs:\n\t\t\tTMP_102(uint32) := 4294967295(uint32)\n\t\t\tTMP_103(bool) = value <= TMP_102\n\t\t\tTMP_104(None) = SOLIDITY_CALL require(bool,string)(TMP_103,SafeCast: value doesn't fit in 32 bits)\n\t\tExpression: uint32(value)\n\t\tIRs:\n\t\t\tTMP_105 = CONVERT value to uint32\n\t\t\tRETURN TMP_105\n\tFunction SafeCast.toUint16(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint16).max,SafeCast: value doesn't fit in 16 bits)\n\t\tIRs:\n\t\t\tTMP_107(uint16) := 65535(uint16)\n\t\t\tTMP_108(bool) = value <= TMP_107\n\t\t\tTMP_109(None) = SOLIDITY_CALL require(bool,string)(TMP_108,SafeCast: value doesn't fit in 16 bits)\n\t\tExpression: uint16(value)\n\t\tIRs:\n\t\t\tTMP_110 = CONVERT value to uint16\n\t\t\tRETURN TMP_110\n\tFunction SafeCast.toUint8(uint256) (*)\n\t\tExpression: require(bool,string)(value <= type()(uint8).max,SafeCast: value doesn't fit in 8 bits)\n\t\tIRs:\n\t\t\tTMP_112(uint8) := 255(uint8)\n\t\t\tTMP_113(bool) = value <= TMP_112\n\t\t\tTMP_114(None) = SOLIDITY_CALL require(bool,string)(TMP_113,SafeCast: value doesn't fit in 8 bits)\n\t\tExpression: uint8(value)\n\t\tIRs:\n\t\t\tTMP_115 = CONVERT value to uint8\n\t\t\tRETURN TMP_115\n\tFunction SafeCast.toUint256(int256) (*)\n\t\tExpression: require(bool,string)(value >= 0,SafeCast: value must be positive)\n\t\tIRs:\n\t\t\tTMP_116(bool) = value >= 0\n\t\t\tTMP_117(None) = SOLIDITY_CALL require(bool,string)(TMP_116,SafeCast: value must be positive)\n\t\tExpression: uint256(value)\n\t\tIRs:\n\t\t\tTMP_118 = CONVERT value to uint256\n\t\t\tRETURN TMP_118\n\tFunction SafeCast.toInt128(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int128).min && value <= type()(int128).max,SafeCast: value doesn't fit in 128 bits)\n\t\tIRs:\n\t\t\tTMP_120(int128) := -170141183460469231731687303715884105728(int128)\n\t\t\tTMP_121(bool) = value >= TMP_120\n\t\t\tTMP_123(int128) := 170141183460469231731687303715884105727(int128)\n\t\t\tTMP_124(bool) = value <= TMP_123\n\t\t\tTMP_125(bool) = TMP_121 && TMP_124\n\t\t\tTMP_126(None) = SOLIDITY_CALL require(bool,string)(TMP_125,SafeCast: value doesn't fit in 128 bits)\n\t\tExpression: int128(value)\n\t\tIRs:\n\t\t\tTMP_127 = CONVERT value to int128\n\t\t\tRETURN TMP_127\n\tFunction SafeCast.toInt64(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int64).min && value <= type()(int64).max,SafeCast: value doesn't fit in 64 bits)\n\t\tIRs:\n\t\t\tTMP_129(int64) := -9223372036854775808(int64)\n\t\t\tTMP_130(bool) = value >= TMP_129\n\t\t\tTMP_132(int64) := 9223372036854775807(int64)\n\t\t\tTMP_133(bool) = value <= TMP_132\n\t\t\tTMP_134(bool) = TMP_130 && TMP_133\n\t\t\tTMP_135(None) = SOLIDITY_CALL require(bool,string)(TMP_134,SafeCast: value doesn't fit in 64 bits)\n\t\tExpression: int64(value)\n\t\tIRs:\n\t\t\tTMP_136 = CONVERT value to int64\n\t\t\tRETURN TMP_136\n\tFunction SafeCast.toInt32(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int32).min && value <= type()(int32).max,SafeCast: value doesn't fit in 32 bits)\n\t\tIRs:\n\t\t\tTMP_138(int32) := -2147483648(int32)\n\t\t\tTMP_139(bool) = value >= TMP_138\n\t\t\tTMP_141(int32) := 2147483647(int32)\n\t\t\tTMP_142(bool) = value <= TMP_141\n\t\t\tTMP_143(bool) = TMP_139 && TMP_142\n\t\t\tTMP_144(None) = SOLIDITY_CALL require(bool,string)(TMP_143,SafeCast: value doesn't fit in 32 bits)\n\t\tExpression: int32(value)\n\t\tIRs:\n\t\t\tTMP_145 = CONVERT value to int32\n\t\t\tRETURN TMP_145\n\tFunction SafeCast.toInt16(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int16).min && value <= type()(int16).max,SafeCast: value doesn't fit in 16 bits)\n\t\tIRs:\n\t\t\tTMP_147(int16) := -32768(int16)\n\t\t\tTMP_148(bool) = value >= TMP_147\n\t\t\tTMP_150(int16) := 32767(int16)\n\t\t\tTMP_151(bool) = value <= TMP_150\n\t\t\tTMP_152(bool) = TMP_148 && TMP_151\n\t\t\tTMP_153(None) = SOLIDITY_CALL require(bool,string)(TMP_152,SafeCast: value doesn't fit in 16 bits)\n\t\tExpression: int16(value)\n\t\tIRs:\n\t\t\tTMP_154 = CONVERT value to int16\n\t\t\tRETURN TMP_154\n\tFunction SafeCast.toInt8(int256) (*)\n\t\tExpression: require(bool,string)(value >= type()(int8).min && value <= type()(int8).max,SafeCast: value doesn't fit in 8 bits)\n\t\tIRs:\n\t\t\tTMP_156(int8) := -128(int8)\n\t\t\tTMP_157(bool) = value >= TMP_156\n\t\t\tTMP_159(int8) := 127(int8)\n\t\t\tTMP_160(bool) = value <= TMP_159\n\t\t\tTMP_161(bool) = TMP_157 && TMP_160\n\t\t\tTMP_162(None) = SOLIDITY_CALL require(bool,string)(TMP_161,SafeCast: value doesn't fit in 8 bits)\n\t\tExpression: int8(value)\n\t\tIRs:\n\t\t\tTMP_163 = CONVERT value to int8\n\t\t\tRETURN TMP_163\n\tFunction SafeCast.toInt256(uint256) (*)\n\t\tExpression: require(bool,string)(value <= uint256(type()(int256).max),SafeCast: value doesn't fit in an int256)\n\t\tIRs:\n\t\t\tTMP_165(int256) := 57896044618658097711785492504343953926634992332820282019728792003956564819967(int256)\n\t\t\tTMP_166 = CONVERT TMP_165 to uint256\n\t\t\tTMP_167(bool) = value <= TMP_166\n\t\t\tTMP_168(None) = SOLIDITY_CALL require(bool,string)(TMP_167,SafeCast: value doesn't fit in an int256)\n\t\tExpression: int256(value)\n\t\tIRs:\n\t\t\tTMP_169 = CONVERT value to int256\n\t\t\tRETURN TMP_169\nContract IFlashLoanReceiver\n\tFunction IFlashLoanReceiver.executeOperation(address[],uint256[],uint256[],address,bytes) (*)\n\tFunction IFlashLoanReceiver.ADDRESSES_PROVIDER() (*)\n\tFunction IFlashLoanReceiver.POOL() (*)\nContract IFlashLoanSimpleReceiver\n\tFunction IFlashLoanSimpleReceiver.executeOperation(address,uint256,uint256,address,bytes) (*)\n\tFunction IFlashLoanSimpleReceiver.ADDRESSES_PROVIDER() (*)\n\tFunction IFlashLoanSimpleReceiver.POOL() (*)\nContract IACLManager\n\tFunction IACLManager.ADDRESSES_PROVIDER() (*)\n\tFunction IACLManager.POOL_ADMIN_ROLE() (*)\n\tFunction IACLManager.EMERGENCY_ADMIN_ROLE() (*)\n\tFunction IACLManager.RISK_ADMIN_ROLE() (*)\n\tFunction IACLManager.FLASH_BORROWER_ROLE() (*)\n\tFunction IACLManager.BRIDGE_ROLE() (*)\n\tFunction IACLManager.ASSET_LISTING_ADMIN_ROLE() (*)\n\tFunction IACLManager.setRoleAdmin(bytes32,bytes32) (*)\n\tFunction IACLManager.addPoolAdmin(address) (*)\n\tFunction IACLManager.removePoolAdmin(address) (*)\n\tFunction IACLManager.isPoolAdmin(address) (*)\n\tFunction IACLManager.addEmergencyAdmin(address) (*)\n\tFunction IACLManager.removeEmergencyAdmin(address) (*)\n\tFunction IACLManager.isEmergencyAdmin(address) (*)\n\tFunction IACLManager.addRiskAdmin(address) (*)\n\tFunction IACLManager.removeRiskAdmin(address) (*)\n\tFunction IACLManager.isRiskAdmin(address) (*)\n\tFunction IACLManager.addFlashBorrower(address) (*)\n\tFunction IACLManager.removeFlashBorrower(address) (*)\n\tFunction IACLManager.isFlashBorrower(address) (*)\n\tFunction IACLManager.addBridge(address) (*)\n\tFunction IACLManager.removeBridge(address) (*)\n\tFunction IACLManager.isBridge(address) (*)\n\tFunction IACLManager.addAssetListingAdmin(address) (*)\n\tFunction IACLManager.removeAssetListingAdmin(address) (*)\n\tFunction IACLManager.isAssetListingAdmin(address) (*)\nContract IAToken\n\tFunction IInitializableAToken.initialize(IPool,address,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\n\tFunction IScaledBalanceToken.scaledBalanceOf(address) (*)\n\tFunction IScaledBalanceToken.getScaledUserBalanceAndSupply(address) (*)\n\tFunction IScaledBalanceToken.scaledTotalSupply() (*)\n\tFunction IScaledBalanceToken.getPreviousIndex(address) (*)\n\tFunction IERC20.totalSupply() (*)\n\tFunction IERC20.balanceOf(address) (*)\n\tFunction IERC20.transfer(address,uint256) (*)\n\tFunction IERC20.allowance(address,address) (*)\n\tFunction IERC20.approve(address,uint256) (*)\n\tFunction IERC20.transferFrom(address,address,uint256) (*)\n\tFunction IAToken.mint(address,address,uint256,uint256) (*)\n\tFunction IAToken.burn(address,address,uint256,uint256) (*)\n\tFunction IAToken.mintToTreasury(uint256,uint256) (*)\n\tFunction IAToken.transferOnLiquidation(address,address,uint256) (*)\n\tFunction IAToken.transferUnderlyingTo(address,uint256) (*)\n\tFunction IAToken.handleRepayment(address,address,uint256) (*)\n\tFunction IAToken.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)\n\tFunction IAToken.UNDERLYING_ASSET_ADDRESS() (*)\n\tFunction IAToken.RESERVE_TREASURY_ADDRESS() (*)\n\tFunction IAToken.DOMAIN_SEPARATOR() (*)\n\tFunction IAToken.nonces(address) (*)\n\tFunction IAToken.rescueTokens(address,address,uint256) (*)\nContract IAaveIncentivesController\n\tFunction IAaveIncentivesController.handleAction(address,uint256,uint256) (*)\nContract IERC20WithPermit\n\tFunction IERC20.totalSupply() (*)\n\tFunction IERC20.balanceOf(address) (*)\n\tFunction IERC20.transfer(address,uint256) (*)\n\tFunction IERC20.allowance(address,address) (*)\n\tFunction IERC20.approve(address,uint256) (*)\n\tFunction IERC20.transferFrom(address,address,uint256) (*)\n\tFunction IERC20WithPermit.permit(address,address,uint256,uint256,uint8,bytes32,bytes32) (*)\nContract IInitializableAToken\n\tFunction IInitializableAToken.initialize(IPool,address,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\nContract IInitializableDebtToken\n\tFunction IInitializableDebtToken.initialize(IPool,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\nContract IPool\n\tFunction IPool.mintUnbacked(address,uint256,address,uint16) (*)\n\tFunction IPool.backUnbacked(address,uint256,uint256) (*)\n\tFunction IPool.supply(address,uint256,address,uint16) (*)\n\tFunction IPool.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) (*)\n\tFunction IPool.withdraw(address,uint256,address) (*)\n\tFunction IPool.borrow(address,uint256,uint256,uint16,address) (*)\n\tFunction IPool.repay(address,uint256,uint256,address) (*)\n\tFunction IPool.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) (*)\n\tFunction IPool.repayWithATokens(address,uint256,uint256) (*)\n\tFunction IPool.swapBorrowRateMode(address,uint256) (*)\n\tFunction IPool.rebalanceStableBorrowRate(address,address) (*)\n\tFunction IPool.setUserUseReserveAsCollateral(address,bool) (*)\n\tFunction IPool.liquidationCall(address,address,address,uint256,bool) (*)\n\tFunction IPool.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) (*)\n\tFunction IPool.flashLoanSimple(address,address,uint256,bytes,uint16) (*)\n\tFunction IPool.getUserAccountData(address) (*)\n\tFunction IPool.initReserve(address,address,address,address,address) (*)\n\tFunction IPool.dropReserve(address) (*)\n\tFunction IPool.setReserveInterestRateStrategyAddress(address,address) (*)\n\tFunction IPool.setConfiguration(address,DataTypes.ReserveConfigurationMap) (*)\n\tFunction IPool.getConfiguration(address) (*)\n\tFunction IPool.getUserConfiguration(address) (*)\n\tFunction IPool.getReserveNormalizedIncome(address) (*)\n\tFunction IPool.getReserveNormalizedVariableDebt(address) (*)\n\tFunction IPool.getReserveData(address) (*)\n\tFunction IPool.finalizeTransfer(address,address,address,uint256,uint256,uint256) (*)\n\tFunction IPool.getReservesList() (*)\n\tFunction IPool.getReserveAddressById(uint16) (*)\n\tFunction IPool.ADDRESSES_PROVIDER() (*)\n\tFunction IPool.updateBridgeProtocolFee(uint256) (*)\n\tFunction IPool.updateFlashloanPremiums(uint128,uint128) (*)\n\tFunction IPool.configureEModeCategory(uint8,DataTypes.EModeCategory) (*)\n\tFunction IPool.getEModeCategoryData(uint8) (*)\n\tFunction IPool.setUserEMode(uint8) (*)\n\tFunction IPool.getUserEMode(address) (*)\n\tFunction IPool.resetIsolationModeTotalDebt(address) (*)\n\tFunction IPool.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() (*)\n\tFunction IPool.FLASHLOAN_PREMIUM_TOTAL() (*)\n\tFunction IPool.BRIDGE_PROTOCOL_FEE() (*)\n\tFunction IPool.FLASHLOAN_PREMIUM_TO_PROTOCOL() (*)\n\tFunction IPool.MAX_NUMBER_RESERVES() (*)\n\tFunction IPool.mintToTreasury(address[]) (*)\n\tFunction IPool.rescueTokens(address,address,uint256) (*)\n\tFunction IPool.deposit(address,uint256,address,uint16) (*)\nContract IPoolAddressesProvider\n\tFunction IPoolAddressesProvider.getMarketId() (*)\n\tFunction IPoolAddressesProvider.setMarketId(string) (*)\n\tFunction IPoolAddressesProvider.getAddress(bytes32) (*)\n\tFunction IPoolAddressesProvider.setAddressAsProxy(bytes32,address) (*)\n\tFunction IPoolAddressesProvider.setAddress(bytes32,address) (*)\n\tFunction IPoolAddressesProvider.getPool() (*)\n\tFunction IPoolAddressesProvider.setPoolImpl(address) (*)\n\tFunction IPoolAddressesProvider.getPoolConfigurator() (*)\n\tFunction IPoolAddressesProvider.setPoolConfiguratorImpl(address) (*)\n\tFunction IPoolAddressesProvider.getPriceOracle() (*)\n\tFunction IPoolAddressesProvider.setPriceOracle(address) (*)\n\tFunction IPoolAddressesProvider.getACLManager() (*)\n\tFunction IPoolAddressesProvider.setACLManager(address) (*)\n\tFunction IPoolAddressesProvider.getACLAdmin() (*)\n\tFunction IPoolAddressesProvider.setACLAdmin(address) (*)\n\tFunction IPoolAddressesProvider.getPriceOracleSentinel() (*)\n\tFunction IPoolAddressesProvider.setPriceOracleSentinel(address) (*)\n\tFunction IPoolAddressesProvider.getPoolDataProvider() (*)\n\tFunction IPoolAddressesProvider.setPoolDataProvider(address) (*)\nContract IPriceOracleGetter\n\tFunction IPriceOracleGetter.BASE_CURRENCY() (*)\n\tFunction IPriceOracleGetter.BASE_CURRENCY_UNIT() (*)\n\tFunction IPriceOracleGetter.getAssetPrice(address) (*)\nContract IPriceOracleSentinel\n\tFunction IPriceOracleSentinel.ADDRESSES_PROVIDER() (*)\n\tFunction IPriceOracleSentinel.isBorrowAllowed() (*)\n\tFunction IPriceOracleSentinel.isLiquidationAllowed() (*)\n\tFunction IPriceOracleSentinel.setSequencerOracle(address) (*)\n\tFunction IPriceOracleSentinel.setGracePeriod(uint256) (*)\n\tFunction IPriceOracleSentinel.getSequencerOracle() (*)\n\tFunction IPriceOracleSentinel.getGracePeriod() (*)\nContract IReserveInterestRateStrategy\n\tFunction IReserveInterestRateStrategy.calculateInterestRates(DataTypes.CalculateInterestRatesParams) (*)\nContract IScaledBalanceToken\n\tFunction IScaledBalanceToken.scaledBalanceOf(address) (*)\n\tFunction IScaledBalanceToken.getScaledUserBalanceAndSupply(address) (*)\n\tFunction IScaledBalanceToken.scaledTotalSupply() (*)\n\tFunction IScaledBalanceToken.getPreviousIndex(address) (*)\nContract IStableDebtToken\n\tFunction IInitializableDebtToken.initialize(IPool,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\n\tFunction IStableDebtToken.mint(address,address,uint256,uint256) (*)\n\tFunction IStableDebtToken.burn(address,uint256) (*)\n\tFunction IStableDebtToken.getAverageStableRate() (*)\n\tFunction IStableDebtToken.getUserStableRate(address) (*)\n\tFunction IStableDebtToken.getUserLastUpdated(address) (*)\n\tFunction IStableDebtToken.getSupplyData() (*)\n\tFunction IStableDebtToken.getTotalSupplyLastUpdated() (*)\n\tFunction IStableDebtToken.getTotalSupplyAndAvgRate() (*)\n\tFunction IStableDebtToken.principalBalanceOf(address) (*)\n\tFunction IStableDebtToken.UNDERLYING_ASSET_ADDRESS() (*)\nContract IVariableDebtToken\n\tFunction IInitializableDebtToken.initialize(IPool,address,IAaveIncentivesController,uint8,string,string,bytes) (*)\n\tFunction IScaledBalanceToken.scaledBalanceOf(address) (*)\n\tFunction IScaledBalanceToken.getScaledUserBalanceAndSupply(address) (*)\n\tFunction IScaledBalanceToken.scaledTotalSupply() (*)\n\tFunction IScaledBalanceToken.getPreviousIndex(address) (*)\n\tFunction IVariableDebtToken.mint(address,address,uint256,uint256) (*)\n\tFunction IVariableDebtToken.burn(address,uint256,uint256) (*)\n\tFunction IVariableDebtToken.UNDERLYING_ASSET_ADDRESS() (*)\nContract VersionedInitializable\n\tFunction VersionedInitializable.getRevision() (*)\n\tFunction VersionedInitializable.isConstructor() (*)\n\t\tExpression: cs = extcodesize(uint256)(address()())\n\t\tIRs:\n\t\t\tTMP_170 = CONVERT this to address\n\t\t\tREF_11 -> CODESIZE TMP_170\n\t\t\tcs(uint256) := REF_11(uint256)\n\t\tExpression: cs == 0\n\t\tIRs:\n\t\t\tTMP_171(bool) = cs == 0\n\t\t\tRETURN TMP_171\n\tFunction VersionedInitializable.slitherConstructorVariables() (*)\n\t\tExpression: lastInitializedRevision = 0\n\t\tIRs:\n\t\t\tlastInitializedRevision(uint256) := 0(uint256)\n\tModifier VersionedInitializable.initializer()\n\t\tExpression: revision = getRevision()\n\t\tIRs:\n\t\t\tTMP_172(uint256) = INTERNAL_CALL, VersionedInitializable.getRevision()()\n\t\t\trevision(uint256) := TMP_172(uint256)\n\t\tExpression: require(bool,string)(initializing || isConstructor() || revision > lastInitializedRevision,Contract instance has already been initialized)\n\t\tIRs:\n\t\t\tTMP_173(bool) = INTERNAL_CALL, VersionedInitializable.isConstructor()()\n\t\t\tTMP_174(bool) = initializing || TMP_173\n\t\t\tTMP_175(bool) = revision > lastInitializedRevision\n\t\t\tTMP_176(bool) = TMP_174 || TMP_175\n\t\t\tTMP_177(None) = SOLIDITY_CALL require(bool,string)(TMP_176,Contract instance has already been initialized)\n\t\tExpression: isTopLevelCall = ! initializing\n\t\tIRs:\n\t\t\tTMP_178 = UnaryType.BANG initializing \n\t\t\tisTopLevelCall(bool) := TMP_178(bool)\n\t\tExpression: isTopLevelCall\n\t\tIRs:\n\t\t\tCONDITION isTopLevelCall\n\t\tExpression: initializing = true\n\t\tIRs:\n\t\t\tinitializing(bool) := True(bool)\n\t\tExpression: lastInitializedRevision = revision\n\t\tIRs:\n\t\t\tlastInitializedRevision(uint256) := revision(uint256)\n\t\tExpression: isTopLevelCall\n\t\tIRs:\n\t\t\tCONDITION isTopLevelCall\n\t\tExpression: initializing = false\n\t\tIRs:\n\t\t\tinitializing(bool) := False(bool)\nContract ReserveConfiguration\n\tFunction ReserveConfiguration.setLtv(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(ltv <= MAX_VALID_LTV,Errors.INVALID_LTV)\n\t\tIRs:\n\t\t\tTMP_179(bool) = ltv <= MAX_VALID_LTV\n\t\t\tREF_12(string) -> Errors.INVALID_LTV\n\t\t\tTMP_180(None) = SOLIDITY_CALL require(bool,string)(TMP_179,REF_12)\n\t\tExpression: self.data = (self.data & LTV_MASK) | ltv\n\t\tIRs:\n\t\t\tREF_13(uint256) -> self.data\n\t\t\tREF_14(uint256) -> self.data\n\t\t\tTMP_181(uint256) = REF_14 & LTV_MASK\n\t\t\tTMP_182(uint256) = TMP_181 | ltv\n\t\t\tREF_13(uint256) (->self) := TMP_182(uint256)\n\tFunction ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: self.data & ~ LTV_MASK\n\t\tIRs:\n\t\t\tREF_15(uint256) -> self.data\n\t\t\tTMP_183 = UnaryType.TILD LTV_MASK \n\t\t\tTMP_184(uint256) = REF_15 & TMP_183\n\t\t\tRETURN TMP_184\n\tFunction ReserveConfiguration.setLiquidationThreshold(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD,Errors.INVALID_LIQ_THRESHOLD)\n\t\tIRs:\n\t\t\tTMP_185(bool) = threshold <= MAX_VALID_LIQUIDATION_THRESHOLD\n\t\t\tREF_16(string) -> Errors.INVALID_LIQ_THRESHOLD\n\t\t\tTMP_186(None) = SOLIDITY_CALL require(bool,string)(TMP_185,REF_16)\n\t\tExpression: self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_17(uint256) -> self.data\n\t\t\tREF_18(uint256) -> self.data\n\t\t\tTMP_187(uint256) = REF_18 & LIQUIDATION_THRESHOLD_MASK\n\t\t\tTMP_188(uint256) = threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION\n\t\t\tTMP_189(uint256) = TMP_187 | TMP_188\n\t\t\tREF_17(uint256) (->self) := TMP_189(uint256)\n\tFunction ReserveConfiguration.getLiquidationThreshold(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_19(uint256) -> self.data\n\t\t\tTMP_190 = UnaryType.TILD LIQUIDATION_THRESHOLD_MASK \n\t\t\tTMP_191(uint256) = REF_19 & TMP_190\n\t\t\tTMP_192(uint256) = TMP_191 >> LIQUIDATION_THRESHOLD_START_BIT_POSITION\n\t\t\tRETURN TMP_192\n\tFunction ReserveConfiguration.setLiquidationBonus(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(bonus <= MAX_VALID_LIQUIDATION_BONUS,Errors.INVALID_LIQ_BONUS)\n\t\tIRs:\n\t\t\tTMP_193(bool) = bonus <= MAX_VALID_LIQUIDATION_BONUS\n\t\t\tREF_20(string) -> Errors.INVALID_LIQ_BONUS\n\t\t\tTMP_194(None) = SOLIDITY_CALL require(bool,string)(TMP_193,REF_20)\n\t\tExpression: self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_21(uint256) -> self.data\n\t\t\tREF_22(uint256) -> self.data\n\t\t\tTMP_195(uint256) = REF_22 & LIQUIDATION_BONUS_MASK\n\t\t\tTMP_196(uint256) = bonus << LIQUIDATION_BONUS_START_BIT_POSITION\n\t\t\tTMP_197(uint256) = TMP_195 | TMP_196\n\t\t\tREF_21(uint256) (->self) := TMP_197(uint256)\n\tFunction ReserveConfiguration.getLiquidationBonus(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_23(uint256) -> self.data\n\t\t\tTMP_198 = UnaryType.TILD LIQUIDATION_BONUS_MASK \n\t\t\tTMP_199(uint256) = REF_23 & TMP_198\n\t\t\tTMP_200(uint256) = TMP_199 >> LIQUIDATION_BONUS_START_BIT_POSITION\n\t\t\tRETURN TMP_200\n\tFunction ReserveConfiguration.setDecimals(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(decimals <= MAX_VALID_DECIMALS,Errors.INVALID_DECIMALS)\n\t\tIRs:\n\t\t\tTMP_201(bool) = decimals <= MAX_VALID_DECIMALS\n\t\t\tREF_24(string) -> Errors.INVALID_DECIMALS\n\t\t\tTMP_202(None) = SOLIDITY_CALL require(bool,string)(TMP_201,REF_24)\n\t\tExpression: self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_25(uint256) -> self.data\n\t\t\tREF_26(uint256) -> self.data\n\t\t\tTMP_203(uint256) = REF_26 & DECIMALS_MASK\n\t\t\tTMP_204(uint256) = decimals << RESERVE_DECIMALS_START_BIT_POSITION\n\t\t\tTMP_205(uint256) = TMP_203 | TMP_204\n\t\t\tREF_25(uint256) (->self) := TMP_205(uint256)\n\tFunction ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_27(uint256) -> self.data\n\t\t\tTMP_206 = UnaryType.TILD DECIMALS_MASK \n\t\t\tTMP_207(uint256) = REF_27 & TMP_206\n\t\t\tTMP_208(uint256) = TMP_207 >> RESERVE_DECIMALS_START_BIT_POSITION\n\t\t\tRETURN TMP_208\n\tFunction ReserveConfiguration.setActive(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: active\n\t\tIRs:\n\t\t\tCONDITION active\n\t\tExpression: self.data = (self.data & ACTIVE_MASK) | (uint256(1) << IS_ACTIVE_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_28(uint256) -> self.data\n\t\t\tREF_29(uint256) -> self.data\n\t\t\tTMP_209(uint256) = REF_29 & ACTIVE_MASK\n\t\t\tTMP_210 = CONVERT 1 to uint256\n\t\t\tTMP_211(uint256) = TMP_210 << IS_ACTIVE_START_BIT_POSITION\n\t\t\tTMP_212(uint256) = TMP_209 | TMP_211\n\t\t\tREF_28(uint256) (->self) := TMP_212(uint256)\n\t\tExpression: self.data = (self.data & ACTIVE_MASK) | (uint256(0) << IS_ACTIVE_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_30(uint256) -> self.data\n\t\t\tREF_31(uint256) -> self.data\n\t\t\tTMP_213(uint256) = REF_31 & ACTIVE_MASK\n\t\t\tTMP_214 = CONVERT 0 to uint256\n\t\t\tTMP_215(uint256) = TMP_214 << IS_ACTIVE_START_BIT_POSITION\n\t\t\tTMP_216(uint256) = TMP_213 | TMP_215\n\t\t\tREF_30(uint256) (->self) := TMP_216(uint256)\n\tFunction ReserveConfiguration.getActive(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ ACTIVE_MASK) != 0\n\t\tIRs:\n\t\t\tREF_32(uint256) -> self.data\n\t\t\tTMP_217 = UnaryType.TILD ACTIVE_MASK \n\t\t\tTMP_218(uint256) = REF_32 & TMP_217\n\t\t\tTMP_219(bool) = TMP_218 != 0\n\t\t\tRETURN TMP_219\n\tFunction ReserveConfiguration.setFrozen(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: frozen\n\t\tIRs:\n\t\t\tCONDITION frozen\n\t\tExpression: self.data = (self.data & FROZEN_MASK) | (uint256(1) << IS_FROZEN_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_33(uint256) -> self.data\n\t\t\tREF_34(uint256) -> self.data\n\t\t\tTMP_220(uint256) = REF_34 & FROZEN_MASK\n\t\t\tTMP_221 = CONVERT 1 to uint256\n\t\t\tTMP_222(uint256) = TMP_221 << IS_FROZEN_START_BIT_POSITION\n\t\t\tTMP_223(uint256) = TMP_220 | TMP_222\n\t\t\tREF_33(uint256) (->self) := TMP_223(uint256)\n\t\tExpression: self.data = (self.data & FROZEN_MASK) | (uint256(0) << IS_FROZEN_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_35(uint256) -> self.data\n\t\t\tREF_36(uint256) -> self.data\n\t\t\tTMP_224(uint256) = REF_36 & FROZEN_MASK\n\t\t\tTMP_225 = CONVERT 0 to uint256\n\t\t\tTMP_226(uint256) = TMP_225 << IS_FROZEN_START_BIT_POSITION\n\t\t\tTMP_227(uint256) = TMP_224 | TMP_226\n\t\t\tREF_35(uint256) (->self) := TMP_227(uint256)\n\tFunction ReserveConfiguration.getFrozen(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ FROZEN_MASK) != 0\n\t\tIRs:\n\t\t\tREF_37(uint256) -> self.data\n\t\t\tTMP_228 = UnaryType.TILD FROZEN_MASK \n\t\t\tTMP_229(uint256) = REF_37 & TMP_228\n\t\t\tTMP_230(bool) = TMP_229 != 0\n\t\t\tRETURN TMP_230\n\tFunction ReserveConfiguration.setPaused(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: paused\n\t\tIRs:\n\t\t\tCONDITION paused\n\t\tExpression: self.data = (self.data & PAUSED_MASK) | (uint256(1) << IS_PAUSED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_38(uint256) -> self.data\n\t\t\tREF_39(uint256) -> self.data\n\t\t\tTMP_231(uint256) = REF_39 & PAUSED_MASK\n\t\t\tTMP_232 = CONVERT 1 to uint256\n\t\t\tTMP_233(uint256) = TMP_232 << IS_PAUSED_START_BIT_POSITION\n\t\t\tTMP_234(uint256) = TMP_231 | TMP_233\n\t\t\tREF_38(uint256) (->self) := TMP_234(uint256)\n\t\tExpression: self.data = (self.data & PAUSED_MASK) | (uint256(0) << IS_PAUSED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_40(uint256) -> self.data\n\t\t\tREF_41(uint256) -> self.data\n\t\t\tTMP_235(uint256) = REF_41 & PAUSED_MASK\n\t\t\tTMP_236 = CONVERT 0 to uint256\n\t\t\tTMP_237(uint256) = TMP_236 << IS_PAUSED_START_BIT_POSITION\n\t\t\tTMP_238(uint256) = TMP_235 | TMP_237\n\t\t\tREF_40(uint256) (->self) := TMP_238(uint256)\n\tFunction ReserveConfiguration.getPaused(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ PAUSED_MASK) != 0\n\t\tIRs:\n\t\t\tREF_42(uint256) -> self.data\n\t\t\tTMP_239 = UnaryType.TILD PAUSED_MASK \n\t\t\tTMP_240(uint256) = REF_42 & TMP_239\n\t\t\tTMP_241(bool) = TMP_240 != 0\n\t\t\tRETURN TMP_241\n\tFunction ReserveConfiguration.setBorrowableInIsolation(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: borrowable\n\t\tIRs:\n\t\t\tCONDITION borrowable\n\t\tExpression: self.data = (self.data & BORROWABLE_IN_ISOLATION_MASK) | (uint256(1) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_43(uint256) -> self.data\n\t\t\tREF_44(uint256) -> self.data\n\t\t\tTMP_242(uint256) = REF_44 & BORROWABLE_IN_ISOLATION_MASK\n\t\t\tTMP_243 = CONVERT 1 to uint256\n\t\t\tTMP_244(uint256) = TMP_243 << BORROWABLE_IN_ISOLATION_START_BIT_POSITION\n\t\t\tTMP_245(uint256) = TMP_242 | TMP_244\n\t\t\tREF_43(uint256) (->self) := TMP_245(uint256)\n\t\tExpression: self.data = (self.data & BORROWABLE_IN_ISOLATION_MASK) | (uint256(0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_45(uint256) -> self.data\n\t\t\tREF_46(uint256) -> self.data\n\t\t\tTMP_246(uint256) = REF_46 & BORROWABLE_IN_ISOLATION_MASK\n\t\t\tTMP_247 = CONVERT 0 to uint256\n\t\t\tTMP_248(uint256) = TMP_247 << BORROWABLE_IN_ISOLATION_START_BIT_POSITION\n\t\t\tTMP_249(uint256) = TMP_246 | TMP_248\n\t\t\tREF_45(uint256) (->self) := TMP_249(uint256)\n\tFunction ReserveConfiguration.getBorrowableInIsolation(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ BORROWABLE_IN_ISOLATION_MASK) != 0\n\t\tIRs:\n\t\t\tREF_47(uint256) -> self.data\n\t\t\tTMP_250 = UnaryType.TILD BORROWABLE_IN_ISOLATION_MASK \n\t\t\tTMP_251(uint256) = REF_47 & TMP_250\n\t\t\tTMP_252(bool) = TMP_251 != 0\n\t\t\tRETURN TMP_252\n\tFunction ReserveConfiguration.setSiloedBorrowing(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: siloed\n\t\tIRs:\n\t\t\tCONDITION siloed\n\t\tExpression: self.data = (self.data & SILOED_BORROWING_MASK) | (uint256(1) << SILOED_BORROWING_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_48(uint256) -> self.data\n\t\t\tREF_49(uint256) -> self.data\n\t\t\tTMP_253(uint256) = REF_49 & SILOED_BORROWING_MASK\n\t\t\tTMP_254 = CONVERT 1 to uint256\n\t\t\tTMP_255(uint256) = TMP_254 << SILOED_BORROWING_START_BIT_POSITION\n\t\t\tTMP_256(uint256) = TMP_253 | TMP_255\n\t\t\tREF_48(uint256) (->self) := TMP_256(uint256)\n\t\tExpression: self.data = (self.data & SILOED_BORROWING_MASK) | (uint256(0) << SILOED_BORROWING_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_50(uint256) -> self.data\n\t\t\tREF_51(uint256) -> self.data\n\t\t\tTMP_257(uint256) = REF_51 & SILOED_BORROWING_MASK\n\t\t\tTMP_258 = CONVERT 0 to uint256\n\t\t\tTMP_259(uint256) = TMP_258 << SILOED_BORROWING_START_BIT_POSITION\n\t\t\tTMP_260(uint256) = TMP_257 | TMP_259\n\t\t\tREF_50(uint256) (->self) := TMP_260(uint256)\n\tFunction ReserveConfiguration.getSiloedBorrowing(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ SILOED_BORROWING_MASK) != 0\n\t\tIRs:\n\t\t\tREF_52(uint256) -> self.data\n\t\t\tTMP_261 = UnaryType.TILD SILOED_BORROWING_MASK \n\t\t\tTMP_262(uint256) = REF_52 & TMP_261\n\t\t\tTMP_263(bool) = TMP_262 != 0\n\t\t\tRETURN TMP_263\n\tFunction ReserveConfiguration.setBorrowingEnabled(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: enabled\n\t\tIRs:\n\t\t\tCONDITION enabled\n\t\tExpression: self.data = (self.data & BORROWING_MASK) | (uint256(1) << BORROWING_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_53(uint256) -> self.data\n\t\t\tREF_54(uint256) -> self.data\n\t\t\tTMP_264(uint256) = REF_54 & BORROWING_MASK\n\t\t\tTMP_265 = CONVERT 1 to uint256\n\t\t\tTMP_266(uint256) = TMP_265 << BORROWING_ENABLED_START_BIT_POSITION\n\t\t\tTMP_267(uint256) = TMP_264 | TMP_266\n\t\t\tREF_53(uint256) (->self) := TMP_267(uint256)\n\t\tExpression: self.data = (self.data & BORROWING_MASK) | (uint256(0) << BORROWING_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_55(uint256) -> self.data\n\t\t\tREF_56(uint256) -> self.data\n\t\t\tTMP_268(uint256) = REF_56 & BORROWING_MASK\n\t\t\tTMP_269 = CONVERT 0 to uint256\n\t\t\tTMP_270(uint256) = TMP_269 << BORROWING_ENABLED_START_BIT_POSITION\n\t\t\tTMP_271(uint256) = TMP_268 | TMP_270\n\t\t\tREF_55(uint256) (->self) := TMP_271(uint256)\n\tFunction ReserveConfiguration.getBorrowingEnabled(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ BORROWING_MASK) != 0\n\t\tIRs:\n\t\t\tREF_57(uint256) -> self.data\n\t\t\tTMP_272 = UnaryType.TILD BORROWING_MASK \n\t\t\tTMP_273(uint256) = REF_57 & TMP_272\n\t\t\tTMP_274(bool) = TMP_273 != 0\n\t\t\tRETURN TMP_274\n\tFunction ReserveConfiguration.setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: enabled\n\t\tIRs:\n\t\t\tCONDITION enabled\n\t\tExpression: self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(1) << STABLE_BORROWING_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_58(uint256) -> self.data\n\t\t\tREF_59(uint256) -> self.data\n\t\t\tTMP_275(uint256) = REF_59 & STABLE_BORROWING_MASK\n\t\t\tTMP_276 = CONVERT 1 to uint256\n\t\t\tTMP_277(uint256) = TMP_276 << STABLE_BORROWING_ENABLED_START_BIT_POSITION\n\t\t\tTMP_278(uint256) = TMP_275 | TMP_277\n\t\t\tREF_58(uint256) (->self) := TMP_278(uint256)\n\t\tExpression: self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_60(uint256) -> self.data\n\t\t\tREF_61(uint256) -> self.data\n\t\t\tTMP_279(uint256) = REF_61 & STABLE_BORROWING_MASK\n\t\t\tTMP_280 = CONVERT 0 to uint256\n\t\t\tTMP_281(uint256) = TMP_280 << STABLE_BORROWING_ENABLED_START_BIT_POSITION\n\t\t\tTMP_282(uint256) = TMP_279 | TMP_281\n\t\t\tREF_60(uint256) (->self) := TMP_282(uint256)\n\tFunction ReserveConfiguration.getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ STABLE_BORROWING_MASK) != 0\n\t\tIRs:\n\t\t\tREF_62(uint256) -> self.data\n\t\t\tTMP_283 = UnaryType.TILD STABLE_BORROWING_MASK \n\t\t\tTMP_284(uint256) = REF_62 & TMP_283\n\t\t\tTMP_285(bool) = TMP_284 != 0\n\t\t\tRETURN TMP_285\n\tFunction ReserveConfiguration.setReserveFactor(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(reserveFactor <= MAX_VALID_RESERVE_FACTOR,Errors.INVALID_RESERVE_FACTOR)\n\t\tIRs:\n\t\t\tTMP_286(bool) = reserveFactor <= MAX_VALID_RESERVE_FACTOR\n\t\t\tREF_63(string) -> Errors.INVALID_RESERVE_FACTOR\n\t\t\tTMP_287(None) = SOLIDITY_CALL require(bool,string)(TMP_286,REF_63)\n\t\tExpression: self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_64(uint256) -> self.data\n\t\t\tREF_65(uint256) -> self.data\n\t\t\tTMP_288(uint256) = REF_65 & RESERVE_FACTOR_MASK\n\t\t\tTMP_289(uint256) = reserveFactor << RESERVE_FACTOR_START_BIT_POSITION\n\t\t\tTMP_290(uint256) = TMP_288 | TMP_289\n\t\t\tREF_64(uint256) (->self) := TMP_290(uint256)\n\tFunction ReserveConfiguration.getReserveFactor(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_66(uint256) -> self.data\n\t\t\tTMP_291 = UnaryType.TILD RESERVE_FACTOR_MASK \n\t\t\tTMP_292(uint256) = REF_66 & TMP_291\n\t\t\tTMP_293(uint256) = TMP_292 >> RESERVE_FACTOR_START_BIT_POSITION\n\t\t\tRETURN TMP_293\n\tFunction ReserveConfiguration.setBorrowCap(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(borrowCap <= MAX_VALID_BORROW_CAP,Errors.INVALID_BORROW_CAP)\n\t\tIRs:\n\t\t\tTMP_294(bool) = borrowCap <= MAX_VALID_BORROW_CAP\n\t\t\tREF_67(string) -> Errors.INVALID_BORROW_CAP\n\t\t\tTMP_295(None) = SOLIDITY_CALL require(bool,string)(TMP_294,REF_67)\n\t\tExpression: self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_68(uint256) -> self.data\n\t\t\tREF_69(uint256) -> self.data\n\t\t\tTMP_296(uint256) = REF_69 & BORROW_CAP_MASK\n\t\t\tTMP_297(uint256) = borrowCap << BORROW_CAP_START_BIT_POSITION\n\t\t\tTMP_298(uint256) = TMP_296 | TMP_297\n\t\t\tREF_68(uint256) (->self) := TMP_298(uint256)\n\tFunction ReserveConfiguration.getBorrowCap(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_70(uint256) -> self.data\n\t\t\tTMP_299 = UnaryType.TILD BORROW_CAP_MASK \n\t\t\tTMP_300(uint256) = REF_70 & TMP_299\n\t\t\tTMP_301(uint256) = TMP_300 >> BORROW_CAP_START_BIT_POSITION\n\t\t\tRETURN TMP_301\n\tFunction ReserveConfiguration.setSupplyCap(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(supplyCap <= MAX_VALID_SUPPLY_CAP,Errors.INVALID_SUPPLY_CAP)\n\t\tIRs:\n\t\t\tTMP_302(bool) = supplyCap <= MAX_VALID_SUPPLY_CAP\n\t\t\tREF_71(string) -> Errors.INVALID_SUPPLY_CAP\n\t\t\tTMP_303(None) = SOLIDITY_CALL require(bool,string)(TMP_302,REF_71)\n\t\tExpression: self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_72(uint256) -> self.data\n\t\t\tREF_73(uint256) -> self.data\n\t\t\tTMP_304(uint256) = REF_73 & SUPPLY_CAP_MASK\n\t\t\tTMP_305(uint256) = supplyCap << SUPPLY_CAP_START_BIT_POSITION\n\t\t\tTMP_306(uint256) = TMP_304 | TMP_305\n\t\t\tREF_72(uint256) (->self) := TMP_306(uint256)\n\tFunction ReserveConfiguration.getSupplyCap(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_74(uint256) -> self.data\n\t\t\tTMP_307 = UnaryType.TILD SUPPLY_CAP_MASK \n\t\t\tTMP_308(uint256) = REF_74 & TMP_307\n\t\t\tTMP_309(uint256) = TMP_308 >> SUPPLY_CAP_START_BIT_POSITION\n\t\t\tRETURN TMP_309\n\tFunction ReserveConfiguration.setDebtCeiling(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(ceiling <= MAX_VALID_DEBT_CEILING,Errors.INVALID_DEBT_CEILING)\n\t\tIRs:\n\t\t\tTMP_310(bool) = ceiling <= MAX_VALID_DEBT_CEILING\n\t\t\tREF_75(string) -> Errors.INVALID_DEBT_CEILING\n\t\t\tTMP_311(None) = SOLIDITY_CALL require(bool,string)(TMP_310,REF_75)\n\t\tExpression: self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_76(uint256) -> self.data\n\t\t\tREF_77(uint256) -> self.data\n\t\t\tTMP_312(uint256) = REF_77 & DEBT_CEILING_MASK\n\t\t\tTMP_313(uint256) = ceiling << DEBT_CEILING_START_BIT_POSITION\n\t\t\tTMP_314(uint256) = TMP_312 | TMP_313\n\t\t\tREF_76(uint256) (->self) := TMP_314(uint256)\n\tFunction ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_78(uint256) -> self.data\n\t\t\tTMP_315 = UnaryType.TILD DEBT_CEILING_MASK \n\t\t\tTMP_316(uint256) = REF_78 & TMP_315\n\t\t\tTMP_317(uint256) = TMP_316 >> DEBT_CEILING_START_BIT_POSITION\n\t\t\tRETURN TMP_317\n\tFunction ReserveConfiguration.setLiquidationProtocolFee(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE,Errors.INVALID_LIQUIDATION_PROTOCOL_FEE)\n\t\tIRs:\n\t\t\tTMP_318(bool) = liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE\n\t\t\tREF_79(string) -> Errors.INVALID_LIQUIDATION_PROTOCOL_FEE\n\t\t\tTMP_319(None) = SOLIDITY_CALL require(bool,string)(TMP_318,REF_79)\n\t\tExpression: self.data = (self.data & LIQUIDATION_PROTOCOL_FEE_MASK) | (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_80(uint256) -> self.data\n\t\t\tREF_81(uint256) -> self.data\n\t\t\tTMP_320(uint256) = REF_81 & LIQUIDATION_PROTOCOL_FEE_MASK\n\t\t\tTMP_321(uint256) = liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION\n\t\t\tTMP_322(uint256) = TMP_320 | TMP_321\n\t\t\tREF_80(uint256) (->self) := TMP_322(uint256)\n\tFunction ReserveConfiguration.getLiquidationProtocolFee(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_82(uint256) -> self.data\n\t\t\tTMP_323 = UnaryType.TILD LIQUIDATION_PROTOCOL_FEE_MASK \n\t\t\tTMP_324(uint256) = REF_82 & TMP_323\n\t\t\tTMP_325(uint256) = TMP_324 >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION\n\t\t\tRETURN TMP_325\n\tFunction ReserveConfiguration.setUnbackedMintCap(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP,Errors.INVALID_UNBACKED_MINT_CAP)\n\t\tIRs:\n\t\t\tTMP_326(bool) = unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP\n\t\t\tREF_83(string) -> Errors.INVALID_UNBACKED_MINT_CAP\n\t\t\tTMP_327(None) = SOLIDITY_CALL require(bool,string)(TMP_326,REF_83)\n\t\tExpression: self.data = (self.data & UNBACKED_MINT_CAP_MASK) | (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_84(uint256) -> self.data\n\t\t\tREF_85(uint256) -> self.data\n\t\t\tTMP_328(uint256) = REF_85 & UNBACKED_MINT_CAP_MASK\n\t\t\tTMP_329(uint256) = unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION\n\t\t\tTMP_330(uint256) = TMP_328 | TMP_329\n\t\t\tREF_84(uint256) (->self) := TMP_330(uint256)\n\tFunction ReserveConfiguration.getUnbackedMintCap(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_86(uint256) -> self.data\n\t\t\tTMP_331 = UnaryType.TILD UNBACKED_MINT_CAP_MASK \n\t\t\tTMP_332(uint256) = REF_86 & TMP_331\n\t\t\tTMP_333(uint256) = TMP_332 >> UNBACKED_MINT_CAP_START_BIT_POSITION\n\t\t\tRETURN TMP_333\n\tFunction ReserveConfiguration.setEModeCategory(DataTypes.ReserveConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(category <= MAX_VALID_EMODE_CATEGORY,Errors.INVALID_EMODE_CATEGORY)\n\t\tIRs:\n\t\t\tTMP_334(bool) = category <= MAX_VALID_EMODE_CATEGORY\n\t\t\tREF_87(string) -> Errors.INVALID_EMODE_CATEGORY\n\t\t\tTMP_335(None) = SOLIDITY_CALL require(bool,string)(TMP_334,REF_87)\n\t\tExpression: self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_88(uint256) -> self.data\n\t\t\tREF_89(uint256) -> self.data\n\t\t\tTMP_336(uint256) = REF_89 & EMODE_CATEGORY_MASK\n\t\t\tTMP_337(uint256) = category << EMODE_CATEGORY_START_BIT_POSITION\n\t\t\tTMP_338(uint256) = TMP_336 | TMP_337\n\t\t\tREF_88(uint256) (->self) := TMP_338(uint256)\n\tFunction ReserveConfiguration.getEModeCategory(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n\t\tIRs:\n\t\t\tREF_90(uint256) -> self.data\n\t\t\tTMP_339 = UnaryType.TILD EMODE_CATEGORY_MASK \n\t\t\tTMP_340(uint256) = REF_90 & TMP_339\n\t\t\tTMP_341(uint256) = TMP_340 >> EMODE_CATEGORY_START_BIT_POSITION\n\t\t\tRETURN TMP_341\n\tFunction ReserveConfiguration.setFlashLoanEnabled(DataTypes.ReserveConfigurationMap,bool) (*)\n\t\tExpression: flashLoanEnabled\n\t\tIRs:\n\t\t\tCONDITION flashLoanEnabled\n\t\tExpression: self.data = (self.data & FLASHLOAN_ENABLED_MASK) | (uint256(1) << FLASHLOAN_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_91(uint256) -> self.data\n\t\t\tREF_92(uint256) -> self.data\n\t\t\tTMP_342(uint256) = REF_92 & FLASHLOAN_ENABLED_MASK\n\t\t\tTMP_343 = CONVERT 1 to uint256\n\t\t\tTMP_344(uint256) = TMP_343 << FLASHLOAN_ENABLED_START_BIT_POSITION\n\t\t\tTMP_345(uint256) = TMP_342 | TMP_344\n\t\t\tREF_91(uint256) (->self) := TMP_345(uint256)\n\t\tExpression: self.data = (self.data & FLASHLOAN_ENABLED_MASK) | (uint256(0) << FLASHLOAN_ENABLED_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tREF_93(uint256) -> self.data\n\t\t\tREF_94(uint256) -> self.data\n\t\t\tTMP_346(uint256) = REF_94 & FLASHLOAN_ENABLED_MASK\n\t\t\tTMP_347 = CONVERT 0 to uint256\n\t\t\tTMP_348(uint256) = TMP_347 << FLASHLOAN_ENABLED_START_BIT_POSITION\n\t\t\tTMP_349(uint256) = TMP_346 | TMP_348\n\t\t\tREF_93(uint256) (->self) := TMP_349(uint256)\n\tFunction ReserveConfiguration.getFlashLoanEnabled(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: (self.data & ~ FLASHLOAN_ENABLED_MASK) != 0\n\t\tIRs:\n\t\t\tREF_95(uint256) -> self.data\n\t\t\tTMP_350 = UnaryType.TILD FLASHLOAN_ENABLED_MASK \n\t\t\tTMP_351(uint256) = REF_95 & TMP_350\n\t\t\tTMP_352(bool) = TMP_351 != 0\n\t\t\tRETURN TMP_352\n\tFunction ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: dataLocal = self.data\n\t\tIRs:\n\t\t\tREF_96(uint256) -> self.data\n\t\t\tdataLocal(uint256) := REF_96(uint256)\n\t\tExpression: ((dataLocal & ~ ACTIVE_MASK) != 0,(dataLocal & ~ FROZEN_MASK) != 0,(dataLocal & ~ BORROWING_MASK) != 0,(dataLocal & ~ STABLE_BORROWING_MASK) != 0,(dataLocal & ~ PAUSED_MASK) != 0)\n\t\tIRs:\n\t\t\tTMP_353 = UnaryType.TILD ACTIVE_MASK \n\t\t\tTMP_354(uint256) = dataLocal & TMP_353\n\t\t\tTMP_355(bool) = TMP_354 != 0\n\t\t\tTMP_356 = UnaryType.TILD FROZEN_MASK \n\t\t\tTMP_357(uint256) = dataLocal & TMP_356\n\t\t\tTMP_358(bool) = TMP_357 != 0\n\t\t\tTMP_359 = UnaryType.TILD BORROWING_MASK \n\t\t\tTMP_360(uint256) = dataLocal & TMP_359\n\t\t\tTMP_361(bool) = TMP_360 != 0\n\t\t\tTMP_362 = UnaryType.TILD STABLE_BORROWING_MASK \n\t\t\tTMP_363(uint256) = dataLocal & TMP_362\n\t\t\tTMP_364(bool) = TMP_363 != 0\n\t\t\tTMP_365 = UnaryType.TILD PAUSED_MASK \n\t\t\tTMP_366(uint256) = dataLocal & TMP_365\n\t\t\tTMP_367(bool) = TMP_366 != 0\n\t\t\tRETURN TMP_355,TMP_358,TMP_361,TMP_364,TMP_367\n\tFunction ReserveConfiguration.getParams(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: dataLocal = self.data\n\t\tIRs:\n\t\t\tREF_97(uint256) -> self.data\n\t\t\tdataLocal(uint256) := REF_97(uint256)\n\t\tExpression: (dataLocal & ~ LTV_MASK,(dataLocal & ~ LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,(dataLocal & ~ LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,(dataLocal & ~ DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,(dataLocal & ~ RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,(dataLocal & ~ EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tTMP_368 = UnaryType.TILD LTV_MASK \n\t\t\tTMP_369(uint256) = dataLocal & TMP_368\n\t\t\tTMP_370 = UnaryType.TILD LIQUIDATION_THRESHOLD_MASK \n\t\t\tTMP_371(uint256) = dataLocal & TMP_370\n\t\t\tTMP_372(uint256) = TMP_371 >> LIQUIDATION_THRESHOLD_START_BIT_POSITION\n\t\t\tTMP_373 = UnaryType.TILD LIQUIDATION_BONUS_MASK \n\t\t\tTMP_374(uint256) = dataLocal & TMP_373\n\t\t\tTMP_375(uint256) = TMP_374 >> LIQUIDATION_BONUS_START_BIT_POSITION\n\t\t\tTMP_376 = UnaryType.TILD DECIMALS_MASK \n\t\t\tTMP_377(uint256) = dataLocal & TMP_376\n\t\t\tTMP_378(uint256) = TMP_377 >> RESERVE_DECIMALS_START_BIT_POSITION\n\t\t\tTMP_379 = UnaryType.TILD RESERVE_FACTOR_MASK \n\t\t\tTMP_380(uint256) = dataLocal & TMP_379\n\t\t\tTMP_381(uint256) = TMP_380 >> RESERVE_FACTOR_START_BIT_POSITION\n\t\t\tTMP_382 = UnaryType.TILD EMODE_CATEGORY_MASK \n\t\t\tTMP_383(uint256) = dataLocal & TMP_382\n\t\t\tTMP_384(uint256) = TMP_383 >> EMODE_CATEGORY_START_BIT_POSITION\n\t\t\tRETURN TMP_369,TMP_372,TMP_375,TMP_378,TMP_381,TMP_384\n\tFunction ReserveConfiguration.getCaps(DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: dataLocal = self.data\n\t\tIRs:\n\t\t\tREF_98(uint256) -> self.data\n\t\t\tdataLocal(uint256) := REF_98(uint256)\n\t\tExpression: ((dataLocal & ~ BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,(dataLocal & ~ SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION)\n\t\tIRs:\n\t\t\tTMP_385 = UnaryType.TILD BORROW_CAP_MASK \n\t\t\tTMP_386(uint256) = dataLocal & TMP_385\n\t\t\tTMP_387(uint256) = TMP_386 >> BORROW_CAP_START_BIT_POSITION\n\t\t\tTMP_388 = UnaryType.TILD SUPPLY_CAP_MASK \n\t\t\tTMP_389(uint256) = dataLocal & TMP_388\n\t\t\tTMP_390(uint256) = TMP_389 >> SUPPLY_CAP_START_BIT_POSITION\n\t\t\tRETURN TMP_387,TMP_390\n\tFunction ReserveConfiguration.slitherConstructorConstantVariables() (*)\n\t\tExpression: LTV_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000\n\t\tIRs:\n\t\t\tLTV_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129574400(uint256)\n\t\tExpression: LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF\n\t\tIRs:\n\t\t\tLIQUIDATION_THRESHOLD_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457584007908834738175(uint256)\n\t\tExpression: LIQUIDATION_BONUS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF\n\t\tIRs:\n\t\t\tLIQUIDATION_BONUS_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457583726442447896575(uint256)\n\t\tExpression: DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF\n\t\tIRs:\n\t\t\tDECIMALS_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457512231794068422655(uint256)\n\t\tExpression: ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tACTIVE_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457511950319091711999(uint256)\n\t\tExpression: FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tFROZEN_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457439892725053784063(uint256)\n\t\tExpression: BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tBORROWING_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457295777536977928191(uint256)\n\t\tExpression: STABLE_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tSTABLE_BORROWING_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039457007547160826216447(uint256)\n\t\tExpression: PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tPAUSED_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039456431086408522792959(uint256)\n\t\tExpression: BORROWABLE_IN_ISOLATION_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tBORROWABLE_IN_ISOLATION_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039455278164903915945983(uint256)\n\t\tExpression: SILOED_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tSILOED_BORROWING_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039452972321894702252031(uint256)\n\t\tExpression: FLASHLOAN_ENABLED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tFLASHLOAN_ENABLED_MASK(uint256) := 115792089237316195423570985008687907853269984665640564039448360635876274864127(uint256)\n\t\tExpression: RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tRESERVE_FACTOR_MASK(uint256) := 115792089237316195423570985008687907853269984665640562830550211137357664485375(uint256)\n\t\tExpression: BORROW_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tBORROW_CAP_MASK(uint256) := 115792089237316195423570985008687907853269901588890828691141347134601036824575(uint256)\n\t\tExpression: SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tSUPPLY_CAP_MASK(uint256) := 115792089237316195423570985008682198862499243902866067452821842515308866174975(uint256)\n\t\tExpression: LIQUIDATION_PROTOCOL_FEE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tLIQUIDATION_PROTOCOL_FEE_MASK(uint256) := 115792089237316195423570984634549197687329661445021480007966928956539929624575(uint256)\n\t\tExpression: EMODE_CATEGORY_MASK = 0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tEMODE_CATEGORY_MASK(uint256) := 115792089237316195423570889601861022891927484329094684320502060868636724166655(uint256)\n\t\tExpression: UNBACKED_MINT_CAP_MASK = 0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tUNBACKED_MINT_CAP_MASK(uint256) := 115792089237309613405341795965490592094593402660309829990319025859654871678975(uint256)\n\t\tExpression: DEBT_CEILING_MASK = 0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\tIRs:\n\t\t\tDEBT_CEILING_MASK(uint256) := 108555083659990515227827083269813533489170840026057959730454019326871953473535(uint256)\n\t\tExpression: LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16\n\t\tIRs:\n\t\t\tLIQUIDATION_THRESHOLD_START_BIT_POSITION(uint256) := 16(uint256)\n\t\tExpression: LIQUIDATION_BONUS_START_BIT_POSITION = 32\n\t\tIRs:\n\t\t\tLIQUIDATION_BONUS_START_BIT_POSITION(uint256) := 32(uint256)\n\t\tExpression: RESERVE_DECIMALS_START_BIT_POSITION = 48\n\t\tIRs:\n\t\t\tRESERVE_DECIMALS_START_BIT_POSITION(uint256) := 48(uint256)\n\t\tExpression: IS_ACTIVE_START_BIT_POSITION = 56\n\t\tIRs:\n\t\t\tIS_ACTIVE_START_BIT_POSITION(uint256) := 56(uint256)\n\t\tExpression: IS_FROZEN_START_BIT_POSITION = 57\n\t\tIRs:\n\t\t\tIS_FROZEN_START_BIT_POSITION(uint256) := 57(uint256)\n\t\tExpression: BORROWING_ENABLED_START_BIT_POSITION = 58\n\t\tIRs:\n\t\t\tBORROWING_ENABLED_START_BIT_POSITION(uint256) := 58(uint256)\n\t\tExpression: STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59\n\t\tIRs:\n\t\t\tSTABLE_BORROWING_ENABLED_START_BIT_POSITION(uint256) := 59(uint256)\n\t\tExpression: IS_PAUSED_START_BIT_POSITION = 60\n\t\tIRs:\n\t\t\tIS_PAUSED_START_BIT_POSITION(uint256) := 60(uint256)\n\t\tExpression: BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61\n\t\tIRs:\n\t\t\tBORROWABLE_IN_ISOLATION_START_BIT_POSITION(uint256) := 61(uint256)\n\t\tExpression: SILOED_BORROWING_START_BIT_POSITION = 62\n\t\tIRs:\n\t\t\tSILOED_BORROWING_START_BIT_POSITION(uint256) := 62(uint256)\n\t\tExpression: FLASHLOAN_ENABLED_START_BIT_POSITION = 63\n\t\tIRs:\n\t\t\tFLASHLOAN_ENABLED_START_BIT_POSITION(uint256) := 63(uint256)\n\t\tExpression: RESERVE_FACTOR_START_BIT_POSITION = 64\n\t\tIRs:\n\t\t\tRESERVE_FACTOR_START_BIT_POSITION(uint256) := 64(uint256)\n\t\tExpression: BORROW_CAP_START_BIT_POSITION = 80\n\t\tIRs:\n\t\t\tBORROW_CAP_START_BIT_POSITION(uint256) := 80(uint256)\n\t\tExpression: SUPPLY_CAP_START_BIT_POSITION = 116\n\t\tIRs:\n\t\t\tSUPPLY_CAP_START_BIT_POSITION(uint256) := 116(uint256)\n\t\tExpression: LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152\n\t\tIRs:\n\t\t\tLIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION(uint256) := 152(uint256)\n\t\tExpression: EMODE_CATEGORY_START_BIT_POSITION = 168\n\t\tIRs:\n\t\t\tEMODE_CATEGORY_START_BIT_POSITION(uint256) := 168(uint256)\n\t\tExpression: UNBACKED_MINT_CAP_START_BIT_POSITION = 176\n\t\tIRs:\n\t\t\tUNBACKED_MINT_CAP_START_BIT_POSITION(uint256) := 176(uint256)\n\t\tExpression: DEBT_CEILING_START_BIT_POSITION = 212\n\t\tIRs:\n\t\t\tDEBT_CEILING_START_BIT_POSITION(uint256) := 212(uint256)\n\t\tExpression: MAX_VALID_LTV = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_LTV(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_LIQUIDATION_THRESHOLD = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_LIQUIDATION_THRESHOLD(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_LIQUIDATION_BONUS = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_LIQUIDATION_BONUS(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_DECIMALS = 255\n\t\tIRs:\n\t\t\tMAX_VALID_DECIMALS(uint256) := 255(uint256)\n\t\tExpression: MAX_VALID_RESERVE_FACTOR = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_RESERVE_FACTOR(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_BORROW_CAP = 68719476735\n\t\tIRs:\n\t\t\tMAX_VALID_BORROW_CAP(uint256) := 68719476735(uint256)\n\t\tExpression: MAX_VALID_SUPPLY_CAP = 68719476735\n\t\tIRs:\n\t\t\tMAX_VALID_SUPPLY_CAP(uint256) := 68719476735(uint256)\n\t\tExpression: MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535\n\t\tIRs:\n\t\t\tMAX_VALID_LIQUIDATION_PROTOCOL_FEE(uint256) := 65535(uint256)\n\t\tExpression: MAX_VALID_EMODE_CATEGORY = 255\n\t\tIRs:\n\t\t\tMAX_VALID_EMODE_CATEGORY(uint256) := 255(uint256)\n\t\tExpression: MAX_VALID_UNBACKED_MINT_CAP = 68719476735\n\t\tIRs:\n\t\t\tMAX_VALID_UNBACKED_MINT_CAP(uint256) := 68719476735(uint256)\n\t\tExpression: MAX_VALID_DEBT_CEILING = 1099511627775\n\t\tIRs:\n\t\t\tMAX_VALID_DEBT_CEILING(uint256) := 1099511627775(uint256)\n\t\tExpression: DEBT_CEILING_DECIMALS = 2\n\t\tIRs:\n\t\t\tDEBT_CEILING_DECIMALS(uint256) := 2(uint256)\n\t\tExpression: MAX_RESERVES_COUNT = 128\n\t\tIRs:\n\t\t\tMAX_RESERVES_COUNT(uint16) := 128(uint256)\nContract UserConfiguration\n\tFunction UserConfiguration.setBorrowing(DataTypes.UserConfigurationMap,uint256,bool) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_99(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_391(bool) = reserveIndex < REF_99\n\t\t\tREF_100(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_392(None) = SOLIDITY_CALL require(bool,string)(TMP_391,REF_100)\n\t\tExpression: bit = 1 << (reserveIndex << 1)\n\t\tIRs:\n\t\t\tTMP_393(uint256) = reserveIndex << 1\n\t\t\tTMP_394(uint256) = 1 << TMP_393\n\t\t\tbit(uint256) := TMP_394(uint256)\n\t\tExpression: borrowing\n\t\tIRs:\n\t\t\tCONDITION borrowing\n\t\tExpression: self.data |= bit\n\t\tIRs:\n\t\t\tREF_101(uint256) -> self.data\n\t\t\tREF_101(-> self) = REF_101 | bit\n\t\tExpression: self.data &= ~ bit\n\t\tIRs:\n\t\t\tREF_102(uint256) -> self.data\n\t\t\tTMP_395 = UnaryType.TILD bit \n\t\t\tREF_102(-> self) = REF_102 & TMP_395\n\tFunction UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_103(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_396(bool) = reserveIndex < REF_103\n\t\t\tREF_104(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_397(None) = SOLIDITY_CALL require(bool,string)(TMP_396,REF_104)\n\t\tExpression: bit = 1 << ((reserveIndex << 1) + 1)\n\t\tIRs:\n\t\t\tTMP_398(uint256) = reserveIndex << 1\n\t\t\tTMP_399(uint256) = TMP_398 + 1\n\t\t\tTMP_400(uint256) = 1 << TMP_399\n\t\t\tbit(uint256) := TMP_400(uint256)\n\t\tExpression: usingAsCollateral\n\t\tIRs:\n\t\t\tCONDITION usingAsCollateral\n\t\tExpression: self.data |= bit\n\t\tIRs:\n\t\t\tREF_105(uint256) -> self.data\n\t\t\tREF_105(-> self) = REF_105 | bit\n\t\tExpression: self.data &= ~ bit\n\t\tIRs:\n\t\t\tREF_106(uint256) -> self.data\n\t\t\tTMP_401 = UnaryType.TILD bit \n\t\t\tREF_106(-> self) = REF_106 & TMP_401\n\tFunction UserConfiguration.isUsingAsCollateralOrBorrowing(DataTypes.UserConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_107(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_402(bool) = reserveIndex < REF_107\n\t\t\tREF_108(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_403(None) = SOLIDITY_CALL require(bool,string)(TMP_402,REF_108)\n\t\tExpression: (self.data >> (reserveIndex << 1)) & 3 != 0\n\t\tIRs:\n\t\t\tREF_109(uint256) -> self.data\n\t\t\tTMP_404(uint256) = reserveIndex << 1\n\t\t\tTMP_405(uint256) = REF_109 >> TMP_404\n\t\t\tTMP_406(uint256) = TMP_405 & 3\n\t\t\tTMP_407(bool) = TMP_406 != 0\n\t\t\tRETURN TMP_407\n\tFunction UserConfiguration.isBorrowing(DataTypes.UserConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_110(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_408(bool) = reserveIndex < REF_110\n\t\t\tREF_111(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_409(None) = SOLIDITY_CALL require(bool,string)(TMP_408,REF_111)\n\t\tExpression: (self.data >> (reserveIndex << 1)) & 1 != 0\n\t\tIRs:\n\t\t\tREF_112(uint256) -> self.data\n\t\t\tTMP_410(uint256) = reserveIndex << 1\n\t\t\tTMP_411(uint256) = REF_112 >> TMP_410\n\t\t\tTMP_412(uint256) = TMP_411 & 1\n\t\t\tTMP_413(bool) = TMP_412 != 0\n\t\t\tRETURN TMP_413\n\tFunction UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256) (*)\n\t\tExpression: require(bool,string)(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT,Errors.INVALID_RESERVE_INDEX)\n\t\tIRs:\n\t\t\tREF_113(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tTMP_414(bool) = reserveIndex < REF_113\n\t\t\tREF_114(string) -> Errors.INVALID_RESERVE_INDEX\n\t\t\tTMP_415(None) = SOLIDITY_CALL require(bool,string)(TMP_414,REF_114)\n\t\tExpression: (self.data >> ((reserveIndex << 1) + 1)) & 1 != 0\n\t\tIRs:\n\t\t\tREF_115(uint256) -> self.data\n\t\t\tTMP_416(uint256) = reserveIndex << 1\n\t\t\tTMP_417(uint256) = TMP_416 + 1\n\t\t\tTMP_418(uint256) = REF_115 >> TMP_417\n\t\t\tTMP_419(uint256) = TMP_418 & 1\n\t\t\tTMP_420(bool) = TMP_419 != 0\n\t\t\tRETURN TMP_420\n\tFunction UserConfiguration.isUsingAsCollateralOne(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: collateralData = self.data & COLLATERAL_MASK\n\t\tIRs:\n\t\t\tREF_116(uint256) -> self.data\n\t\t\tTMP_421(uint256) = REF_116 & COLLATERAL_MASK\n\t\t\tcollateralData(uint256) := TMP_421(uint256)\n\t\tExpression: collateralData != 0 && (collateralData & (collateralData - 1) == 0)\n\t\tIRs:\n\t\t\tTMP_422(bool) = collateralData != 0\n\t\t\tTMP_423(uint256) = collateralData (c)- 1\n\t\t\tTMP_424(uint256) = collateralData & TMP_423\n\t\t\tTMP_425(bool) = TMP_424 == 0\n\t\t\tTMP_426(bool) = TMP_422 && TMP_425\n\t\t\tRETURN TMP_426\n\tFunction UserConfiguration.isUsingAsCollateralAny(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: self.data & COLLATERAL_MASK != 0\n\t\tIRs:\n\t\t\tREF_117(uint256) -> self.data\n\t\t\tTMP_427(uint256) = REF_117 & COLLATERAL_MASK\n\t\t\tTMP_428(bool) = TMP_427 != 0\n\t\t\tRETURN TMP_428\n\tFunction UserConfiguration.isBorrowingOne(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: borrowingData = self.data & BORROWING_MASK\n\t\tIRs:\n\t\t\tREF_118(uint256) -> self.data\n\t\t\tTMP_429(uint256) = REF_118 & BORROWING_MASK\n\t\t\tborrowingData(uint256) := TMP_429(uint256)\n\t\tExpression: borrowingData != 0 && (borrowingData & (borrowingData - 1) == 0)\n\t\tIRs:\n\t\t\tTMP_430(bool) = borrowingData != 0\n\t\t\tTMP_431(uint256) = borrowingData (c)- 1\n\t\t\tTMP_432(uint256) = borrowingData & TMP_431\n\t\t\tTMP_433(bool) = TMP_432 == 0\n\t\t\tTMP_434(bool) = TMP_430 && TMP_433\n\t\t\tRETURN TMP_434\n\tFunction UserConfiguration.isBorrowingAny(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: self.data & BORROWING_MASK != 0\n\t\tIRs:\n\t\t\tREF_119(uint256) -> self.data\n\t\t\tTMP_435(uint256) = REF_119 & BORROWING_MASK\n\t\t\tTMP_436(bool) = TMP_435 != 0\n\t\t\tRETURN TMP_436\n\tFunction UserConfiguration.isEmpty(DataTypes.UserConfigurationMap) (*)\n\t\tExpression: self.data == 0\n\t\tIRs:\n\t\t\tREF_120(uint256) -> self.data\n\t\t\tTMP_437(bool) = REF_120 == 0\n\t\t\tRETURN TMP_437\n\tFunction UserConfiguration.getIsolationModeState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)) (*)\n\t\tExpression: isUsingAsCollateralOne(self)\n\t\tIRs:\n\t\t\tTMP_438(bool) = INTERNAL_CALL, UserConfiguration.isUsingAsCollateralOne(DataTypes.UserConfigurationMap)(self)\n\t\t\tCONDITION TMP_438\n\t\tExpression: assetId = _getFirstAssetIdByMask(self,COLLATERAL_MASK)\n\t\tIRs:\n\t\t\tTMP_439(uint256) = INTERNAL_CALL, UserConfiguration._getFirstAssetIdByMask(DataTypes.UserConfigurationMap,uint256)(self,COLLATERAL_MASK)\n\t\t\tassetId(uint256) := TMP_439(uint256)\n\t\tExpression: assetAddress = reservesList[assetId]\n\t\tIRs:\n\t\t\tREF_121(address) -> reservesList[assetId]\n\t\t\tassetAddress(address) := REF_121(address)\n\t\tExpression: ceiling = reservesData[assetAddress].configuration.getDebtCeiling()\n\t\tIRs:\n\t\t\tREF_122(DataTypes.ReserveData) -> reservesData[assetAddress]\n\t\t\tREF_123(DataTypes.ReserveConfigurationMap) -> REF_122.configuration\n\t\t\tTMP_440(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap), arguments:['REF_123'] \n\t\t\tceiling(uint256) := TMP_440(uint256)\n\t\tExpression: ceiling != 0\n\t\tIRs:\n\t\t\tTMP_441(bool) = ceiling != 0\n\t\t\tCONDITION TMP_441\n\t\tExpression: (true,assetAddress,ceiling)\n\t\tIRs:\n\t\t\tRETURN True,assetAddress,ceiling\n\t\tExpression: (false,address(0),0)\n\t\tIRs:\n\t\t\tTMP_442 = CONVERT 0 to address\n\t\t\tRETURN False,TMP_442,0\n\tFunction UserConfiguration.getSiloedBorrowingState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)) (*)\n\t\tExpression: isBorrowingOne(self)\n\t\tIRs:\n\t\t\tTMP_443(bool) = INTERNAL_CALL, UserConfiguration.isBorrowingOne(DataTypes.UserConfigurationMap)(self)\n\t\t\tCONDITION TMP_443\n\t\tExpression: assetId = _getFirstAssetIdByMask(self,BORROWING_MASK)\n\t\tIRs:\n\t\t\tTMP_444(uint256) = INTERNAL_CALL, UserConfiguration._getFirstAssetIdByMask(DataTypes.UserConfigurationMap,uint256)(self,BORROWING_MASK)\n\t\t\tassetId(uint256) := TMP_444(uint256)\n\t\tExpression: assetAddress = reservesList[assetId]\n\t\tIRs:\n\t\t\tREF_125(address) -> reservesList[assetId]\n\t\t\tassetAddress(address) := REF_125(address)\n\t\tExpression: reservesData[assetAddress].configuration.getSiloedBorrowing()\n\t\tIRs:\n\t\t\tREF_126(DataTypes.ReserveData) -> reservesData[assetAddress]\n\t\t\tREF_127(DataTypes.ReserveConfigurationMap) -> REF_126.configuration\n\t\t\tTMP_445(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getSiloedBorrowing(DataTypes.ReserveConfigurationMap), arguments:['REF_127'] \n\t\t\tCONDITION TMP_445\n\t\tExpression: (true,assetAddress)\n\t\tIRs:\n\t\t\tRETURN True,assetAddress\n\t\tExpression: (false,address(0))\n\t\tIRs:\n\t\t\tTMP_446 = CONVERT 0 to address\n\t\t\tRETURN False,TMP_446\n\tFunction UserConfiguration._getFirstAssetIdByMask(DataTypes.UserConfigurationMap,uint256) (*)\n\t\tExpression: bitmapData = self.data & mask\n\t\tIRs:\n\t\t\tREF_129(uint256) -> self.data\n\t\t\tTMP_447(uint256) = REF_129 & mask\n\t\t\tbitmapData(uint256) := TMP_447(uint256)\n\t\tExpression: firstAssetPosition = bitmapData & ~ (bitmapData - 1)\n\t\tIRs:\n\t\t\tTMP_448(uint256) = bitmapData - 1\n\t\t\tTMP_449 = UnaryType.TILD TMP_448 \n\t\t\tTMP_450(uint256) = bitmapData & TMP_449\n\t\t\tfirstAssetPosition(uint256) := TMP_450(uint256)\n\t\tExpression: (firstAssetPosition >>= 2) != 0\n\t\tIRs:\n\t\t\tfirstAssetPosition(uint256) = firstAssetPosition >> 2\n\t\t\tTMP_451(bool) = firstAssetPosition != 0\n\t\t\tCONDITION TMP_451\n\t\tExpression: id += 1\n\t\tIRs:\n\t\t\tid(uint256) = id + 1\n\t\tExpression: id\n\t\tIRs:\n\t\t\tRETURN id\n\tFunction UserConfiguration.slitherConstructorConstantVariables() (*)\n\t\tExpression: BORROWING_MASK = 0x5555555555555555555555555555555555555555555555555555555555555555\n\t\tIRs:\n\t\t\tBORROWING_MASK(uint256) := 38597363079105398474523661669562635951089994888546854679819194669304376546645(uint256)\n\t\tExpression: COLLATERAL_MASK = 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\t\tIRs:\n\t\t\tCOLLATERAL_MASK(uint256) := 77194726158210796949047323339125271902179989777093709359638389338608753093290(uint256)\nContract Errors\n\tFunction Errors.slitherConstructorConstantVariables() (*)\n\t\tExpression: CALLER_NOT_POOL_ADMIN = 1\n\t\tIRs:\n\t\t\tCALLER_NOT_POOL_ADMIN(string) := 1(string)\n\t\tExpression: CALLER_NOT_EMERGENCY_ADMIN = 2\n\t\tIRs:\n\t\t\tCALLER_NOT_EMERGENCY_ADMIN(string) := 2(string)\n\t\tExpression: CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = 3\n\t\tIRs:\n\t\t\tCALLER_NOT_POOL_OR_EMERGENCY_ADMIN(string) := 3(string)\n\t\tExpression: CALLER_NOT_RISK_OR_POOL_ADMIN = 4\n\t\tIRs:\n\t\t\tCALLER_NOT_RISK_OR_POOL_ADMIN(string) := 4(string)\n\t\tExpression: CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = 5\n\t\tIRs:\n\t\t\tCALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN(string) := 5(string)\n\t\tExpression: CALLER_NOT_BRIDGE = 6\n\t\tIRs:\n\t\t\tCALLER_NOT_BRIDGE(string) := 6(string)\n\t\tExpression: ADDRESSES_PROVIDER_NOT_REGISTERED = 7\n\t\tIRs:\n\t\t\tADDRESSES_PROVIDER_NOT_REGISTERED(string) := 7(string)\n\t\tExpression: INVALID_ADDRESSES_PROVIDER_ID = 8\n\t\tIRs:\n\t\t\tINVALID_ADDRESSES_PROVIDER_ID(string) := 8(string)\n\t\tExpression: NOT_CONTRACT = 9\n\t\tIRs:\n\t\t\tNOT_CONTRACT(string) := 9(string)\n\t\tExpression: CALLER_NOT_POOL_CONFIGURATOR = 10\n\t\tIRs:\n\t\t\tCALLER_NOT_POOL_CONFIGURATOR(string) := 10(string)\n\t\tExpression: CALLER_NOT_ATOKEN = 11\n\t\tIRs:\n\t\t\tCALLER_NOT_ATOKEN(string) := 11(string)\n\t\tExpression: INVALID_ADDRESSES_PROVIDER = 12\n\t\tIRs:\n\t\t\tINVALID_ADDRESSES_PROVIDER(string) := 12(string)\n\t\tExpression: INVALID_FLASHLOAN_EXECUTOR_RETURN = 13\n\t\tIRs:\n\t\t\tINVALID_FLASHLOAN_EXECUTOR_RETURN(string) := 13(string)\n\t\tExpression: RESERVE_ALREADY_ADDED = 14\n\t\tIRs:\n\t\t\tRESERVE_ALREADY_ADDED(string) := 14(string)\n\t\tExpression: NO_MORE_RESERVES_ALLOWED = 15\n\t\tIRs:\n\t\t\tNO_MORE_RESERVES_ALLOWED(string) := 15(string)\n\t\tExpression: EMODE_CATEGORY_RESERVED = 16\n\t\tIRs:\n\t\t\tEMODE_CATEGORY_RESERVED(string) := 16(string)\n\t\tExpression: INVALID_EMODE_CATEGORY_ASSIGNMENT = 17\n\t\tIRs:\n\t\t\tINVALID_EMODE_CATEGORY_ASSIGNMENT(string) := 17(string)\n\t\tExpression: RESERVE_LIQUIDITY_NOT_ZERO = 18\n\t\tIRs:\n\t\t\tRESERVE_LIQUIDITY_NOT_ZERO(string) := 18(string)\n\t\tExpression: FLASHLOAN_PREMIUM_INVALID = 19\n\t\tIRs:\n\t\t\tFLASHLOAN_PREMIUM_INVALID(string) := 19(string)\n\t\tExpression: INVALID_RESERVE_PARAMS = 20\n\t\tIRs:\n\t\t\tINVALID_RESERVE_PARAMS(string) := 20(string)\n\t\tExpression: INVALID_EMODE_CATEGORY_PARAMS = 21\n\t\tIRs:\n\t\t\tINVALID_EMODE_CATEGORY_PARAMS(string) := 21(string)\n\t\tExpression: BRIDGE_PROTOCOL_FEE_INVALID = 22\n\t\tIRs:\n\t\t\tBRIDGE_PROTOCOL_FEE_INVALID(string) := 22(string)\n\t\tExpression: CALLER_MUST_BE_POOL = 23\n\t\tIRs:\n\t\t\tCALLER_MUST_BE_POOL(string) := 23(string)\n\t\tExpression: INVALID_MINT_AMOUNT = 24\n\t\tIRs:\n\t\t\tINVALID_MINT_AMOUNT(string) := 24(string)\n\t\tExpression: INVALID_BURN_AMOUNT = 25\n\t\tIRs:\n\t\t\tINVALID_BURN_AMOUNT(string) := 25(string)\n\t\tExpression: INVALID_AMOUNT = 26\n\t\tIRs:\n\t\t\tINVALID_AMOUNT(string) := 26(string)\n\t\tExpression: RESERVE_INACTIVE = 27\n\t\tIRs:\n\t\t\tRESERVE_INACTIVE(string) := 27(string)\n\t\tExpression: RESERVE_FROZEN = 28\n\t\tIRs:\n\t\t\tRESERVE_FROZEN(string) := 28(string)\n\t\tExpression: RESERVE_PAUSED = 29\n\t\tIRs:\n\t\t\tRESERVE_PAUSED(string) := 29(string)\n\t\tExpression: BORROWING_NOT_ENABLED = 30\n\t\tIRs:\n\t\t\tBORROWING_NOT_ENABLED(string) := 30(string)\n\t\tExpression: STABLE_BORROWING_NOT_ENABLED = 31\n\t\tIRs:\n\t\t\tSTABLE_BORROWING_NOT_ENABLED(string) := 31(string)\n\t\tExpression: NOT_ENOUGH_AVAILABLE_USER_BALANCE = 32\n\t\tIRs:\n\t\t\tNOT_ENOUGH_AVAILABLE_USER_BALANCE(string) := 32(string)\n\t\tExpression: INVALID_INTEREST_RATE_MODE_SELECTED = 33\n\t\tIRs:\n\t\t\tINVALID_INTEREST_RATE_MODE_SELECTED(string) := 33(string)\n\t\tExpression: COLLATERAL_BALANCE_IS_ZERO = 34\n\t\tIRs:\n\t\t\tCOLLATERAL_BALANCE_IS_ZERO(string) := 34(string)\n\t\tExpression: HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = 35\n\t\tIRs:\n\t\t\tHEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD(string) := 35(string)\n\t\tExpression: COLLATERAL_CANNOT_COVER_NEW_BORROW = 36\n\t\tIRs:\n\t\t\tCOLLATERAL_CANNOT_COVER_NEW_BORROW(string) := 36(string)\n\t\tExpression: COLLATERAL_SAME_AS_BORROWING_CURRENCY = 37\n\t\tIRs:\n\t\t\tCOLLATERAL_SAME_AS_BORROWING_CURRENCY(string) := 37(string)\n\t\tExpression: AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = 38\n\t\tIRs:\n\t\t\tAMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE(string) := 38(string)\n\t\tExpression: NO_DEBT_OF_SELECTED_TYPE = 39\n\t\tIRs:\n\t\t\tNO_DEBT_OF_SELECTED_TYPE(string) := 39(string)\n\t\tExpression: NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = 40\n\t\tIRs:\n\t\t\tNO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF(string) := 40(string)\n\t\tExpression: NO_OUTSTANDING_STABLE_DEBT = 41\n\t\tIRs:\n\t\t\tNO_OUTSTANDING_STABLE_DEBT(string) := 41(string)\n\t\tExpression: NO_OUTSTANDING_VARIABLE_DEBT = 42\n\t\tIRs:\n\t\t\tNO_OUTSTANDING_VARIABLE_DEBT(string) := 42(string)\n\t\tExpression: UNDERLYING_BALANCE_ZERO = 43\n\t\tIRs:\n\t\t\tUNDERLYING_BALANCE_ZERO(string) := 43(string)\n\t\tExpression: INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = 44\n\t\tIRs:\n\t\t\tINTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET(string) := 44(string)\n\t\tExpression: HEALTH_FACTOR_NOT_BELOW_THRESHOLD = 45\n\t\tIRs:\n\t\t\tHEALTH_FACTOR_NOT_BELOW_THRESHOLD(string) := 45(string)\n\t\tExpression: COLLATERAL_CANNOT_BE_LIQUIDATED = 46\n\t\tIRs:\n\t\t\tCOLLATERAL_CANNOT_BE_LIQUIDATED(string) := 46(string)\n\t\tExpression: SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = 47\n\t\tIRs:\n\t\t\tSPECIFIED_CURRENCY_NOT_BORROWED_BY_USER(string) := 47(string)\n\t\tExpression: INCONSISTENT_FLASHLOAN_PARAMS = 49\n\t\tIRs:\n\t\t\tINCONSISTENT_FLASHLOAN_PARAMS(string) := 49(string)\n\t\tExpression: BORROW_CAP_EXCEEDED = 50\n\t\tIRs:\n\t\t\tBORROW_CAP_EXCEEDED(string) := 50(string)\n\t\tExpression: SUPPLY_CAP_EXCEEDED = 51\n\t\tIRs:\n\t\t\tSUPPLY_CAP_EXCEEDED(string) := 51(string)\n\t\tExpression: UNBACKED_MINT_CAP_EXCEEDED = 52\n\t\tIRs:\n\t\t\tUNBACKED_MINT_CAP_EXCEEDED(string) := 52(string)\n\t\tExpression: DEBT_CEILING_EXCEEDED = 53\n\t\tIRs:\n\t\t\tDEBT_CEILING_EXCEEDED(string) := 53(string)\n\t\tExpression: UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = 54\n\t\tIRs:\n\t\t\tUNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO(string) := 54(string)\n\t\tExpression: STABLE_DEBT_NOT_ZERO = 55\n\t\tIRs:\n\t\t\tSTABLE_DEBT_NOT_ZERO(string) := 55(string)\n\t\tExpression: VARIABLE_DEBT_SUPPLY_NOT_ZERO = 56\n\t\tIRs:\n\t\t\tVARIABLE_DEBT_SUPPLY_NOT_ZERO(string) := 56(string)\n\t\tExpression: LTV_VALIDATION_FAILED = 57\n\t\tIRs:\n\t\t\tLTV_VALIDATION_FAILED(string) := 57(string)\n\t\tExpression: INCONSISTENT_EMODE_CATEGORY = 58\n\t\tIRs:\n\t\t\tINCONSISTENT_EMODE_CATEGORY(string) := 58(string)\n\t\tExpression: PRICE_ORACLE_SENTINEL_CHECK_FAILED = 59\n\t\tIRs:\n\t\t\tPRICE_ORACLE_SENTINEL_CHECK_FAILED(string) := 59(string)\n\t\tExpression: ASSET_NOT_BORROWABLE_IN_ISOLATION = 60\n\t\tIRs:\n\t\t\tASSET_NOT_BORROWABLE_IN_ISOLATION(string) := 60(string)\n\t\tExpression: RESERVE_ALREADY_INITIALIZED = 61\n\t\tIRs:\n\t\t\tRESERVE_ALREADY_INITIALIZED(string) := 61(string)\n\t\tExpression: USER_IN_ISOLATION_MODE_OR_LTV_ZERO = 62\n\t\tIRs:\n\t\t\tUSER_IN_ISOLATION_MODE_OR_LTV_ZERO(string) := 62(string)\n\t\tExpression: INVALID_LTV = 63\n\t\tIRs:\n\t\t\tINVALID_LTV(string) := 63(string)\n\t\tExpression: INVALID_LIQ_THRESHOLD = 64\n\t\tIRs:\n\t\t\tINVALID_LIQ_THRESHOLD(string) := 64(string)\n\t\tExpression: INVALID_LIQ_BONUS = 65\n\t\tIRs:\n\t\t\tINVALID_LIQ_BONUS(string) := 65(string)\n\t\tExpression: INVALID_DECIMALS = 66\n\t\tIRs:\n\t\t\tINVALID_DECIMALS(string) := 66(string)\n\t\tExpression: INVALID_RESERVE_FACTOR = 67\n\t\tIRs:\n\t\t\tINVALID_RESERVE_FACTOR(string) := 67(string)\n\t\tExpression: INVALID_BORROW_CAP = 68\n\t\tIRs:\n\t\t\tINVALID_BORROW_CAP(string) := 68(string)\n\t\tExpression: INVALID_SUPPLY_CAP = 69\n\t\tIRs:\n\t\t\tINVALID_SUPPLY_CAP(string) := 69(string)\n\t\tExpression: INVALID_LIQUIDATION_PROTOCOL_FEE = 70\n\t\tIRs:\n\t\t\tINVALID_LIQUIDATION_PROTOCOL_FEE(string) := 70(string)\n\t\tExpression: INVALID_EMODE_CATEGORY = 71\n\t\tIRs:\n\t\t\tINVALID_EMODE_CATEGORY(string) := 71(string)\n\t\tExpression: INVALID_UNBACKED_MINT_CAP = 72\n\t\tIRs:\n\t\t\tINVALID_UNBACKED_MINT_CAP(string) := 72(string)\n\t\tExpression: INVALID_DEBT_CEILING = 73\n\t\tIRs:\n\t\t\tINVALID_DEBT_CEILING(string) := 73(string)\n\t\tExpression: INVALID_RESERVE_INDEX = 74\n\t\tIRs:\n\t\t\tINVALID_RESERVE_INDEX(string) := 74(string)\n\t\tExpression: ACL_ADMIN_CANNOT_BE_ZERO = 75\n\t\tIRs:\n\t\t\tACL_ADMIN_CANNOT_BE_ZERO(string) := 75(string)\n\t\tExpression: INCONSISTENT_PARAMS_LENGTH = 76\n\t\tIRs:\n\t\t\tINCONSISTENT_PARAMS_LENGTH(string) := 76(string)\n\t\tExpression: ZERO_ADDRESS_NOT_VALID = 77\n\t\tIRs:\n\t\t\tZERO_ADDRESS_NOT_VALID(string) := 77(string)\n\t\tExpression: INVALID_EXPIRATION = 78\n\t\tIRs:\n\t\t\tINVALID_EXPIRATION(string) := 78(string)\n\t\tExpression: INVALID_SIGNATURE = 79\n\t\tIRs:\n\t\t\tINVALID_SIGNATURE(string) := 79(string)\n\t\tExpression: OPERATION_NOT_SUPPORTED = 80\n\t\tIRs:\n\t\t\tOPERATION_NOT_SUPPORTED(string) := 80(string)\n\t\tExpression: DEBT_CEILING_NOT_ZERO = 81\n\t\tIRs:\n\t\t\tDEBT_CEILING_NOT_ZERO(string) := 81(string)\n\t\tExpression: ASSET_NOT_LISTED = 82\n\t\tIRs:\n\t\t\tASSET_NOT_LISTED(string) := 82(string)\n\t\tExpression: INVALID_OPTIMAL_USAGE_RATIO = 83\n\t\tIRs:\n\t\t\tINVALID_OPTIMAL_USAGE_RATIO(string) := 83(string)\n\t\tExpression: INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = 84\n\t\tIRs:\n\t\t\tINVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO(string) := 84(string)\n\t\tExpression: UNDERLYING_CANNOT_BE_RESCUED = 85\n\t\tIRs:\n\t\t\tUNDERLYING_CANNOT_BE_RESCUED(string) := 85(string)\n\t\tExpression: ADDRESSES_PROVIDER_ALREADY_ADDED = 86\n\t\tIRs:\n\t\t\tADDRESSES_PROVIDER_ALREADY_ADDED(string) := 86(string)\n\t\tExpression: POOL_ADDRESSES_DO_NOT_MATCH = 87\n\t\tIRs:\n\t\t\tPOOL_ADDRESSES_DO_NOT_MATCH(string) := 87(string)\n\t\tExpression: STABLE_BORROWING_ENABLED = 88\n\t\tIRs:\n\t\t\tSTABLE_BORROWING_ENABLED(string) := 88(string)\n\t\tExpression: SILOED_BORROWING_VIOLATION = 89\n\t\tIRs:\n\t\t\tSILOED_BORROWING_VIOLATION(string) := 89(string)\n\t\tExpression: RESERVE_DEBT_NOT_ZERO = 90\n\t\tIRs:\n\t\t\tRESERVE_DEBT_NOT_ZERO(string) := 90(string)\n\t\tExpression: FLASHLOAN_DISABLED = 91\n\t\tIRs:\n\t\t\tFLASHLOAN_DISABLED(string) := 91(string)\nContract Helpers\n\tFunction Helpers.getUserCurrentDebt(address,DataTypes.ReserveCache) (*)\n\t\tExpression: (IERC20(reserveCache.stableDebtTokenAddress).balanceOf(user),IERC20(reserveCache.variableDebtTokenAddress).balanceOf(user))\n\t\tIRs:\n\t\t\tREF_130(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_452 = CONVERT REF_130 to IERC20\n\t\t\tTMP_453(uint256) = HIGH_LEVEL_CALL, dest:TMP_452(IERC20), function:balanceOf, arguments:['user']  \n\t\t\tREF_132(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_454 = CONVERT REF_132 to IERC20\n\t\t\tTMP_455(uint256) = HIGH_LEVEL_CALL, dest:TMP_454(IERC20), function:balanceOf, arguments:['user']  \n\t\t\tRETURN TMP_453,TMP_455\nContract BorrowLogic\n\tFunction BorrowLogic.executeBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteBorrowParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_134(address) -> params.asset\n\t\t\tREF_135(DataTypes.ReserveData) -> reservesData[REF_134]\n\t\t\treserve(DataTypes.ReserveData) := REF_135(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_456(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_456(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: (isolationModeActive,isolationModeCollateralAddress,isolationModeDebtCeiling) = userConfig.getIsolationModeState(reservesData,reservesList)\n\t\tIRs:\n\t\t\tTUPLE_4(bool,address,uint256) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.getIsolationModeState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)), arguments:['userConfig', 'reservesData', 'reservesList'] \n\t\t\tisolationModeActive(bool)= UNPACK TUPLE_4 index: 0 \n\t\t\tisolationModeCollateralAddress(address)= UNPACK TUPLE_4 index: 1 \n\t\t\tisolationModeDebtCeiling(uint256)= UNPACK TUPLE_4 index: 2 \n\t\tExpression: ValidationLogic.validateBorrow(reservesData,reservesList,eModeCategories,DataTypes.ValidateBorrowParams({reserveCache:reserveCache,userConfig:userConfig,asset:params.asset,userAddress:params.onBehalfOf,amount:params.amount,interestRateMode:params.interestRateMode,maxStableLoanPercent:params.maxStableRateBorrowSizePercent,reservesCount:params.reservesCount,oracle:params.oracle,userEModeCategory:params.userEModeCategory,priceOracleSentinel:params.priceOracleSentinel,isolationModeActive:isolationModeActive,isolationModeCollateralAddress:isolationModeCollateralAddress,isolationModeDebtCeiling:isolationModeDebtCeiling}))\n\t\tIRs:\n\t\t\tREF_141(address) -> params.asset\n\t\t\tREF_142(address) -> params.onBehalfOf\n\t\t\tREF_143(uint256) -> params.amount\n\t\t\tREF_144(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_145(uint256) -> params.maxStableRateBorrowSizePercent\n\t\t\tREF_146(uint256) -> params.reservesCount\n\t\t\tREF_147(address) -> params.oracle\n\t\t\tREF_148(uint8) -> params.userEModeCategory\n\t\t\tREF_149(address) -> params.priceOracleSentinel\n\t\t\tTMP_458(DataTypes.ValidateBorrowParams) = new ValidateBorrowParams(reserveCache,userConfig,REF_141,REF_142,REF_143,REF_144,REF_145,REF_146,REF_147,REF_148,REF_149,isolationModeActive,isolationModeCollateralAddress,isolationModeDebtCeiling)\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.ValidateBorrowParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'TMP_458'] \n\t\tExpression: currentStableRate = 0\n\t\tIRs:\n\t\t\tcurrentStableRate(uint256) := 0(uint256)\n\t\tExpression: isFirstBorrowing = false\n\t\tIRs:\n\t\t\tisFirstBorrowing(bool) := False(bool)\n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_150(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_151(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_460(bool) = REF_150 == REF_151\n\t\t\tCONDITION TMP_460\n\t\tExpression: currentStableRate = reserve.currentStableBorrowRate\n\t\tIRs:\n\t\t\tREF_152(uint128) -> reserve.currentStableBorrowRate\n\t\t\tcurrentStableRate(uint256) := REF_152(uint128)\n\t\tExpression: (isFirstBorrowing,reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(reserveCache.stableDebtTokenAddress).mint(params.user,params.onBehalfOf,params.amount,currentStableRate)\n\t\tIRs:\n\t\t\tREF_153(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_154(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_155(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_461 = CONVERT REF_155 to IStableDebtToken\n\t\t\tREF_157(address) -> params.user\n\t\t\tREF_158(address) -> params.onBehalfOf\n\t\t\tREF_159(uint256) -> params.amount\n\t\t\tTUPLE_5(bool,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_461(IStableDebtToken), function:mint, arguments:['REF_157', 'REF_158', 'REF_159', 'currentStableRate']  \n\t\t\tisFirstBorrowing(bool)= UNPACK TUPLE_5 index: 0 \n\t\t\tREF_153(uint256)= UNPACK TUPLE_5 index: 1 \n\t\t\tREF_154(uint256)= UNPACK TUPLE_5 index: 2 \n\t\tExpression: (isFirstBorrowing,reserveCache.nextScaledVariableDebt) = IVariableDebtToken(reserveCache.variableDebtTokenAddress).mint(params.user,params.onBehalfOf,params.amount,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_160(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_161(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_462 = CONVERT REF_161 to IVariableDebtToken\n\t\t\tREF_163(address) -> params.user\n\t\t\tREF_164(address) -> params.onBehalfOf\n\t\t\tREF_165(uint256) -> params.amount\n\t\t\tREF_166(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTUPLE_6(bool,uint256) = HIGH_LEVEL_CALL, dest:TMP_462(IVariableDebtToken), function:mint, arguments:['REF_163', 'REF_164', 'REF_165', 'REF_166']  \n\t\t\tisFirstBorrowing(bool)= UNPACK TUPLE_6 index: 0 \n\t\t\tREF_160(uint256)= UNPACK TUPLE_6 index: 1 \n\t\tExpression: isFirstBorrowing\n\t\tIRs:\n\t\t\tCONDITION isFirstBorrowing\n\t\tExpression: userConfig.setBorrowing(reserve.id,true)\n\t\tIRs:\n\t\t\tREF_168(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setBorrowing(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_168', 'True'] \n\t\tExpression: isolationModeActive\n\t\tIRs:\n\t\t\tCONDITION isolationModeActive\n\t\tExpression: nextIsolationModeTotalDebt = reservesData[isolationModeCollateralAddress].isolationModeTotalDebt += (params.amount / 10 ** (reserveCache.reserveConfiguration.getDecimals() - ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128()\n\t\tIRs:\n\t\t\tREF_169(DataTypes.ReserveData) -> reservesData[isolationModeCollateralAddress]\n\t\t\tREF_170(uint128) -> REF_169.isolationModeTotalDebt\n\t\t\tREF_171(uint256) -> params.amount\n\t\t\tREF_172(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_464(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_172'] \n\t\t\tREF_174(uint256) -> ReserveConfiguration.DEBT_CEILING_DECIMALS\n\t\t\tTMP_465(uint256) = TMP_464 (c)- REF_174\n\t\t\tTMP_466(uint256) = 10 (c)** TMP_465\n\t\t\tTMP_467(uint256) = REF_171 (c)/ TMP_466\n\t\t\tTMP_468(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_467'] \n\t\t\tREF_170(-> reservesData) = REF_170 (c)+ TMP_468\n\t\t\tnextIsolationModeTotalDebt(uint256) := REF_170(uint128)\n\t\tExpression: IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,nextIsolationModeTotalDebt)\n\t\tIRs:\n\t\t\tEmit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,nextIsolationModeTotalDebt)\n\t\tExpression: params.releaseUnderlying\n\t\tIRs:\n\t\t\tREF_176(bool) -> params.releaseUnderlying\n\t\t\tCONDITION REF_176\n\t\tExpression: IAToken(reserveCache.aTokenAddress).transferUnderlyingTo(params.user,params.amount)\n\t\tIRs:\n\t\t\tREF_177(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_470 = CONVERT REF_177 to IAToken\n\t\t\tREF_179(address) -> params.user\n\t\t\tREF_180(uint256) -> params.amount\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_470(IAToken), function:transferUnderlyingTo, arguments:['REF_179', 'REF_180']  \n\t\tExpression: params.releaseUnderlying\n\t\tIRs:\n\t\t\tREF_181(bool) -> params.releaseUnderlying\n\t\t\tCONDITION REF_181\n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,0,params.amount)\n\t\tIRs:\n\t\t\tREF_183(address) -> params.asset\n\t\t\tREF_184(uint256) -> params.amount\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_183', '0', 'REF_184'] \n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,0,0)\n\t\tIRs:\n\t\t\tREF_186(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_186', '0', '0'] \n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_187(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_188(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_474(bool) = REF_187 == REF_188\n\t\t\tCONDITION TMP_474\n\t\tExpression: Borrow(params.asset,params.user,params.onBehalfOf,params.amount,params.interestRateMode,currentStableRate,params.referralCode)\n\t\tIRs:\n\t\t\tREF_189(address) -> params.asset\n\t\t\tREF_190(address) -> params.user\n\t\t\tREF_191(address) -> params.onBehalfOf\n\t\t\tREF_192(uint256) -> params.amount\n\t\t\tREF_193(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_194(uint16) -> params.referralCode\n\t\t\tEmit Borrow(REF_189,REF_190,REF_191,REF_192,REF_193,currentStableRate,REF_194)\n\t\tExpression: Borrow(params.asset,params.user,params.onBehalfOf,params.amount,params.interestRateMode,reserve.currentVariableBorrowRate,params.referralCode)\n\t\tIRs:\n\t\t\tREF_195(address) -> params.asset\n\t\t\tREF_196(address) -> params.user\n\t\t\tREF_197(address) -> params.onBehalfOf\n\t\t\tREF_198(uint256) -> params.amount\n\t\t\tREF_199(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_200(uint128) -> reserve.currentVariableBorrowRate\n\t\t\tREF_201(uint16) -> params.referralCode\n\t\t\tEmit Borrow(REF_195,REF_196,REF_197,REF_198,REF_199,REF_200,REF_201)\n\tFunction BorrowLogic.executeRepay(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteRepayParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_202(address) -> params.asset\n\t\t\tREF_203(DataTypes.ReserveData) -> reservesData[REF_202]\n\t\t\treserve(DataTypes.ReserveData) := REF_203(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_477(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_477(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: (stableDebt,variableDebt) = Helpers.getUserCurrentDebt(params.onBehalfOf,reserveCache)\n\t\tIRs:\n\t\t\tREF_207(address) -> params.onBehalfOf\n\t\t\tTUPLE_7(uint256,uint256) = LIBRARY_CALL, dest:Helpers, function:Helpers.getUserCurrentDebt(address,DataTypes.ReserveCache), arguments:['REF_207', 'reserveCache'] \n\t\t\tstableDebt(uint256)= UNPACK TUPLE_7 index: 0 \n\t\t\tvariableDebt(uint256)= UNPACK TUPLE_7 index: 1 \n\t\tExpression: ValidationLogic.validateRepay(reserveCache,params.amount,params.interestRateMode,params.onBehalfOf,stableDebt,variableDebt)\n\t\tIRs:\n\t\t\tREF_209(uint256) -> params.amount\n\t\t\tREF_210(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_211(address) -> params.onBehalfOf\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateRepay(DataTypes.ReserveCache,uint256,DataTypes.InterestRateMode,address,uint256,uint256), arguments:['reserveCache', 'REF_209', 'REF_210', 'REF_211', 'stableDebt', 'variableDebt'] \n\t\tExpression: params.useATokens && params.amount == type()(uint256).max\n\t\tIRs:\n\t\t\tREF_212(bool) -> params.useATokens\n\t\t\tREF_213(uint256) -> params.amount\n\t\t\tTMP_481(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tTMP_482(bool) = REF_213 == TMP_481\n\t\t\tTMP_483(bool) = REF_212 && TMP_482\n\t\t\tCONDITION TMP_483\n\t\tExpression: params.amount = IAToken(reserveCache.aTokenAddress).balanceOf(msg.sender)\n\t\tIRs:\n\t\t\tREF_214(uint256) -> params.amount\n\t\t\tREF_215(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_484 = CONVERT REF_215 to IAToken\n\t\t\tTMP_485(uint256) = HIGH_LEVEL_CALL, dest:TMP_484(IAToken), function:balanceOf, arguments:['msg.sender']  \n\t\t\tREF_214(uint256) (->params) := TMP_485(uint256)\n\t\tExpression: params.amount < paybackAmount\n\t\tIRs:\n\t\t\tREF_217(uint256) -> params.amount\n\t\t\tTMP_486(bool) = REF_217 < paybackAmount\n\t\t\tCONDITION TMP_486\n\t\tExpression: paybackAmount = params.amount\n\t\tIRs:\n\t\t\tREF_218(uint256) -> params.amount\n\t\t\tpaybackAmount(uint256) := REF_218(uint256)\n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_219(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_220(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_487(bool) = REF_219 == REF_220\n\t\t\tCONDITION TMP_487\n\t\tExpression: (reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(reserveCache.stableDebtTokenAddress).burn(params.onBehalfOf,paybackAmount)\n\t\tIRs:\n\t\t\tREF_221(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_222(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_223(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_488 = CONVERT REF_223 to IStableDebtToken\n\t\t\tREF_225(address) -> params.onBehalfOf\n\t\t\tTUPLE_8(uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_488(IStableDebtToken), function:burn, arguments:['REF_225', 'paybackAmount']  \n\t\t\tREF_221(uint256)= UNPACK TUPLE_8 index: 0 \n\t\t\tREF_222(uint256)= UNPACK TUPLE_8 index: 1 \n\t\tExpression: reserveCache.nextScaledVariableDebt = IVariableDebtToken(reserveCache.variableDebtTokenAddress).burn(params.onBehalfOf,paybackAmount,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_226(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_227(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_489 = CONVERT REF_227 to IVariableDebtToken\n\t\t\tREF_229(address) -> params.onBehalfOf\n\t\t\tREF_230(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_490(uint256) = HIGH_LEVEL_CALL, dest:TMP_489(IVariableDebtToken), function:burn, arguments:['REF_229', 'paybackAmount', 'REF_230']  \n\t\t\tREF_226(uint256) (->reserveCache) := TMP_490(uint256)\n\t\tExpression: stableDebt + variableDebt - paybackAmount == 0\n\t\tIRs:\n\t\t\tTMP_491(uint256) = stableDebt (c)+ variableDebt\n\t\t\tTMP_492(uint256) = TMP_491 (c)- paybackAmount\n\t\t\tTMP_493(bool) = TMP_492 == 0\n\t\t\tCONDITION TMP_493\n\t\tExpression: userConfig.setBorrowing(reserve.id,false)\n\t\tIRs:\n\t\t\tREF_232(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setBorrowing(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_232', 'False'] \n\t\tExpression: IsolationModeLogic.updateIsolatedDebtIfIsolated(reservesData,reservesList,userConfig,reserveCache,paybackAmount)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:IsolationModeLogic, function:IsolationModeLogic.updateIsolatedDebtIfIsolated(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveCache,uint256), arguments:['reservesData', 'reservesList', 'userConfig', 'reserveCache', 'paybackAmount'] \n\t\tExpression: params.useATokens\n\t\tIRs:\n\t\t\tREF_234(bool) -> params.useATokens\n\t\t\tCONDITION REF_234\n\t\tExpression: IAToken(reserveCache.aTokenAddress).burn(msg.sender,reserveCache.aTokenAddress,paybackAmount,reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_235(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_496 = CONVERT REF_235 to IAToken\n\t\t\tREF_237(address) -> reserveCache.aTokenAddress\n\t\t\tREF_238(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_496(IAToken), function:burn, arguments:['msg.sender', 'REF_237', 'paybackAmount', 'REF_238']  \n\t\tExpression: IERC20(params.asset).safeTransferFrom(msg.sender,reserveCache.aTokenAddress,paybackAmount)\n\t\tIRs:\n\t\t\tREF_239(address) -> params.asset\n\t\t\tTMP_498 = CONVERT REF_239 to IERC20\n\t\t\tREF_241(address) -> reserveCache.aTokenAddress\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_498', 'msg.sender', 'REF_241', 'paybackAmount'] \n\t\tExpression: IAToken(reserveCache.aTokenAddress).handleRepayment(msg.sender,params.onBehalfOf,paybackAmount)\n\t\tIRs:\n\t\t\tREF_242(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_500 = CONVERT REF_242 to IAToken\n\t\t\tREF_244(address) -> params.onBehalfOf\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_500(IAToken), function:handleRepayment, arguments:['msg.sender', 'REF_244', 'paybackAmount']  \n\t\tExpression: Repay(params.asset,params.onBehalfOf,msg.sender,paybackAmount,params.useATokens)\n\t\tIRs:\n\t\t\tREF_245(address) -> params.asset\n\t\t\tREF_246(address) -> params.onBehalfOf\n\t\t\tREF_247(bool) -> params.useATokens\n\t\t\tEmit Repay(REF_245,REF_246,msg.sender,paybackAmount,REF_247)\n\t\tExpression: paybackAmount\n\t\tIRs:\n\t\t\tRETURN paybackAmount\n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_248(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_249(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_503(bool) = REF_248 == REF_249\n\t\t\tCONDITION TMP_503\n\t\tExpression: paybackAmount = stableDebt\n\t\tIRs:\n\t\t\tpaybackAmount(uint256) := stableDebt(uint256)\n\t\tExpression: paybackAmount = variableDebt\n\t\tIRs:\n\t\t\tpaybackAmount(uint256) := variableDebt(uint256)\n\t\tExpression: params.useATokens\n\t\tIRs:\n\t\t\tREF_250(bool) -> params.useATokens\n\t\t\tCONDITION REF_250\n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,0,0)\n\t\tIRs:\n\t\t\tREF_252(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_252', '0', '0'] \n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,paybackAmount,0)\n\t\tIRs:\n\t\t\tREF_254(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_254', 'paybackAmount', '0'] \n\tFunction BorrowLogic.executeRebalanceStableBorrowRate(DataTypes.ReserveData,address,address) (*)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_506(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_506(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: ValidationLogic.validateRebalanceStableBorrowRate(reserve,reserveCache,asset)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateRebalanceStableBorrowRate(DataTypes.ReserveData,DataTypes.ReserveCache,address), arguments:['reserve', 'reserveCache', 'asset'] \n\t\tExpression: stableDebtToken = IStableDebtToken(reserveCache.stableDebtTokenAddress)\n\t\tIRs:\n\t\t\tREF_258(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_509 = CONVERT REF_258 to IStableDebtToken\n\t\t\tstableDebtToken(IStableDebtToken) := TMP_509(IStableDebtToken)\n\t\tExpression: stableDebt = IERC20(address(stableDebtToken)).balanceOf(user)\n\t\tIRs:\n\t\t\tTMP_510 = CONVERT stableDebtToken to address\n\t\t\tTMP_511 = CONVERT TMP_510 to IERC20\n\t\t\tTMP_512(uint256) = HIGH_LEVEL_CALL, dest:TMP_511(IERC20), function:balanceOf, arguments:['user']  \n\t\t\tstableDebt(uint256) := TMP_512(uint256)\n\t\tExpression: stableDebtToken.burn(user,stableDebt)\n\t\tIRs:\n\t\t\tTUPLE_9(uint256,uint256) = HIGH_LEVEL_CALL, dest:stableDebtToken(IStableDebtToken), function:burn, arguments:['user', 'stableDebt']  \n\t\tExpression: (None,reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = stableDebtToken.mint(user,user,stableDebt,reserve.currentStableBorrowRate)\n\t\tIRs:\n\t\t\tREF_261(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_262(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_264(uint128) -> reserve.currentStableBorrowRate\n\t\t\tTUPLE_10(bool,uint256,uint256) = HIGH_LEVEL_CALL, dest:stableDebtToken(IStableDebtToken), function:mint, arguments:['user', 'user', 'stableDebt', 'REF_264']  \n\t\t\tREF_261(uint256)= UNPACK TUPLE_10 index: 1 \n\t\t\tREF_262(uint256)= UNPACK TUPLE_10 index: 2 \n\t\tExpression: reserve.updateInterestRates(reserveCache,asset,0,0)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'asset', '0', '0'] \n\t\tExpression: RebalanceStableBorrowRate(asset,user)\n\t\tIRs:\n\t\t\tEmit RebalanceStableBorrowRate(asset,user)\n\tFunction BorrowLogic.executeSwapBorrowRateMode(DataTypes.ReserveData,DataTypes.UserConfigurationMap,address,DataTypes.InterestRateMode) (*)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_515(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_515(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: (stableDebt,variableDebt) = Helpers.getUserCurrentDebt(msg.sender,reserveCache)\n\t\tIRs:\n\t\t\tTUPLE_11(uint256,uint256) = LIBRARY_CALL, dest:Helpers, function:Helpers.getUserCurrentDebt(address,DataTypes.ReserveCache), arguments:['msg.sender', 'reserveCache'] \n\t\t\tstableDebt(uint256)= UNPACK TUPLE_11 index: 0 \n\t\t\tvariableDebt(uint256)= UNPACK TUPLE_11 index: 1 \n\t\tExpression: ValidationLogic.validateSwapRateMode(reserve,reserveCache,userConfig,stableDebt,variableDebt,interestRateMode)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSwapRateMode(DataTypes.ReserveData,DataTypes.ReserveCache,DataTypes.UserConfigurationMap,uint256,uint256,DataTypes.InterestRateMode), arguments:['reserve', 'reserveCache', 'userConfig', 'stableDebt', 'variableDebt', 'interestRateMode'] \n\t\tExpression: interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_270(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_518(bool) = interestRateMode == REF_270\n\t\t\tCONDITION TMP_518\n\t\tExpression: (reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(reserveCache.stableDebtTokenAddress).burn(msg.sender,stableDebt)\n\t\tIRs:\n\t\t\tREF_271(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_272(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_273(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_519 = CONVERT REF_273 to IStableDebtToken\n\t\t\tTUPLE_12(uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_519(IStableDebtToken), function:burn, arguments:['msg.sender', 'stableDebt']  \n\t\t\tREF_271(uint256)= UNPACK TUPLE_12 index: 0 \n\t\t\tREF_272(uint256)= UNPACK TUPLE_12 index: 1 \n\t\tExpression: (None,reserveCache.nextScaledVariableDebt) = IVariableDebtToken(reserveCache.variableDebtTokenAddress).mint(msg.sender,msg.sender,stableDebt,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_275(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_276(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_520 = CONVERT REF_276 to IVariableDebtToken\n\t\t\tREF_278(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTUPLE_13(bool,uint256) = HIGH_LEVEL_CALL, dest:TMP_520(IVariableDebtToken), function:mint, arguments:['msg.sender', 'msg.sender', 'stableDebt', 'REF_278']  \n\t\t\tREF_275(uint256)= UNPACK TUPLE_13 index: 1 \n\t\tExpression: reserveCache.nextScaledVariableDebt = IVariableDebtToken(reserveCache.variableDebtTokenAddress).burn(msg.sender,variableDebt,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_279(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_280(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_521 = CONVERT REF_280 to IVariableDebtToken\n\t\t\tREF_282(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_522(uint256) = HIGH_LEVEL_CALL, dest:TMP_521(IVariableDebtToken), function:burn, arguments:['msg.sender', 'variableDebt', 'REF_282']  \n\t\t\tREF_279(uint256) (->reserveCache) := TMP_522(uint256)\n\t\tExpression: (None,reserveCache.nextTotalStableDebt,reserveCache.nextAvgStableBorrowRate) = IStableDebtToken(reserveCache.stableDebtTokenAddress).mint(msg.sender,msg.sender,variableDebt,reserve.currentStableBorrowRate)\n\t\tIRs:\n\t\t\tREF_283(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_284(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_285(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_523 = CONVERT REF_285 to IStableDebtToken\n\t\t\tREF_287(uint128) -> reserve.currentStableBorrowRate\n\t\t\tTUPLE_14(bool,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_523(IStableDebtToken), function:mint, arguments:['msg.sender', 'msg.sender', 'variableDebt', 'REF_287']  \n\t\t\tREF_283(uint256)= UNPACK TUPLE_14 index: 1 \n\t\t\tREF_284(uint256)= UNPACK TUPLE_14 index: 2 \n\t\tExpression: reserve.updateInterestRates(reserveCache,asset,0,0)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'asset', '0', '0'] \n\t\tExpression: SwapBorrowRateMode(asset,msg.sender,interestRateMode)\n\t\tIRs:\n\t\t\tEmit SwapBorrowRateMode(asset,msg.sender,interestRateMode)\nContract BridgeLogic\n\tFunction BridgeLogic.executeMintUnbacked(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,address,uint256,address,uint16) (*)\n\t\tExpression: reserve = reservesData[asset]\n\t\tIRs:\n\t\t\tREF_289(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treserve(DataTypes.ReserveData) := REF_289(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_526(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_526(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: ValidationLogic.validateSupply(reserveCache,reserve,amount)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSupply(DataTypes.ReserveCache,DataTypes.ReserveData,uint256), arguments:['reserveCache', 'reserve', 'amount'] \n\t\tExpression: unbackedMintCap = reserveCache.reserveConfiguration.getUnbackedMintCap()\n\t\tIRs:\n\t\t\tREF_293(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_529(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getUnbackedMintCap(DataTypes.ReserveConfigurationMap), arguments:['REF_293'] \n\t\t\tunbackedMintCap(uint256) := TMP_529(uint256)\n\t\tExpression: reserveDecimals = reserveCache.reserveConfiguration.getDecimals()\n\t\tIRs:\n\t\t\tREF_295(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_530(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_295'] \n\t\t\treserveDecimals(uint256) := TMP_530(uint256)\n\t\tExpression: unbacked = reserve.unbacked += amount.toUint128()\n\t\tIRs:\n\t\t\tREF_297(uint128) -> reserve.unbacked\n\t\t\tTMP_531(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['amount'] \n\t\t\tREF_297(-> reserve) = REF_297 (c)+ TMP_531\n\t\t\tunbacked(uint256) := REF_297(uint128)\n\t\tExpression: require(bool,string)(unbacked <= unbackedMintCap * (10 ** reserveDecimals),Errors.UNBACKED_MINT_CAP_EXCEEDED)\n\t\tIRs:\n\t\t\tTMP_532(uint256) = 10 (c)** reserveDecimals\n\t\t\tTMP_533(uint256) = unbackedMintCap (c)* TMP_532\n\t\t\tTMP_534(bool) = unbacked <= TMP_533\n\t\t\tREF_299(string) -> Errors.UNBACKED_MINT_CAP_EXCEEDED\n\t\t\tTMP_535(None) = SOLIDITY_CALL require(bool,string)(TMP_534,REF_299)\n\t\tExpression: reserve.updateInterestRates(reserveCache,asset,0,0)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'asset', '0', '0'] \n\t\tExpression: isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(msg.sender,onBehalfOf,amount,reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_301(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_537 = CONVERT REF_301 to IAToken\n\t\t\tREF_303(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_538(bool) = HIGH_LEVEL_CALL, dest:TMP_537(IAToken), function:mint, arguments:['msg.sender', 'onBehalfOf', 'amount', 'REF_303']  \n\t\t\tisFirstSupply(bool) := TMP_538(bool)\n\t\tExpression: isFirstSupply\n\t\tIRs:\n\t\t\tCONDITION isFirstSupply\n\t\tExpression: ValidationLogic.validateAutomaticUseAsCollateral(reservesData,reservesList,userConfig,reserveCache.reserveConfiguration,reserveCache.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_305(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tREF_306(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_539(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address), arguments:['reservesData', 'reservesList', 'userConfig', 'REF_305', 'REF_306'] \n\t\t\tCONDITION TMP_539\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,true)\n\t\tIRs:\n\t\t\tREF_308(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_308', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(asset,onBehalfOf)\n\t\tIRs:\n\t\t\tEmit ReserveUsedAsCollateralEnabled(asset,onBehalfOf)\n\t\tExpression: MintUnbacked(asset,msg.sender,onBehalfOf,amount,referralCode)\n\t\tIRs:\n\t\t\tEmit MintUnbacked(asset,msg.sender,onBehalfOf,amount,referralCode)\n\tFunction BridgeLogic.executeBackUnbacked(DataTypes.ReserveData,address,uint256,uint256,uint256) (*)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_543(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_543(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: feeToProtocol = fee.percentMul(protocolFeeBps)\n\t\tIRs:\n\t\t\tTMP_545(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['fee', 'protocolFeeBps'] \n\t\t\tfeeToProtocol(uint256) := TMP_545(uint256)\n\t\tExpression: feeToLP = fee - feeToProtocol\n\t\tIRs:\n\t\t\tTMP_546(uint256) = fee (c)- feeToProtocol\n\t\t\tfeeToLP(uint256) := TMP_546(uint256)\n\t\tExpression: added = backingAmount + fee\n\t\tIRs:\n\t\t\tTMP_547(uint256) = backingAmount (c)+ fee\n\t\t\tadded(uint256) := TMP_547(uint256)\n\t\tExpression: reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(IERC20(reserveCache.aTokenAddress).totalSupply() + uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),feeToLP)\n\t\tIRs:\n\t\t\tREF_312(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_314(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_548 = CONVERT REF_314 to IERC20\n\t\t\tTMP_549(uint256) = HIGH_LEVEL_CALL, dest:TMP_548(IERC20), function:totalSupply, arguments:[]  \n\t\t\tREF_316(uint128) -> reserve.accruedToTreasury\n\t\t\tTMP_550 = CONVERT REF_316 to uint256\n\t\t\tREF_318(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_551(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_550', 'REF_318'] \n\t\t\tTMP_552(uint256) = TMP_549 (c)+ TMP_551\n\t\t\tTMP_553(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cumulateToLiquidityIndex(DataTypes.ReserveData,uint256,uint256), arguments:['reserve', 'TMP_552', 'feeToLP'] \n\t\t\tREF_312(uint256) (->reserveCache) := TMP_553(uint256)\n\t\tExpression: reserve.accruedToTreasury += feeToProtocol.rayDiv(reserveCache.nextLiquidityIndex).toUint128()\n\t\tIRs:\n\t\t\tREF_319(uint128) -> reserve.accruedToTreasury\n\t\t\tREF_321(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_554(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['feeToProtocol', 'REF_321'] \n\t\t\tTMP_555(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_554'] \n\t\t\tREF_319(-> reserve) = REF_319 (c)+ TMP_555\n\t\tExpression: reserve.unbacked -= backingAmount.toUint128()\n\t\tIRs:\n\t\t\tREF_323(uint128) -> reserve.unbacked\n\t\t\tTMP_556(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['backingAmount'] \n\t\t\tREF_323(-> reserve) = REF_323 (c)- TMP_556\n\t\tExpression: reserve.updateInterestRates(reserveCache,asset,added,0)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'asset', 'added', '0'] \n\t\tExpression: IERC20(asset).safeTransferFrom(msg.sender,reserveCache.aTokenAddress,added)\n\t\tIRs:\n\t\t\tTMP_558 = CONVERT asset to IERC20\n\t\t\tREF_327(address) -> reserveCache.aTokenAddress\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_558', 'msg.sender', 'REF_327', 'added'] \n\t\tExpression: BackUnbacked(asset,msg.sender,backingAmount,fee)\n\t\tIRs:\n\t\t\tEmit BackUnbacked(asset,msg.sender,backingAmount,fee)\n\t\tExpression: backingAmount\n\t\tIRs:\n\t\t\tRETURN backingAmount\n\t\tExpression: (amount < reserve.unbacked)\n\t\tIRs:\n\t\t\tREF_328(uint128) -> reserve.unbacked\n\t\t\tTMP_561(bool) = amount < REF_328\n\t\t\tCONDITION TMP_561\n\t\tExpression: backingAmount = amount\n\t\tIRs:\n\t\t\tbackingAmount(uint256) := amount(uint256)\n\t\tExpression: backingAmount = reserve.unbacked\n\t\tIRs:\n\t\t\tREF_329(uint128) -> reserve.unbacked\n\t\t\tbackingAmount(uint256) := REF_329(uint128)\nContract EModeLogic\n\tFunction EModeLogic.executeSetUserEMode(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),mapping(address => uint8),DataTypes.UserConfigurationMap,DataTypes.ExecuteSetUserEModeParams) (*)\n\t\tExpression: ValidationLogic.validateSetUserEMode(reservesData,reservesList,eModeCategories,userConfig,params.reservesCount,params.categoryId)\n\t\tIRs:\n\t\t\tREF_331(uint256) -> params.reservesCount\n\t\t\tREF_332(uint8) -> params.categoryId\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSetUserEMode(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,uint256,uint8), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'REF_331', 'REF_332'] \n\t\tExpression: prevCategoryId = usersEModeCategory[msg.sender]\n\t\tIRs:\n\t\t\tREF_333(uint8) -> usersEModeCategory[msg.sender]\n\t\t\tprevCategoryId(uint8) := REF_333(uint8)\n\t\tExpression: usersEModeCategory[msg.sender] = params.categoryId\n\t\tIRs:\n\t\t\tREF_334(uint8) -> usersEModeCategory[msg.sender]\n\t\t\tREF_335(uint8) -> params.categoryId\n\t\t\tREF_334(uint8) (->usersEModeCategory) := REF_335(uint8)\n\t\tExpression: prevCategoryId != 0\n\t\tIRs:\n\t\t\tTMP_563(bool) = prevCategoryId != 0\n\t\t\tCONDITION TMP_563\n\t\tExpression: ValidationLogic.validateHealthFactor(reservesData,reservesList,eModeCategories,userConfig,msg.sender,params.categoryId,params.reservesCount,params.oracle)\n\t\tIRs:\n\t\t\tREF_337(uint8) -> params.categoryId\n\t\t\tREF_338(uint256) -> params.reservesCount\n\t\t\tREF_339(address) -> params.oracle\n\t\t\tTUPLE_15(uint256,bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateHealthFactor(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,uint8,uint256,address), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'msg.sender', 'REF_337', 'REF_338', 'REF_339'] \n\t\tExpression: UserEModeSet(msg.sender,params.categoryId)\n\t\tIRs:\n\t\t\tREF_340(uint8) -> params.categoryId\n\t\t\tEmit UserEModeSet(msg.sender,REF_340)\n\tFunction EModeLogic.getEModeConfiguration(DataTypes.EModeCategory,IPriceOracleGetter) (*)\n\t\tExpression: eModeAssetPrice = 0\n\t\tIRs:\n\t\t\teModeAssetPrice(uint256) := 0(uint256)\n\t\tExpression: eModePriceSource = category.priceSource\n\t\tIRs:\n\t\t\tREF_341(address) -> category.priceSource\n\t\t\teModePriceSource(address) := REF_341(address)\n\t\tExpression: eModePriceSource != address(0)\n\t\tIRs:\n\t\t\tTMP_565 = CONVERT 0 to address\n\t\t\tTMP_566(bool) = eModePriceSource != TMP_565\n\t\t\tCONDITION TMP_566\n\t\tExpression: eModeAssetPrice = oracle.getAssetPrice(eModePriceSource)\n\t\tIRs:\n\t\t\tTMP_567(uint256) = HIGH_LEVEL_CALL, dest:oracle(IPriceOracleGetter), function:getAssetPrice, arguments:['eModePriceSource']  \n\t\t\teModeAssetPrice(uint256) := TMP_567(uint256)\n\t\tExpression: (category.ltv,category.liquidationThreshold,eModeAssetPrice)\n\t\tIRs:\n\t\t\tREF_343(uint16) -> category.ltv\n\t\t\tREF_344(uint16) -> category.liquidationThreshold\n\t\t\tRETURN REF_343,REF_344,eModeAssetPrice\n\tFunction EModeLogic.isInEModeCategory(uint256,uint256) (*)\n\t\tExpression: (eModeUserCategory != 0 && eModeAssetCategory == eModeUserCategory)\n\t\tIRs:\n\t\t\tTMP_568(bool) = eModeUserCategory != 0\n\t\t\tTMP_569(bool) = eModeAssetCategory == eModeUserCategory\n\t\t\tTMP_570(bool) = TMP_568 && TMP_569\n\t\t\tRETURN TMP_570\nContract FlashLoanLogic\n\tFunction FlashLoanLogic.executeFlashLoan(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.FlashloanParams) (*)\n\t\tExpression: ValidationLogic.validateFlashloan(reservesData,params.assets,params.amounts)\n\t\tIRs:\n\t\t\tREF_346(address[]) -> params.assets\n\t\t\tREF_347(uint256[]) -> params.amounts\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateFlashloan(mapping(address => DataTypes.ReserveData),address[],uint256[]), arguments:['reservesData', 'REF_346', 'REF_347'] \n\t\tExpression: vars.totalPremiums = new uint256[](params.assets.length)\n\t\tIRs:\n\t\t\tREF_348(uint256[]) -> vars.totalPremiums\n\t\t\tREF_349(address[]) -> params.assets\n\t\t\tREF_350 -> LENGTH REF_349\n\t\t\tTMP_573(uint256[])  = new uint256[](REF_350)\n\t\t\tREF_348(uint256[]) (->vars) := TMP_573(uint256[])\n\t\tExpression: vars.receiver = IFlashLoanReceiver(params.receiverAddress)\n\t\tIRs:\n\t\t\tREF_351(IFlashLoanReceiver) -> vars.receiver\n\t\t\tREF_352(address) -> params.receiverAddress\n\t\t\tTMP_574 = CONVERT REF_352 to IFlashLoanReceiver\n\t\t\tREF_351(IFlashLoanReceiver) (->vars) := TMP_574(IFlashLoanReceiver)\n\t\tExpression: vars.i = 0\n\t\tIRs:\n\t\t\tREF_353(uint256) -> vars.i\n\t\t\tREF_353(uint256) (->vars) := 0(uint256)\n\t\tExpression: vars.i < params.assets.length\n\t\tIRs:\n\t\t\tREF_354(uint256) -> vars.i\n\t\t\tREF_355(address[]) -> params.assets\n\t\t\tREF_356 -> LENGTH REF_355\n\t\t\tTMP_575(bool) = REF_354 < REF_356\n\t\t\tCONDITION TMP_575\n\t\tExpression: vars.currentAmount = params.amounts[vars.i]\n\t\tIRs:\n\t\t\tREF_357(uint256) -> vars.currentAmount\n\t\t\tREF_358(uint256[]) -> params.amounts\n\t\t\tREF_359(uint256) -> vars.i\n\t\t\tREF_360(uint256) -> REF_358[REF_359]\n\t\t\tREF_357(uint256) (->vars) := REF_360(uint256)\n\t\tExpression: IAToken(reservesData[params.assets[vars.i]].aTokenAddress).transferUnderlyingTo(params.receiverAddress,vars.currentAmount)\n\t\tIRs:\n\t\t\tREF_361(address[]) -> params.assets\n\t\t\tREF_362(uint256) -> vars.i\n\t\t\tREF_363(address) -> REF_361[REF_362]\n\t\t\tREF_364(DataTypes.ReserveData) -> reservesData[REF_363]\n\t\t\tREF_365(address) -> REF_364.aTokenAddress\n\t\t\tTMP_576 = CONVERT REF_365 to IAToken\n\t\t\tREF_367(address) -> params.receiverAddress\n\t\t\tREF_368(uint256) -> vars.currentAmount\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_576(IAToken), function:transferUnderlyingTo, arguments:['REF_367', 'REF_368']  \n\t\tExpression: vars.i ++\n\t\tIRs:\n\t\t\tREF_369(uint256) -> vars.i\n\t\t\tTMP_578(uint256) := REF_369(uint256)\n\t\t\tREF_369(-> vars) = REF_369 (c)+ 1\n\t\tExpression: require(bool,string)(vars.receiver.executeOperation(params.assets,params.amounts,vars.totalPremiums,msg.sender,params.params),Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN)\n\t\tIRs:\n\t\t\tREF_370(IFlashLoanReceiver) -> vars.receiver\n\t\t\tREF_372(address[]) -> params.assets\n\t\t\tREF_373(uint256[]) -> params.amounts\n\t\t\tREF_374(uint256[]) -> vars.totalPremiums\n\t\t\tREF_375(bytes) -> params.params\n\t\t\tTMP_579(bool) = HIGH_LEVEL_CALL, dest:REF_370(IFlashLoanReceiver), function:executeOperation, arguments:['REF_372', 'REF_373', 'REF_374', 'msg.sender', 'REF_375']  \n\t\t\tREF_376(string) -> Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN\n\t\t\tTMP_580(None) = SOLIDITY_CALL require(bool,string)(TMP_579,REF_376)\n\t\tExpression: vars.i = 0\n\t\tIRs:\n\t\t\tREF_377(uint256) -> vars.i\n\t\t\tREF_377(uint256) (->vars) := 0(uint256)\n\t\tExpression: vars.i < params.assets.length\n\t\tIRs:\n\t\t\tREF_378(uint256) -> vars.i\n\t\t\tREF_379(address[]) -> params.assets\n\t\t\tREF_380 -> LENGTH REF_379\n\t\t\tTMP_581(bool) = REF_378 < REF_380\n\t\t\tCONDITION TMP_581\n\t\tExpression: vars.currentAsset = params.assets[vars.i]\n\t\tIRs:\n\t\t\tREF_381(address) -> vars.currentAsset\n\t\t\tREF_382(address[]) -> params.assets\n\t\t\tREF_383(uint256) -> vars.i\n\t\t\tREF_384(address) -> REF_382[REF_383]\n\t\t\tREF_381(address) (->vars) := REF_384(address)\n\t\tExpression: vars.currentAmount = params.amounts[vars.i]\n\t\tIRs:\n\t\t\tREF_385(uint256) -> vars.currentAmount\n\t\t\tREF_386(uint256[]) -> params.amounts\n\t\t\tREF_387(uint256) -> vars.i\n\t\t\tREF_388(uint256) -> REF_386[REF_387]\n\t\t\tREF_385(uint256) (->vars) := REF_388(uint256)\n\t\tExpression: DataTypes.InterestRateMode(params.interestRateModes[vars.i]) == DataTypes.InterestRateMode.NONE\n\t\tIRs:\n\t\t\tREF_389(uint256[]) -> params.interestRateModes\n\t\t\tREF_390(uint256) -> vars.i\n\t\t\tREF_391(uint256) -> REF_389[REF_390]\n\t\t\tTMP_582 = CONVERT REF_391 to DataTypes.InterestRateMode\n\t\t\tREF_392(DataTypes.InterestRateMode) -> InterestRateMode.NONE\n\t\t\tTMP_583(bool) = TMP_582 == REF_392\n\t\t\tCONDITION TMP_583\n\t\tExpression: _handleFlashLoanRepayment(reservesData[vars.currentAsset],DataTypes.FlashLoanRepaymentParams({asset:vars.currentAsset,receiverAddress:params.receiverAddress,amount:vars.currentAmount,totalPremium:vars.totalPremiums[vars.i],flashLoanPremiumToProtocol:vars.flashloanPremiumToProtocol,referralCode:params.referralCode}))\n\t\tIRs:\n\t\t\tREF_393(address) -> vars.currentAsset\n\t\t\tREF_394(DataTypes.ReserveData) -> reservesData[REF_393]\n\t\t\tREF_396(address) -> vars.currentAsset\n\t\t\tREF_397(address) -> params.receiverAddress\n\t\t\tREF_398(uint256) -> vars.currentAmount\n\t\t\tREF_399(uint256[]) -> vars.totalPremiums\n\t\t\tREF_400(uint256) -> vars.i\n\t\t\tREF_401(uint256) -> REF_399[REF_400]\n\t\t\tREF_402(uint256) -> vars.flashloanPremiumToProtocol\n\t\t\tREF_403(uint16) -> params.referralCode\n\t\t\tTMP_584(DataTypes.FlashLoanRepaymentParams) = new FlashLoanRepaymentParams(REF_398,REF_401,REF_402,REF_396,REF_397,REF_403)\n\t\t\tINTERNAL_CALL, FlashLoanLogic._handleFlashLoanRepayment(DataTypes.ReserveData,DataTypes.FlashLoanRepaymentParams)(REF_394,TMP_584)\n\t\tExpression: BorrowLogic.executeBorrow(reservesData,reservesList,eModeCategories,userConfig,DataTypes.ExecuteBorrowParams({asset:vars.currentAsset,user:msg.sender,onBehalfOf:params.onBehalfOf,amount:vars.currentAmount,interestRateMode:DataTypes.InterestRateMode(params.interestRateModes[vars.i]),referralCode:params.referralCode,releaseUnderlying:false,maxStableRateBorrowSizePercent:params.maxStableRateBorrowSizePercent,reservesCount:params.reservesCount,oracle:IPoolAddressesProvider(params.addressesProvider).getPriceOracle(),userEModeCategory:params.userEModeCategory,priceOracleSentinel:IPoolAddressesProvider(params.addressesProvider).getPriceOracleSentinel()}))\n\t\tIRs:\n\t\t\tREF_406(address) -> vars.currentAsset\n\t\t\tREF_407(address) -> params.onBehalfOf\n\t\t\tREF_408(uint256) -> vars.currentAmount\n\t\t\tREF_409(uint256[]) -> params.interestRateModes\n\t\t\tREF_410(uint256) -> vars.i\n\t\t\tREF_411(uint256) -> REF_409[REF_410]\n\t\t\tTMP_586 = CONVERT REF_411 to DataTypes.InterestRateMode\n\t\t\tREF_412(uint16) -> params.referralCode\n\t\t\tREF_413(uint256) -> params.maxStableRateBorrowSizePercent\n\t\t\tREF_414(uint256) -> params.reservesCount\n\t\t\tREF_415(address) -> params.addressesProvider\n\t\t\tTMP_587 = CONVERT REF_415 to IPoolAddressesProvider\n\t\t\tTMP_588(address) = HIGH_LEVEL_CALL, dest:TMP_587(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_417(uint8) -> params.userEModeCategory\n\t\t\tREF_418(address) -> params.addressesProvider\n\t\t\tTMP_589 = CONVERT REF_418 to IPoolAddressesProvider\n\t\t\tTMP_590(address) = HIGH_LEVEL_CALL, dest:TMP_589(IPoolAddressesProvider), function:getPriceOracleSentinel, arguments:[]  \n\t\t\tTMP_591(DataTypes.ExecuteBorrowParams) = new ExecuteBorrowParams(REF_406,msg.sender,REF_407,REF_408,TMP_586,REF_412,False,REF_413,REF_414,TMP_588,REF_417,TMP_590)\n\t\t\tLIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteBorrowParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'TMP_591'] \n\t\tExpression: FlashLoan(params.receiverAddress,msg.sender,vars.currentAsset,vars.currentAmount,DataTypes.InterestRateMode(params.interestRateModes[vars.i]),0,params.referralCode)\n\t\tIRs:\n\t\t\tREF_420(address) -> params.receiverAddress\n\t\t\tREF_421(address) -> vars.currentAsset\n\t\t\tREF_422(uint256) -> vars.currentAmount\n\t\t\tREF_423(uint256[]) -> params.interestRateModes\n\t\t\tREF_424(uint256) -> vars.i\n\t\t\tREF_425(uint256) -> REF_423[REF_424]\n\t\t\tTMP_593 = CONVERT REF_425 to DataTypes.InterestRateMode\n\t\t\tREF_426(uint16) -> params.referralCode\n\t\t\tEmit FlashLoan(REF_420,msg.sender,REF_421,REF_422,TMP_593,0,REF_426)\n\t\tExpression: vars.i ++\n\t\tIRs:\n\t\t\tREF_427(uint256) -> vars.i\n\t\t\tTMP_595(uint256) := REF_427(uint256)\n\t\t\tREF_427(-> vars) = REF_427 (c)+ 1\n\t\tExpression: params.isAuthorizedFlashBorrower\n\t\tIRs:\n\t\t\tREF_428(bool) -> params.isAuthorizedFlashBorrower\n\t\t\tCONDITION REF_428\n\t\tExpression: (vars.flashloanPremiumTotal,vars.flashloanPremiumToProtocol) = (0,0)\n\t\tIRs:\n\t\t\tREF_429(uint256) -> vars.flashloanPremiumTotal\n\t\t\tREF_430(uint256) -> vars.flashloanPremiumToProtocol\n\t\t\tREF_429(uint256) (->vars) := 0(uint256)\n\t\t\tREF_430(uint256) (->vars) := 0(uint256)\n\t\tExpression: (vars.flashloanPremiumTotal,vars.flashloanPremiumToProtocol) = (params.flashLoanPremiumTotal,params.flashLoanPremiumToProtocol)\n\t\tIRs:\n\t\t\tREF_431(uint256) -> vars.flashloanPremiumTotal\n\t\t\tREF_432(uint256) -> vars.flashloanPremiumToProtocol\n\t\t\tREF_433(uint256) -> params.flashLoanPremiumTotal\n\t\t\tREF_434(uint256) -> params.flashLoanPremiumToProtocol\n\t\t\tREF_431(uint256) (->vars) := REF_433(uint256)\n\t\t\tREF_432(uint256) (->vars) := REF_434(uint256)\n\t\tExpression: DataTypes.InterestRateMode(params.interestRateModes[vars.i]) == DataTypes.InterestRateMode.NONE\n\t\tIRs:\n\t\t\tREF_435(uint256[]) -> params.interestRateModes\n\t\t\tREF_436(uint256) -> vars.i\n\t\t\tREF_437(uint256) -> REF_435[REF_436]\n\t\t\tTMP_596 = CONVERT REF_437 to DataTypes.InterestRateMode\n\t\t\tREF_438(DataTypes.InterestRateMode) -> InterestRateMode.NONE\n\t\t\tTMP_597(bool) = TMP_596 == REF_438\n\t\t\tCONDITION TMP_597\n\t\tExpression: vars.totalPremiums[vars.i] = vars.currentAmount.percentMul(vars.flashloanPremiumTotal)\n\t\tIRs:\n\t\t\tREF_439(uint256[]) -> vars.totalPremiums\n\t\t\tREF_440(uint256) -> vars.i\n\t\t\tREF_441(uint256) -> REF_439[REF_440]\n\t\t\tREF_442(uint256) -> vars.currentAmount\n\t\t\tREF_444(uint256) -> vars.flashloanPremiumTotal\n\t\t\tTMP_598(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_442', 'REF_444'] \n\t\t\tREF_441(uint256) (->vars) := TMP_598(uint256)\n\t\tExpression: vars.totalPremiums[vars.i] = 0\n\t\tIRs:\n\t\t\tREF_445(uint256[]) -> vars.totalPremiums\n\t\t\tREF_446(uint256) -> vars.i\n\t\t\tREF_447(uint256) -> REF_445[REF_446]\n\t\t\tREF_447(uint256) (->vars) := 0(uint256)\n\tFunction FlashLoanLogic.executeFlashLoanSimple(DataTypes.ReserveData,DataTypes.FlashloanSimpleParams) (*)\n\t\tExpression: ValidationLogic.validateFlashloanSimple(reserve)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateFlashloanSimple(DataTypes.ReserveData), arguments:['reserve'] \n\t\tExpression: receiver = IFlashLoanSimpleReceiver(params.receiverAddress)\n\t\tIRs:\n\t\t\tREF_449(address) -> params.receiverAddress\n\t\t\tTMP_600 = CONVERT REF_449 to IFlashLoanSimpleReceiver\n\t\t\treceiver(IFlashLoanSimpleReceiver) := TMP_600(IFlashLoanSimpleReceiver)\n\t\tExpression: totalPremium = params.amount.percentMul(params.flashLoanPremiumTotal)\n\t\tIRs:\n\t\t\tREF_450(uint256) -> params.amount\n\t\t\tREF_452(uint256) -> params.flashLoanPremiumTotal\n\t\t\tTMP_601(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_450', 'REF_452'] \n\t\t\ttotalPremium(uint256) := TMP_601(uint256)\n\t\tExpression: IAToken(reserve.aTokenAddress).transferUnderlyingTo(params.receiverAddress,params.amount)\n\t\tIRs:\n\t\t\tREF_453(address) -> reserve.aTokenAddress\n\t\t\tTMP_602 = CONVERT REF_453 to IAToken\n\t\t\tREF_455(address) -> params.receiverAddress\n\t\t\tREF_456(uint256) -> params.amount\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_602(IAToken), function:transferUnderlyingTo, arguments:['REF_455', 'REF_456']  \n\t\tExpression: require(bool,string)(receiver.executeOperation(params.asset,params.amount,totalPremium,msg.sender,params.params),Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN)\n\t\tIRs:\n\t\t\tREF_458(address) -> params.asset\n\t\t\tREF_459(uint256) -> params.amount\n\t\t\tREF_460(bytes) -> params.params\n\t\t\tTMP_604(bool) = HIGH_LEVEL_CALL, dest:receiver(IFlashLoanSimpleReceiver), function:executeOperation, arguments:['REF_458', 'REF_459', 'totalPremium', 'msg.sender', 'REF_460']  \n\t\t\tREF_461(string) -> Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN\n\t\t\tTMP_605(None) = SOLIDITY_CALL require(bool,string)(TMP_604,REF_461)\n\t\tExpression: _handleFlashLoanRepayment(reserve,DataTypes.FlashLoanRepaymentParams({asset:params.asset,receiverAddress:params.receiverAddress,amount:params.amount,totalPremium:totalPremium,flashLoanPremiumToProtocol:params.flashLoanPremiumToProtocol,referralCode:params.referralCode}))\n\t\tIRs:\n\t\t\tREF_463(address) -> params.asset\n\t\t\tREF_464(address) -> params.receiverAddress\n\t\t\tREF_465(uint256) -> params.amount\n\t\t\tREF_466(uint256) -> params.flashLoanPremiumToProtocol\n\t\t\tREF_467(uint16) -> params.referralCode\n\t\t\tTMP_606(DataTypes.FlashLoanRepaymentParams) = new FlashLoanRepaymentParams(REF_465,totalPremium,REF_466,REF_463,REF_464,REF_467)\n\t\t\tINTERNAL_CALL, FlashLoanLogic._handleFlashLoanRepayment(DataTypes.ReserveData,DataTypes.FlashLoanRepaymentParams)(reserve,TMP_606)\n\tFunction FlashLoanLogic._handleFlashLoanRepayment(DataTypes.ReserveData,DataTypes.FlashLoanRepaymentParams) (*)\n\t\tExpression: premiumToProtocol = params.totalPremium.percentMul(params.flashLoanPremiumToProtocol)\n\t\tIRs:\n\t\t\tREF_468(uint256) -> params.totalPremium\n\t\t\tREF_470(uint256) -> params.flashLoanPremiumToProtocol\n\t\t\tTMP_608(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_468', 'REF_470'] \n\t\t\tpremiumToProtocol(uint256) := TMP_608(uint256)\n\t\tExpression: premiumToLP = params.totalPremium - premiumToProtocol\n\t\tIRs:\n\t\t\tREF_471(uint256) -> params.totalPremium\n\t\t\tTMP_609(uint256) = REF_471 (c)- premiumToProtocol\n\t\t\tpremiumToLP(uint256) := TMP_609(uint256)\n\t\tExpression: amountPlusPremium = params.amount + params.totalPremium\n\t\tIRs:\n\t\t\tREF_472(uint256) -> params.amount\n\t\t\tREF_473(uint256) -> params.totalPremium\n\t\t\tTMP_610(uint256) = REF_472 (c)+ REF_473\n\t\t\tamountPlusPremium(uint256) := TMP_610(uint256)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_611(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_611(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(IERC20(reserveCache.aTokenAddress).totalSupply() + uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),premiumToLP)\n\t\tIRs:\n\t\t\tREF_476(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_478(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_613 = CONVERT REF_478 to IERC20\n\t\t\tTMP_614(uint256) = HIGH_LEVEL_CALL, dest:TMP_613(IERC20), function:totalSupply, arguments:[]  \n\t\t\tREF_480(uint128) -> reserve.accruedToTreasury\n\t\t\tTMP_615 = CONVERT REF_480 to uint256\n\t\t\tREF_482(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_616(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_615', 'REF_482'] \n\t\t\tTMP_617(uint256) = TMP_614 (c)+ TMP_616\n\t\t\tTMP_618(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cumulateToLiquidityIndex(DataTypes.ReserveData,uint256,uint256), arguments:['reserve', 'TMP_617', 'premiumToLP'] \n\t\t\tREF_476(uint256) (->reserveCache) := TMP_618(uint256)\n\t\tExpression: reserve.accruedToTreasury += premiumToProtocol.rayDiv(reserveCache.nextLiquidityIndex).toUint128()\n\t\tIRs:\n\t\t\tREF_483(uint128) -> reserve.accruedToTreasury\n\t\t\tREF_485(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_619(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['premiumToProtocol', 'REF_485'] \n\t\t\tTMP_620(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_619'] \n\t\t\tREF_483(-> reserve) = REF_483 (c)+ TMP_620\n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,amountPlusPremium,0)\n\t\tIRs:\n\t\t\tREF_488(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_488', 'amountPlusPremium', '0'] \n\t\tExpression: IERC20(params.asset).safeTransferFrom(params.receiverAddress,reserveCache.aTokenAddress,amountPlusPremium)\n\t\tIRs:\n\t\t\tREF_489(address) -> params.asset\n\t\t\tTMP_622 = CONVERT REF_489 to IERC20\n\t\t\tREF_491(address) -> params.receiverAddress\n\t\t\tREF_492(address) -> reserveCache.aTokenAddress\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_622', 'REF_491', 'REF_492', 'amountPlusPremium'] \n\t\tExpression: IAToken(reserveCache.aTokenAddress).handleRepayment(params.receiverAddress,params.receiverAddress,amountPlusPremium)\n\t\tIRs:\n\t\t\tREF_493(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_624 = CONVERT REF_493 to IAToken\n\t\t\tREF_495(address) -> params.receiverAddress\n\t\t\tREF_496(address) -> params.receiverAddress\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_624(IAToken), function:handleRepayment, arguments:['REF_495', 'REF_496', 'amountPlusPremium']  \n\t\tExpression: FlashLoan(params.receiverAddress,msg.sender,params.asset,params.amount,DataTypes.InterestRateMode(0),params.totalPremium,params.referralCode)\n\t\tIRs:\n\t\t\tREF_497(address) -> params.receiverAddress\n\t\t\tREF_498(address) -> params.asset\n\t\t\tREF_499(uint256) -> params.amount\n\t\t\tTMP_626 = CONVERT 0 to DataTypes.InterestRateMode\n\t\t\tREF_500(uint256) -> params.totalPremium\n\t\t\tREF_501(uint16) -> params.referralCode\n\t\t\tEmit FlashLoan(REF_497,msg.sender,REF_498,REF_499,TMP_626,REF_500,REF_501)\nContract GenericLogic\n\tFunction GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams) (*)\n\t\tExpression: params.userConfig.isEmpty()\n\t\tIRs:\n\t\t\tREF_502(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tTMP_628(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isEmpty(DataTypes.UserConfigurationMap), arguments:['REF_502'] \n\t\t\tCONDITION TMP_628\n\t\tExpression: (0,0,0,0,type()(uint256).max,false)\n\t\tIRs:\n\t\t\tTMP_630(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tRETURN 0,0,0,0,TMP_630,False\n\t\tExpression: params.userEModeCategory != 0\n\t\tIRs:\n\t\t\tREF_504(uint8) -> params.userEModeCategory\n\t\t\tTMP_631(bool) = REF_504 != 0\n\t\t\tCONDITION TMP_631\n\t\tExpression: (vars.eModeLtv,vars.eModeLiqThreshold,vars.eModeAssetPrice) = EModeLogic.getEModeConfiguration(eModeCategories[params.userEModeCategory],IPriceOracleGetter(params.oracle))\n\t\tIRs:\n\t\t\tREF_505(uint256) -> vars.eModeLtv\n\t\t\tREF_506(uint256) -> vars.eModeLiqThreshold\n\t\t\tREF_507(uint256) -> vars.eModeAssetPrice\n\t\t\tREF_509(uint8) -> params.userEModeCategory\n\t\t\tREF_510(DataTypes.EModeCategory) -> eModeCategories[REF_509]\n\t\t\tREF_511(address) -> params.oracle\n\t\t\tTMP_632 = CONVERT REF_511 to IPriceOracleGetter\n\t\t\tTUPLE_16(uint256,uint256,uint256) = LIBRARY_CALL, dest:EModeLogic, function:EModeLogic.getEModeConfiguration(DataTypes.EModeCategory,IPriceOracleGetter), arguments:['REF_510', 'TMP_632'] \n\t\t\tREF_505(uint256)= UNPACK TUPLE_16 index: 0 \n\t\t\tREF_506(uint256)= UNPACK TUPLE_16 index: 1 \n\t\t\tREF_507(uint256)= UNPACK TUPLE_16 index: 2 \n\t\tExpression: vars.i < params.reservesCount\n\t\tIRs:\n\t\t\tREF_512(uint256) -> vars.i\n\t\t\tREF_513(uint256) -> params.reservesCount\n\t\t\tTMP_633(bool) = REF_512 < REF_513\n\t\t\tCONDITION TMP_633\n\t\tExpression: ! params.userConfig.isUsingAsCollateralOrBorrowing(vars.i)\n\t\tIRs:\n\t\t\tREF_514(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_516(uint256) -> vars.i\n\t\t\tTMP_634(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateralOrBorrowing(DataTypes.UserConfigurationMap,uint256), arguments:['REF_514', 'REF_516'] \n\t\t\tTMP_635 = UnaryType.BANG TMP_634 \n\t\t\tCONDITION TMP_635\n\t\tExpression: ++ vars.i\n\t\tIRs:\n\t\t\tREF_517(uint256) -> vars.i\n\t\t\tREF_517(-> vars) = REF_517 + 1\n\t\tExpression: vars.currentReserveAddress = reservesList[vars.i]\n\t\tIRs:\n\t\t\tREF_518(address) -> vars.currentReserveAddress\n\t\t\tREF_519(uint256) -> vars.i\n\t\t\tREF_520(address) -> reservesList[REF_519]\n\t\t\tREF_518(address) (->vars) := REF_520(address)\n\t\tExpression: vars.currentReserveAddress == address(0)\n\t\tIRs:\n\t\t\tREF_521(address) -> vars.currentReserveAddress\n\t\t\tTMP_636 = CONVERT 0 to address\n\t\t\tTMP_637(bool) = REF_521 == TMP_636\n\t\t\tCONDITION TMP_637\n\t\tExpression: ++ vars.i\n\t\tIRs:\n\t\t\tREF_522(uint256) -> vars.i\n\t\t\tREF_522(-> vars) = REF_522 + 1\n\t\tExpression: currentReserve = reservesData[vars.currentReserveAddress]\n\t\tIRs:\n\t\t\tREF_523(address) -> vars.currentReserveAddress\n\t\t\tREF_524(DataTypes.ReserveData) -> reservesData[REF_523]\n\t\t\tcurrentReserve(DataTypes.ReserveData) := REF_524(DataTypes.ReserveData)\n\t\tExpression: (vars.ltv,vars.liquidationThreshold,None,vars.decimals,None,vars.eModeAssetCategory) = currentReserve.configuration.getParams()\n\t\tIRs:\n\t\t\tREF_525(uint256) -> vars.ltv\n\t\t\tREF_526(uint256) -> vars.liquidationThreshold\n\t\t\tREF_527(uint256) -> vars.decimals\n\t\t\tREF_528(uint256) -> vars.eModeAssetCategory\n\t\t\tREF_529(DataTypes.ReserveConfigurationMap) -> currentReserve.configuration\n\t\t\tTUPLE_17(uint256,uint256,uint256,uint256,uint256,uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getParams(DataTypes.ReserveConfigurationMap), arguments:['REF_529'] \n\t\t\tREF_525(uint256)= UNPACK TUPLE_17 index: 0 \n\t\t\tREF_526(uint256)= UNPACK TUPLE_17 index: 1 \n\t\t\tREF_527(uint256)= UNPACK TUPLE_17 index: 3 \n\t\t\tREF_528(uint256)= UNPACK TUPLE_17 index: 5 \n\t\tExpression: vars.assetUnit = 10 ** vars.decimals\n\t\tIRs:\n\t\t\tREF_531(uint256) -> vars.assetUnit\n\t\t\tREF_532(uint256) -> vars.decimals\n\t\t\tTMP_638(uint256) = 10 ** REF_532\n\t\t\tREF_531(uint256) (->vars) := TMP_638(uint256)\n\t\tExpression: vars.liquidationThreshold != 0 && params.userConfig.isUsingAsCollateral(vars.i)\n\t\tIRs:\n\t\t\tREF_533(uint256) -> vars.liquidationThreshold\n\t\t\tTMP_639(bool) = REF_533 != 0\n\t\t\tREF_534(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_536(uint256) -> vars.i\n\t\t\tTMP_640(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['REF_534', 'REF_536'] \n\t\t\tTMP_641(bool) = TMP_639 && TMP_640\n\t\t\tCONDITION TMP_641\n\t\tExpression: vars.userBalanceInBaseCurrency = _getUserBalanceInBaseCurrency(params.user,currentReserve,vars.assetPrice,vars.assetUnit)\n\t\tIRs:\n\t\t\tREF_537(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_538(address) -> params.user\n\t\t\tREF_539(uint256) -> vars.assetPrice\n\t\t\tREF_540(uint256) -> vars.assetUnit\n\t\t\tTMP_642(uint256) = INTERNAL_CALL, GenericLogic._getUserBalanceInBaseCurrency(address,DataTypes.ReserveData,uint256,uint256)(REF_538,currentReserve,REF_539,REF_540)\n\t\t\tREF_537(uint256) (->vars) := TMP_642(uint256)\n\t\tExpression: vars.totalCollateralInBaseCurrency += vars.userBalanceInBaseCurrency\n\t\tIRs:\n\t\t\tREF_541(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tREF_542(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_541(-> vars) = REF_541 (c)+ REF_542\n\t\tExpression: vars.isInEModeCategory = EModeLogic.isInEModeCategory(params.userEModeCategory,vars.eModeAssetCategory)\n\t\tIRs:\n\t\t\tREF_543(bool) -> vars.isInEModeCategory\n\t\t\tREF_545(uint8) -> params.userEModeCategory\n\t\t\tREF_546(uint256) -> vars.eModeAssetCategory\n\t\t\tTMP_643(bool) = LIBRARY_CALL, dest:EModeLogic, function:EModeLogic.isInEModeCategory(uint256,uint256), arguments:['REF_545', 'REF_546'] \n\t\t\tREF_543(bool) (->vars) := TMP_643(bool)\n\t\tExpression: vars.ltv != 0\n\t\tIRs:\n\t\t\tREF_547(uint256) -> vars.ltv\n\t\t\tTMP_644(bool) = REF_547 != 0\n\t\t\tCONDITION TMP_644\n\t\tExpression: vars.hasZeroLtvCollateral = true\n\t\tIRs:\n\t\t\tREF_548(bool) -> vars.hasZeroLtvCollateral\n\t\t\tREF_548(bool) (->vars) := True(bool)\n\t\tExpression: params.userConfig.isBorrowing(vars.i)\n\t\tIRs:\n\t\t\tREF_549(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_551(uint256) -> vars.i\n\t\t\tTMP_645(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowing(DataTypes.UserConfigurationMap,uint256), arguments:['REF_549', 'REF_551'] \n\t\t\tCONDITION TMP_645\n\t\tExpression: vars.totalDebtInBaseCurrency += _getUserDebtInBaseCurrency(params.user,currentReserve,vars.assetPrice,vars.assetUnit)\n\t\tIRs:\n\t\t\tREF_552(uint256) -> vars.totalDebtInBaseCurrency\n\t\t\tREF_553(address) -> params.user\n\t\t\tREF_554(uint256) -> vars.assetPrice\n\t\t\tREF_555(uint256) -> vars.assetUnit\n\t\t\tTMP_646(uint256) = INTERNAL_CALL, GenericLogic._getUserDebtInBaseCurrency(address,DataTypes.ReserveData,uint256,uint256)(REF_553,currentReserve,REF_554,REF_555)\n\t\t\tREF_552(-> vars) = REF_552 (c)+ TMP_646\n\t\tExpression: ++ vars.i\n\t\tIRs:\n\t\t\tREF_556(uint256) -> vars.i\n\t\t\tREF_556(-> vars) = REF_556 + 1\n\t\tExpression: (vars.totalCollateralInBaseCurrency,vars.totalDebtInBaseCurrency,vars.avgLtv,vars.avgLiquidationThreshold,vars.healthFactor,vars.hasZeroLtvCollateral)\n\t\tIRs:\n\t\t\tREF_557(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tREF_558(uint256) -> vars.totalDebtInBaseCurrency\n\t\t\tREF_559(uint256) -> vars.avgLtv\n\t\t\tREF_560(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_561(uint256) -> vars.healthFactor\n\t\t\tREF_562(bool) -> vars.hasZeroLtvCollateral\n\t\t\tRETURN REF_557,REF_558,REF_559,REF_560,REF_561,REF_562\n\t\tExpression: vars.eModeAssetPrice != 0 && params.userEModeCategory == vars.eModeAssetCategory\n\t\tIRs:\n\t\t\tREF_563(uint256) -> vars.eModeAssetPrice\n\t\t\tTMP_647(bool) = REF_563 != 0\n\t\t\tREF_564(uint8) -> params.userEModeCategory\n\t\t\tREF_565(uint256) -> vars.eModeAssetCategory\n\t\t\tTMP_648(bool) = REF_564 == REF_565\n\t\t\tTMP_649(bool) = TMP_647 && TMP_648\n\t\t\tCONDITION TMP_649\n\t\tExpression: vars.assetPrice = vars.eModeAssetPrice\n\t\tIRs:\n\t\t\tREF_566(uint256) -> vars.assetPrice\n\t\t\tREF_567(uint256) -> vars.eModeAssetPrice\n\t\t\tREF_566(uint256) (->vars) := REF_567(uint256)\n\t\tExpression: vars.assetPrice = IPriceOracleGetter(params.oracle).getAssetPrice(vars.currentReserveAddress)\n\t\tIRs:\n\t\t\tREF_568(uint256) -> vars.assetPrice\n\t\t\tREF_569(address) -> params.oracle\n\t\t\tTMP_650 = CONVERT REF_569 to IPriceOracleGetter\n\t\t\tREF_571(address) -> vars.currentReserveAddress\n\t\t\tTMP_651(uint256) = HIGH_LEVEL_CALL, dest:TMP_650(IPriceOracleGetter), function:getAssetPrice, arguments:['REF_571']  \n\t\t\tREF_568(uint256) (->vars) := TMP_651(uint256)\n\t\tExpression: vars.isInEModeCategory\n\t\tIRs:\n\t\t\tREF_572(bool) -> vars.isInEModeCategory\n\t\t\tCONDITION REF_572\n\t\tExpression: vars.avgLtv += vars.userBalanceInBaseCurrency * vars.eModeLtv\n\t\tIRs:\n\t\t\tREF_573(uint256) -> vars.avgLtv\n\t\t\tREF_574(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_575(uint256) -> vars.eModeLtv\n\t\t\tTMP_652(uint256) = REF_574 (c)* REF_575\n\t\t\tREF_573(-> vars) = REF_573 (c)+ TMP_652\n\t\tExpression: vars.avgLtv += vars.userBalanceInBaseCurrency * vars.ltv\n\t\tIRs:\n\t\t\tREF_576(uint256) -> vars.avgLtv\n\t\t\tREF_577(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_578(uint256) -> vars.ltv\n\t\t\tTMP_653(uint256) = REF_577 (c)* REF_578\n\t\t\tREF_576(-> vars) = REF_576 (c)+ TMP_653\n\t\tExpression: vars.isInEModeCategory\n\t\tIRs:\n\t\t\tREF_579(bool) -> vars.isInEModeCategory\n\t\t\tCONDITION REF_579\n\t\tExpression: vars.avgLiquidationThreshold += vars.userBalanceInBaseCurrency * vars.eModeLiqThreshold\n\t\tIRs:\n\t\t\tREF_580(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_581(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_582(uint256) -> vars.eModeLiqThreshold\n\t\t\tTMP_654(uint256) = REF_581 (c)* REF_582\n\t\t\tREF_580(-> vars) = REF_580 (c)+ TMP_654\n\t\tExpression: vars.avgLiquidationThreshold += vars.userBalanceInBaseCurrency * vars.liquidationThreshold\n\t\tIRs:\n\t\t\tREF_583(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_584(uint256) -> vars.userBalanceInBaseCurrency\n\t\t\tREF_585(uint256) -> vars.liquidationThreshold\n\t\t\tTMP_655(uint256) = REF_584 (c)* REF_585\n\t\t\tREF_583(-> vars) = REF_583 (c)+ TMP_655\n\t\tExpression: vars.totalCollateralInBaseCurrency != 0\n\t\tIRs:\n\t\t\tREF_586(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tTMP_656(bool) = REF_586 != 0\n\t\t\tCONDITION TMP_656\n\t\tExpression: vars.avgLtv = vars.avgLtv / vars.totalCollateralInBaseCurrency\n\t\tIRs:\n\t\t\tREF_587(uint256) -> vars.avgLtv\n\t\t\tREF_588(uint256) -> vars.avgLtv\n\t\t\tREF_589(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tTMP_657(uint256) = REF_588 / REF_589\n\t\t\tREF_587(uint256) (->vars) := TMP_657(uint256)\n\t\tExpression: vars.avgLtv = 0\n\t\tIRs:\n\t\t\tREF_590(uint256) -> vars.avgLtv\n\t\t\tREF_590(uint256) (->vars) := 0(uint256)\n\t\tExpression: vars.totalCollateralInBaseCurrency != 0\n\t\tIRs:\n\t\t\tREF_591(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tTMP_658(bool) = REF_591 != 0\n\t\t\tCONDITION TMP_658\n\t\tExpression: vars.avgLiquidationThreshold = vars.avgLiquidationThreshold / vars.totalCollateralInBaseCurrency\n\t\tIRs:\n\t\t\tREF_592(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_593(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_594(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tTMP_659(uint256) = REF_593 / REF_594\n\t\t\tREF_592(uint256) (->vars) := TMP_659(uint256)\n\t\tExpression: vars.avgLiquidationThreshold = 0\n\t\tIRs:\n\t\t\tREF_595(uint256) -> vars.avgLiquidationThreshold\n\t\t\tREF_595(uint256) (->vars) := 0(uint256)\n\t\tExpression: (vars.totalDebtInBaseCurrency == 0)\n\t\tIRs:\n\t\t\tREF_596(uint256) -> vars.totalDebtInBaseCurrency\n\t\t\tTMP_660(bool) = REF_596 == 0\n\t\t\tCONDITION TMP_660\n\t\tExpression: vars.healthFactor = type()(uint256).max\n\t\tIRs:\n\t\t\tREF_597(uint256) -> vars.healthFactor\n\t\t\tTMP_662(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tREF_597(uint256) (->vars) := TMP_662(uint256)\n\t\tExpression: vars.healthFactor = (vars.totalCollateralInBaseCurrency.percentMul(vars.avgLiquidationThreshold)).wadDiv(vars.totalDebtInBaseCurrency)\n\t\tIRs:\n\t\t\tREF_598(uint256) -> vars.healthFactor\n\t\t\tREF_599(uint256) -> vars.totalCollateralInBaseCurrency\n\t\t\tREF_601(uint256) -> vars.avgLiquidationThreshold\n\t\t\tTMP_663(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_599', 'REF_601'] \n\t\t\tREF_603(uint256) -> vars.totalDebtInBaseCurrency\n\t\t\tTMP_664(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.wadDiv(uint256,uint256), arguments:['TMP_663', 'REF_603'] \n\t\t\tREF_598(uint256) (->vars) := TMP_664(uint256)\n\tFunction GenericLogic.calculateAvailableBorrows(uint256,uint256,uint256) (*)\n\t\tExpression: availableBorrowsInBaseCurrency = totalCollateralInBaseCurrency.percentMul(ltv)\n\t\tIRs:\n\t\t\tTMP_665(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['totalCollateralInBaseCurrency', 'ltv'] \n\t\t\tavailableBorrowsInBaseCurrency(uint256) := TMP_665(uint256)\n\t\tExpression: availableBorrowsInBaseCurrency < totalDebtInBaseCurrency\n\t\tIRs:\n\t\t\tTMP_666(bool) = availableBorrowsInBaseCurrency < totalDebtInBaseCurrency\n\t\t\tCONDITION TMP_666\n\t\tExpression: 0\n\t\tIRs:\n\t\t\tRETURN 0\n\t\tExpression: availableBorrowsInBaseCurrency = availableBorrowsInBaseCurrency - totalDebtInBaseCurrency\n\t\tIRs:\n\t\t\tTMP_667(uint256) = availableBorrowsInBaseCurrency (c)- totalDebtInBaseCurrency\n\t\t\tavailableBorrowsInBaseCurrency(uint256) := TMP_667(uint256)\n\t\tExpression: availableBorrowsInBaseCurrency\n\t\tIRs:\n\t\t\tRETURN availableBorrowsInBaseCurrency\n\tFunction GenericLogic._getUserDebtInBaseCurrency(address,DataTypes.ReserveData,uint256,uint256) (*)\n\t\tExpression: userTotalDebt = IScaledBalanceToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user)\n\t\tIRs:\n\t\t\tREF_605(address) -> reserve.variableDebtTokenAddress\n\t\t\tTMP_668 = CONVERT REF_605 to IScaledBalanceToken\n\t\t\tTMP_669(uint256) = HIGH_LEVEL_CALL, dest:TMP_668(IScaledBalanceToken), function:scaledBalanceOf, arguments:['user']  \n\t\t\tuserTotalDebt(uint256) := TMP_669(uint256)\n\t\tExpression: userTotalDebt != 0\n\t\tIRs:\n\t\t\tTMP_670(bool) = userTotalDebt != 0\n\t\t\tCONDITION TMP_670\n\t\tExpression: userTotalDebt = userTotalDebt.rayMul(reserve.getNormalizedDebt())\n\t\tIRs:\n\t\t\tTMP_671(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedDebt(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\tTMP_672(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['userTotalDebt', 'TMP_671'] \n\t\t\tuserTotalDebt(uint256) := TMP_672(uint256)\n\t\tExpression: userTotalDebt = userTotalDebt + IERC20(reserve.stableDebtTokenAddress).balanceOf(user)\n\t\tIRs:\n\t\t\tREF_609(address) -> reserve.stableDebtTokenAddress\n\t\t\tTMP_673 = CONVERT REF_609 to IERC20\n\t\t\tTMP_674(uint256) = HIGH_LEVEL_CALL, dest:TMP_673(IERC20), function:balanceOf, arguments:['user']  \n\t\t\tTMP_675(uint256) = userTotalDebt (c)+ TMP_674\n\t\t\tuserTotalDebt(uint256) := TMP_675(uint256)\n\t\tExpression: userTotalDebt = assetPrice * userTotalDebt\n\t\tIRs:\n\t\t\tTMP_676(uint256) = assetPrice (c)* userTotalDebt\n\t\t\tuserTotalDebt(uint256) := TMP_676(uint256)\n\t\tExpression: userTotalDebt / assetUnit\n\t\tIRs:\n\t\t\tTMP_677(uint256) = userTotalDebt / assetUnit\n\t\t\tRETURN TMP_677\n\tFunction GenericLogic._getUserBalanceInBaseCurrency(address,DataTypes.ReserveData,uint256,uint256) (*)\n\t\tExpression: normalizedIncome = reserve.getNormalizedIncome()\n\t\tIRs:\n\t\t\tTMP_678(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedIncome(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\tnormalizedIncome(uint256) := TMP_678(uint256)\n\t\tExpression: balance = (IScaledBalanceToken(reserve.aTokenAddress).scaledBalanceOf(user).rayMul(normalizedIncome)) * assetPrice\n\t\tIRs:\n\t\t\tREF_612(address) -> reserve.aTokenAddress\n\t\t\tTMP_679 = CONVERT REF_612 to IScaledBalanceToken\n\t\t\tTMP_680(uint256) = HIGH_LEVEL_CALL, dest:TMP_679(IScaledBalanceToken), function:scaledBalanceOf, arguments:['user']  \n\t\t\tTMP_681(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_680', 'normalizedIncome'] \n\t\t\tTMP_682(uint256) = TMP_681 (c)* assetPrice\n\t\t\tbalance(uint256) := TMP_682(uint256)\n\t\tExpression: balance / assetUnit\n\t\tIRs:\n\t\t\tTMP_683(uint256) = balance / assetUnit\n\t\t\tRETURN TMP_683\nContract IsolationModeLogic\n\tFunction IsolationModeLogic.updateIsolatedDebtIfIsolated(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveCache,uint256) (*)\n\t\tExpression: (isolationModeActive,isolationModeCollateralAddress,None) = userConfig.getIsolationModeState(reservesData,reservesList)\n\t\tIRs:\n\t\t\tTUPLE_18(bool,address,uint256) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.getIsolationModeState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)), arguments:['userConfig', 'reservesData', 'reservesList'] \n\t\t\tisolationModeActive(bool)= UNPACK TUPLE_18 index: 0 \n\t\t\tisolationModeCollateralAddress(address)= UNPACK TUPLE_18 index: 1 \n\t\tExpression: isolationModeActive\n\t\tIRs:\n\t\t\tCONDITION isolationModeActive\n\t\tExpression: isolationModeTotalDebt = reservesData[isolationModeCollateralAddress].isolationModeTotalDebt\n\t\tIRs:\n\t\t\tREF_616(DataTypes.ReserveData) -> reservesData[isolationModeCollateralAddress]\n\t\t\tREF_617(uint128) -> REF_616.isolationModeTotalDebt\n\t\t\tisolationModeTotalDebt(uint128) := REF_617(uint128)\n\t\tExpression: isolatedDebtRepaid = (repayAmount / 10 ** (reserveCache.reserveConfiguration.getDecimals() - ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128()\n\t\tIRs:\n\t\t\tREF_618(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_684(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_618'] \n\t\t\tREF_620(uint256) -> ReserveConfiguration.DEBT_CEILING_DECIMALS\n\t\t\tTMP_685(uint256) = TMP_684 (c)- REF_620\n\t\t\tTMP_686(uint256) = 10 (c)** TMP_685\n\t\t\tTMP_687(uint256) = repayAmount (c)/ TMP_686\n\t\t\tTMP_688(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_687'] \n\t\t\tisolatedDebtRepaid(uint128) := TMP_688(uint128)\n\t\tExpression: isolationModeTotalDebt <= isolatedDebtRepaid\n\t\tIRs:\n\t\t\tTMP_689(bool) = isolationModeTotalDebt <= isolatedDebtRepaid\n\t\t\tCONDITION TMP_689\n\t\tExpression: reservesData[isolationModeCollateralAddress].isolationModeTotalDebt = 0\n\t\tIRs:\n\t\t\tREF_622(DataTypes.ReserveData) -> reservesData[isolationModeCollateralAddress]\n\t\t\tREF_623(uint128) -> REF_622.isolationModeTotalDebt\n\t\t\tREF_623(uint128) (->reservesData) := 0(uint256)\n\t\tExpression: IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,0)\n\t\tIRs:\n\t\t\tEmit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,0)\n\t\tExpression: nextIsolationModeTotalDebt = reservesData[isolationModeCollateralAddress].isolationModeTotalDebt = isolationModeTotalDebt - isolatedDebtRepaid\n\t\tIRs:\n\t\t\tREF_624(DataTypes.ReserveData) -> reservesData[isolationModeCollateralAddress]\n\t\t\tREF_625(uint128) -> REF_624.isolationModeTotalDebt\n\t\t\tTMP_691(uint128) = isolationModeTotalDebt (c)- isolatedDebtRepaid\n\t\t\tREF_625(uint128) (->reservesData) := TMP_691(uint128)\n\t\t\tnextIsolationModeTotalDebt(uint256) := REF_625(uint128)\n\t\tExpression: IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,nextIsolationModeTotalDebt)\n\t\tIRs:\n\t\t\tEmit IsolationModeTotalDebtUpdated(isolationModeCollateralAddress,nextIsolationModeTotalDebt)\nContract LiquidationLogic\n\tFunction LiquidationLogic.executeLiquidationCall(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(address => DataTypes.UserConfigurationMap),mapping(uint8 => DataTypes.EModeCategory),DataTypes.ExecuteLiquidationCallParams) (*)\n\t\tExpression: collateralReserve = reservesData[params.collateralAsset]\n\t\tIRs:\n\t\t\tREF_626(address) -> params.collateralAsset\n\t\t\tREF_627(DataTypes.ReserveData) -> reservesData[REF_626]\n\t\t\tcollateralReserve(DataTypes.ReserveData) := REF_627(DataTypes.ReserveData)\n\t\tExpression: debtReserve = reservesData[params.debtAsset]\n\t\tIRs:\n\t\t\tREF_628(address) -> params.debtAsset\n\t\t\tREF_629(DataTypes.ReserveData) -> reservesData[REF_628]\n\t\t\tdebtReserve(DataTypes.ReserveData) := REF_629(DataTypes.ReserveData)\n\t\tExpression: userConfig = usersConfig[params.user]\n\t\tIRs:\n\t\t\tREF_630(address) -> params.user\n\t\t\tREF_631(DataTypes.UserConfigurationMap) -> usersConfig[REF_630]\n\t\t\tuserConfig(DataTypes.UserConfigurationMap) := REF_631(DataTypes.UserConfigurationMap)\n\t\tExpression: vars.debtReserveCache = debtReserve.cache()\n\t\tIRs:\n\t\t\tREF_632(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tTMP_693(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['debtReserve'] \n\t\t\tREF_632(DataTypes.ReserveCache) (->vars) := TMP_693(DataTypes.ReserveCache)\n\t\tExpression: debtReserve.updateState(vars.debtReserveCache)\n\t\tIRs:\n\t\t\tREF_635(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['debtReserve', 'REF_635'] \n\t\tExpression: (None,None,None,None,vars.healthFactor,None) = GenericLogic.calculateUserAccountData(reservesData,reservesList,eModeCategories,DataTypes.CalculateUserAccountDataParams({userConfig:userConfig,reservesCount:params.reservesCount,user:params.user,oracle:params.priceOracle,userEModeCategory:params.userEModeCategory}))\n\t\tIRs:\n\t\t\tREF_636(uint256) -> vars.healthFactor\n\t\t\tREF_639(uint256) -> params.reservesCount\n\t\t\tREF_640(address) -> params.user\n\t\t\tREF_641(address) -> params.priceOracle\n\t\t\tREF_642(uint8) -> params.userEModeCategory\n\t\t\tTMP_695(DataTypes.CalculateUserAccountDataParams) = new CalculateUserAccountDataParams(userConfig,REF_639,REF_640,REF_641,REF_642)\n\t\t\tTUPLE_19(uint256,uint256,uint256,uint256,uint256,bool) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'TMP_695'] \n\t\t\tREF_636(uint256)= UNPACK TUPLE_19 index: 4 \n\t\tExpression: (vars.userVariableDebt,vars.userTotalDebt,vars.actualDebtToLiquidate) = _calculateDebt(vars.debtReserveCache,params,vars.healthFactor)\n\t\tIRs:\n\t\t\tREF_643(uint256) -> vars.userVariableDebt\n\t\t\tREF_644(uint256) -> vars.userTotalDebt\n\t\t\tREF_645(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_646(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_647(uint256) -> vars.healthFactor\n\t\t\tTUPLE_20(uint256,uint256,uint256) = INTERNAL_CALL, LiquidationLogic._calculateDebt(DataTypes.ReserveCache,DataTypes.ExecuteLiquidationCallParams,uint256)(REF_646,params,REF_647)\n\t\t\tREF_643(uint256)= UNPACK TUPLE_20 index: 0 \n\t\t\tREF_644(uint256)= UNPACK TUPLE_20 index: 1 \n\t\t\tREF_645(uint256)= UNPACK TUPLE_20 index: 2 \n\t\tExpression: ValidationLogic.validateLiquidationCall(userConfig,collateralReserve,DataTypes.ValidateLiquidationCallParams({debtReserveCache:vars.debtReserveCache,totalDebt:vars.userTotalDebt,healthFactor:vars.healthFactor,priceOracleSentinel:params.priceOracleSentinel}))\n\t\tIRs:\n\t\t\tREF_650(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_651(uint256) -> vars.userTotalDebt\n\t\t\tREF_652(uint256) -> vars.healthFactor\n\t\t\tREF_653(address) -> params.priceOracleSentinel\n\t\t\tTMP_696(DataTypes.ValidateLiquidationCallParams) = new ValidateLiquidationCallParams(REF_650,REF_651,REF_652,REF_653)\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateLiquidationCall(DataTypes.UserConfigurationMap,DataTypes.ReserveData,DataTypes.ValidateLiquidationCallParams), arguments:['userConfig', 'collateralReserve', 'TMP_696'] \n\t\tExpression: (vars.collateralAToken,vars.collateralPriceSource,vars.debtPriceSource,vars.liquidationBonus) = _getConfigurationData(eModeCategories,collateralReserve,params)\n\t\tIRs:\n\t\t\tREF_654(IAToken) -> vars.collateralAToken\n\t\t\tREF_655(address) -> vars.collateralPriceSource\n\t\t\tREF_656(address) -> vars.debtPriceSource\n\t\t\tREF_657(uint256) -> vars.liquidationBonus\n\t\t\tTUPLE_21(IAToken,address,address,uint256) = INTERNAL_CALL, LiquidationLogic._getConfigurationData(mapping(uint8 => DataTypes.EModeCategory),DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams)(eModeCategories,collateralReserve,params)\n\t\t\tREF_654(IAToken)= UNPACK TUPLE_21 index: 0 \n\t\t\tREF_655(address)= UNPACK TUPLE_21 index: 1 \n\t\t\tREF_656(address)= UNPACK TUPLE_21 index: 2 \n\t\t\tREF_657(uint256)= UNPACK TUPLE_21 index: 3 \n\t\tExpression: vars.userCollateralBalance = vars.collateralAToken.balanceOf(params.user)\n\t\tIRs:\n\t\t\tREF_658(uint256) -> vars.userCollateralBalance\n\t\t\tREF_659(IAToken) -> vars.collateralAToken\n\t\t\tREF_661(address) -> params.user\n\t\t\tTMP_698(uint256) = HIGH_LEVEL_CALL, dest:REF_659(IAToken), function:balanceOf, arguments:['REF_661']  \n\t\t\tREF_658(uint256) (->vars) := TMP_698(uint256)\n\t\tExpression: (vars.actualCollateralToLiquidate,vars.actualDebtToLiquidate,vars.liquidationProtocolFeeAmount) = _calculateAvailableCollateralToLiquidate(collateralReserve,vars.debtReserveCache,vars.collateralPriceSource,vars.debtPriceSource,vars.actualDebtToLiquidate,vars.userCollateralBalance,vars.liquidationBonus,IPriceOracleGetter(params.priceOracle))\n\t\tIRs:\n\t\t\tREF_662(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tREF_663(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_664(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tREF_665(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_666(address) -> vars.collateralPriceSource\n\t\t\tREF_667(address) -> vars.debtPriceSource\n\t\t\tREF_668(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_669(uint256) -> vars.userCollateralBalance\n\t\t\tREF_670(uint256) -> vars.liquidationBonus\n\t\t\tREF_671(address) -> params.priceOracle\n\t\t\tTMP_699 = CONVERT REF_671 to IPriceOracleGetter\n\t\t\tTUPLE_22(uint256,uint256,uint256) = INTERNAL_CALL, LiquidationLogic._calculateAvailableCollateralToLiquidate(DataTypes.ReserveData,DataTypes.ReserveCache,address,address,uint256,uint256,uint256,IPriceOracleGetter)(collateralReserve,REF_665,REF_666,REF_667,REF_668,REF_669,REF_670,TMP_699)\n\t\t\tREF_662(uint256)= UNPACK TUPLE_22 index: 0 \n\t\t\tREF_663(uint256)= UNPACK TUPLE_22 index: 1 \n\t\t\tREF_664(uint256)= UNPACK TUPLE_22 index: 2 \n\t\tExpression: vars.userTotalDebt == vars.actualDebtToLiquidate\n\t\tIRs:\n\t\t\tREF_672(uint256) -> vars.userTotalDebt\n\t\t\tREF_673(uint256) -> vars.actualDebtToLiquidate\n\t\t\tTMP_700(bool) = REF_672 == REF_673\n\t\t\tCONDITION TMP_700\n\t\tExpression: userConfig.setBorrowing(debtReserve.id,false)\n\t\tIRs:\n\t\t\tREF_675(uint16) -> debtReserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setBorrowing(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_675', 'False'] \n\t\tExpression: vars.actualCollateralToLiquidate + vars.liquidationProtocolFeeAmount == vars.userCollateralBalance\n\t\tIRs:\n\t\t\tREF_676(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tREF_677(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tTMP_702(uint256) = REF_676 (c)+ REF_677\n\t\t\tREF_678(uint256) -> vars.userCollateralBalance\n\t\t\tTMP_703(bool) = TMP_702 == REF_678\n\t\t\tCONDITION TMP_703\n\t\tExpression: userConfig.setUsingAsCollateral(collateralReserve.id,false)\n\t\tIRs:\n\t\t\tREF_680(uint16) -> collateralReserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_680', 'False'] \n\t\tExpression: ReserveUsedAsCollateralDisabled(params.collateralAsset,params.user)\n\t\tIRs:\n\t\t\tREF_681(address) -> params.collateralAsset\n\t\t\tREF_682(address) -> params.user\n\t\t\tEmit ReserveUsedAsCollateralDisabled(REF_681,REF_682)\n\t\tExpression: _burnDebtTokens(params,vars)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, LiquidationLogic._burnDebtTokens(DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars)(params,vars)\n\t\tExpression: debtReserve.updateInterestRates(vars.debtReserveCache,params.debtAsset,vars.actualDebtToLiquidate,0)\n\t\tIRs:\n\t\t\tREF_684(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_685(address) -> params.debtAsset\n\t\t\tREF_686(uint256) -> vars.actualDebtToLiquidate\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['debtReserve', 'REF_684', 'REF_685', 'REF_686', '0'] \n\t\tExpression: IsolationModeLogic.updateIsolatedDebtIfIsolated(reservesData,reservesList,userConfig,vars.debtReserveCache,vars.actualDebtToLiquidate)\n\t\tIRs:\n\t\t\tREF_688(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_689(uint256) -> vars.actualDebtToLiquidate\n\t\t\tLIBRARY_CALL, dest:IsolationModeLogic, function:IsolationModeLogic.updateIsolatedDebtIfIsolated(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveCache,uint256), arguments:['reservesData', 'reservesList', 'userConfig', 'REF_688', 'REF_689'] \n\t\tExpression: params.receiveAToken\n\t\tIRs:\n\t\t\tREF_690(bool) -> params.receiveAToken\n\t\t\tCONDITION REF_690\n\t\tExpression: _liquidateATokens(reservesData,reservesList,usersConfig,collateralReserve,params,vars)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, LiquidationLogic._liquidateATokens(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(address => DataTypes.UserConfigurationMap),DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars)(reservesData,reservesList,usersConfig,collateralReserve,params,vars)\n\t\tExpression: _burnCollateralATokens(collateralReserve,params,vars)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, LiquidationLogic._burnCollateralATokens(DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars)(collateralReserve,params,vars)\n\t\tExpression: vars.liquidationProtocolFeeAmount != 0\n\t\tIRs:\n\t\t\tREF_691(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tTMP_711(bool) = REF_691 != 0\n\t\t\tCONDITION TMP_711\n\t\tExpression: liquidityIndex = collateralReserve.getNormalizedIncome()\n\t\tIRs:\n\t\t\tTMP_712(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedIncome(DataTypes.ReserveData), arguments:['collateralReserve'] \n\t\t\tliquidityIndex(uint256) := TMP_712(uint256)\n\t\tExpression: scaledDownLiquidationProtocolFee = vars.liquidationProtocolFeeAmount.rayDiv(liquidityIndex)\n\t\tIRs:\n\t\t\tREF_693(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tTMP_713(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['REF_693', 'liquidityIndex'] \n\t\t\tscaledDownLiquidationProtocolFee(uint256) := TMP_713(uint256)\n\t\tExpression: scaledDownUserBalance = vars.collateralAToken.scaledBalanceOf(params.user)\n\t\tIRs:\n\t\t\tREF_695(IAToken) -> vars.collateralAToken\n\t\t\tREF_697(address) -> params.user\n\t\t\tTMP_714(uint256) = HIGH_LEVEL_CALL, dest:REF_695(IAToken), function:scaledBalanceOf, arguments:['REF_697']  \n\t\t\tscaledDownUserBalance(uint256) := TMP_714(uint256)\n\t\tExpression: scaledDownLiquidationProtocolFee > scaledDownUserBalance\n\t\tIRs:\n\t\t\tTMP_715(bool) = scaledDownLiquidationProtocolFee > scaledDownUserBalance\n\t\t\tCONDITION TMP_715\n\t\tExpression: vars.liquidationProtocolFeeAmount = scaledDownUserBalance.rayMul(liquidityIndex)\n\t\tIRs:\n\t\t\tREF_698(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tTMP_716(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['scaledDownUserBalance', 'liquidityIndex'] \n\t\t\tREF_698(uint256) (->vars) := TMP_716(uint256)\n\t\tExpression: vars.collateralAToken.transferOnLiquidation(params.user,vars.collateralAToken.RESERVE_TREASURY_ADDRESS(),vars.liquidationProtocolFeeAmount)\n\t\tIRs:\n\t\t\tREF_700(IAToken) -> vars.collateralAToken\n\t\t\tREF_702(address) -> params.user\n\t\t\tREF_703(IAToken) -> vars.collateralAToken\n\t\t\tTMP_717(address) = HIGH_LEVEL_CALL, dest:REF_703(IAToken), function:RESERVE_TREASURY_ADDRESS, arguments:[]  \n\t\t\tREF_705(uint256) -> vars.liquidationProtocolFeeAmount\n\t\t\tHIGH_LEVEL_CALL, dest:REF_700(IAToken), function:transferOnLiquidation, arguments:['REF_702', 'TMP_717', 'REF_705']  \n\t\tExpression: IERC20(params.debtAsset).safeTransferFrom(msg.sender,vars.debtReserveCache.aTokenAddress,vars.actualDebtToLiquidate)\n\t\tIRs:\n\t\t\tREF_706(address) -> params.debtAsset\n\t\t\tTMP_719 = CONVERT REF_706 to IERC20\n\t\t\tREF_708(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_709(address) -> REF_708.aTokenAddress\n\t\t\tREF_710(uint256) -> vars.actualDebtToLiquidate\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_719', 'msg.sender', 'REF_709', 'REF_710'] \n\t\tExpression: IAToken(vars.debtReserveCache.aTokenAddress).handleRepayment(msg.sender,params.user,vars.actualDebtToLiquidate)\n\t\tIRs:\n\t\t\tREF_711(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_712(address) -> REF_711.aTokenAddress\n\t\t\tTMP_721 = CONVERT REF_712 to IAToken\n\t\t\tREF_714(address) -> params.user\n\t\t\tREF_715(uint256) -> vars.actualDebtToLiquidate\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_721(IAToken), function:handleRepayment, arguments:['msg.sender', 'REF_714', 'REF_715']  \n\t\tExpression: LiquidationCall(params.collateralAsset,params.debtAsset,params.user,vars.actualDebtToLiquidate,vars.actualCollateralToLiquidate,msg.sender,params.receiveAToken)\n\t\tIRs:\n\t\t\tREF_716(address) -> params.collateralAsset\n\t\t\tREF_717(address) -> params.debtAsset\n\t\t\tREF_718(address) -> params.user\n\t\t\tREF_719(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_720(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tREF_721(bool) -> params.receiveAToken\n\t\t\tEmit LiquidationCall(REF_716,REF_717,REF_718,REF_719,REF_720,msg.sender,REF_721)\n\tFunction LiquidationLogic._burnCollateralATokens(DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars) (*)\n\t\tExpression: collateralReserveCache = collateralReserve.cache()\n\t\tIRs:\n\t\t\tTMP_724(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['collateralReserve'] \n\t\t\tcollateralReserveCache(DataTypes.ReserveCache) := TMP_724(DataTypes.ReserveCache)\n\t\tExpression: collateralReserve.updateState(collateralReserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['collateralReserve', 'collateralReserveCache'] \n\t\tExpression: collateralReserve.updateInterestRates(collateralReserveCache,params.collateralAsset,0,vars.actualCollateralToLiquidate)\n\t\tIRs:\n\t\t\tREF_725(address) -> params.collateralAsset\n\t\t\tREF_726(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['collateralReserve', 'collateralReserveCache', 'REF_725', '0', 'REF_726'] \n\t\tExpression: vars.collateralAToken.burn(params.user,msg.sender,vars.actualCollateralToLiquidate,collateralReserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_727(IAToken) -> vars.collateralAToken\n\t\t\tREF_729(address) -> params.user\n\t\t\tREF_730(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tREF_731(uint256) -> collateralReserveCache.nextLiquidityIndex\n\t\t\tHIGH_LEVEL_CALL, dest:REF_727(IAToken), function:burn, arguments:['REF_729', 'msg.sender', 'REF_730', 'REF_731']  \n\tFunction LiquidationLogic._liquidateATokens(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(address => DataTypes.UserConfigurationMap),DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars) (*)\n\t\tExpression: liquidatorPreviousATokenBalance = IERC20(vars.collateralAToken).balanceOf(msg.sender)\n\t\tIRs:\n\t\t\tREF_732(IAToken) -> vars.collateralAToken\n\t\t\tTMP_728 = CONVERT REF_732 to IERC20\n\t\t\tTMP_729(uint256) = HIGH_LEVEL_CALL, dest:TMP_728(IERC20), function:balanceOf, arguments:['msg.sender']  \n\t\t\tliquidatorPreviousATokenBalance(uint256) := TMP_729(uint256)\n\t\tExpression: vars.collateralAToken.transferOnLiquidation(params.user,msg.sender,vars.actualCollateralToLiquidate)\n\t\tIRs:\n\t\t\tREF_734(IAToken) -> vars.collateralAToken\n\t\t\tREF_736(address) -> params.user\n\t\t\tREF_737(uint256) -> vars.actualCollateralToLiquidate\n\t\t\tHIGH_LEVEL_CALL, dest:REF_734(IAToken), function:transferOnLiquidation, arguments:['REF_736', 'msg.sender', 'REF_737']  \n\t\tExpression: liquidatorPreviousATokenBalance == 0\n\t\tIRs:\n\t\t\tTMP_731(bool) = liquidatorPreviousATokenBalance == 0\n\t\t\tCONDITION TMP_731\n\t\tExpression: liquidatorConfig = usersConfig[msg.sender]\n\t\tIRs:\n\t\t\tREF_738(DataTypes.UserConfigurationMap) -> usersConfig[msg.sender]\n\t\t\tliquidatorConfig(DataTypes.UserConfigurationMap) := REF_738(DataTypes.UserConfigurationMap)\n\t\tExpression: ValidationLogic.validateAutomaticUseAsCollateral(reservesData,reservesList,liquidatorConfig,collateralReserve.configuration,collateralReserve.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_740(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tREF_741(address) -> collateralReserve.aTokenAddress\n\t\t\tTMP_732(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address), arguments:['reservesData', 'reservesList', 'liquidatorConfig', 'REF_740', 'REF_741'] \n\t\t\tCONDITION TMP_732\n\t\tExpression: liquidatorConfig.setUsingAsCollateral(collateralReserve.id,true)\n\t\tIRs:\n\t\t\tREF_743(uint16) -> collateralReserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['liquidatorConfig', 'REF_743', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(params.collateralAsset,msg.sender)\n\t\tIRs:\n\t\t\tREF_744(address) -> params.collateralAsset\n\t\t\tEmit ReserveUsedAsCollateralEnabled(REF_744,msg.sender)\n\tFunction LiquidationLogic._burnDebtTokens(DataTypes.ExecuteLiquidationCallParams,LiquidationLogic.LiquidationCallLocalVars) (*)\n\t\tExpression: vars.userVariableDebt >= vars.actualDebtToLiquidate\n\t\tIRs:\n\t\t\tREF_745(uint256) -> vars.userVariableDebt\n\t\t\tREF_746(uint256) -> vars.actualDebtToLiquidate\n\t\t\tTMP_735(bool) = REF_745 >= REF_746\n\t\t\tCONDITION TMP_735\n\t\tExpression: vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(vars.debtReserveCache.variableDebtTokenAddress).burn(params.user,vars.actualDebtToLiquidate,vars.debtReserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_747(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_748(uint256) -> REF_747.nextScaledVariableDebt\n\t\t\tREF_749(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_750(address) -> REF_749.variableDebtTokenAddress\n\t\t\tTMP_736 = CONVERT REF_750 to IVariableDebtToken\n\t\t\tREF_752(address) -> params.user\n\t\t\tREF_753(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_754(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_755(uint256) -> REF_754.nextVariableBorrowIndex\n\t\t\tTMP_737(uint256) = HIGH_LEVEL_CALL, dest:TMP_736(IVariableDebtToken), function:burn, arguments:['REF_752', 'REF_753', 'REF_755']  \n\t\t\tREF_748(uint256) (->vars) := TMP_737(uint256)\n\t\tExpression: vars.userVariableDebt != 0\n\t\tIRs:\n\t\t\tREF_756(uint256) -> vars.userVariableDebt\n\t\t\tTMP_738(bool) = REF_756 != 0\n\t\t\tCONDITION TMP_738\n\t\tExpression: vars.debtReserveCache.nextScaledVariableDebt = IVariableDebtToken(vars.debtReserveCache.variableDebtTokenAddress).burn(params.user,vars.userVariableDebt,vars.debtReserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_757(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_758(uint256) -> REF_757.nextScaledVariableDebt\n\t\t\tREF_759(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_760(address) -> REF_759.variableDebtTokenAddress\n\t\t\tTMP_739 = CONVERT REF_760 to IVariableDebtToken\n\t\t\tREF_762(address) -> params.user\n\t\t\tREF_763(uint256) -> vars.userVariableDebt\n\t\t\tREF_764(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_765(uint256) -> REF_764.nextVariableBorrowIndex\n\t\t\tTMP_740(uint256) = HIGH_LEVEL_CALL, dest:TMP_739(IVariableDebtToken), function:burn, arguments:['REF_762', 'REF_763', 'REF_765']  \n\t\t\tREF_758(uint256) (->vars) := TMP_740(uint256)\n\t\tExpression: (vars.debtReserveCache.nextTotalStableDebt,vars.debtReserveCache.nextAvgStableBorrowRate) = IStableDebtToken(vars.debtReserveCache.stableDebtTokenAddress).burn(params.user,vars.actualDebtToLiquidate - vars.userVariableDebt)\n\t\tIRs:\n\t\t\tREF_766(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_767(uint256) -> REF_766.nextTotalStableDebt\n\t\t\tREF_768(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_769(uint256) -> REF_768.nextAvgStableBorrowRate\n\t\t\tREF_770(DataTypes.ReserveCache) -> vars.debtReserveCache\n\t\t\tREF_771(address) -> REF_770.stableDebtTokenAddress\n\t\t\tTMP_741 = CONVERT REF_771 to IStableDebtToken\n\t\t\tREF_773(address) -> params.user\n\t\t\tREF_774(uint256) -> vars.actualDebtToLiquidate\n\t\t\tREF_775(uint256) -> vars.userVariableDebt\n\t\t\tTMP_742(uint256) = REF_774 (c)- REF_775\n\t\t\tTUPLE_23(uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_741(IStableDebtToken), function:burn, arguments:['REF_773', 'TMP_742']  \n\t\t\tREF_767(uint256)= UNPACK TUPLE_23 index: 0 \n\t\t\tREF_769(uint256)= UNPACK TUPLE_23 index: 1 \n\tFunction LiquidationLogic._calculateDebt(DataTypes.ReserveCache,DataTypes.ExecuteLiquidationCallParams,uint256) (*)\n\t\tExpression: (userStableDebt,userVariableDebt) = Helpers.getUserCurrentDebt(params.user,debtReserveCache)\n\t\tIRs:\n\t\t\tREF_777(address) -> params.user\n\t\t\tTUPLE_24(uint256,uint256) = LIBRARY_CALL, dest:Helpers, function:Helpers.getUserCurrentDebt(address,DataTypes.ReserveCache), arguments:['REF_777', 'debtReserveCache'] \n\t\t\tuserStableDebt(uint256)= UNPACK TUPLE_24 index: 0 \n\t\t\tuserVariableDebt(uint256)= UNPACK TUPLE_24 index: 1 \n\t\tExpression: userTotalDebt = userStableDebt + userVariableDebt\n\t\tIRs:\n\t\t\tTMP_743(uint256) = userStableDebt (c)+ userVariableDebt\n\t\t\tuserTotalDebt(uint256) := TMP_743(uint256)\n\t\tExpression: maxLiquidatableDebt = userTotalDebt.percentMul(closeFactor)\n\t\tIRs:\n\t\t\tTMP_744(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['userTotalDebt', 'closeFactor'] \n\t\t\tmaxLiquidatableDebt(uint256) := TMP_744(uint256)\n\t\tExpression: (userVariableDebt,userTotalDebt,actualDebtToLiquidate)\n\t\tIRs:\n\t\t\tRETURN userVariableDebt,userTotalDebt,actualDebtToLiquidate\n\t\tExpression: healthFactor > CLOSE_FACTOR_HF_THRESHOLD\n\t\tIRs:\n\t\t\tTMP_745(bool) = healthFactor > CLOSE_FACTOR_HF_THRESHOLD\n\t\t\tCONDITION TMP_745\n\t\tExpression: closeFactor = DEFAULT_LIQUIDATION_CLOSE_FACTOR\n\t\tIRs:\n\t\t\tcloseFactor(uint256) := DEFAULT_LIQUIDATION_CLOSE_FACTOR(uint256)\n\t\tExpression: closeFactor = MAX_LIQUIDATION_CLOSE_FACTOR\n\t\tIRs:\n\t\t\tcloseFactor(uint256) := MAX_LIQUIDATION_CLOSE_FACTOR(uint256)\n\t\tExpression: params.debtToCover > maxLiquidatableDebt\n\t\tIRs:\n\t\t\tREF_779(uint256) -> params.debtToCover\n\t\t\tTMP_746(bool) = REF_779 > maxLiquidatableDebt\n\t\t\tCONDITION TMP_746\n\t\tExpression: actualDebtToLiquidate = maxLiquidatableDebt\n\t\tIRs:\n\t\t\tactualDebtToLiquidate(uint256) := maxLiquidatableDebt(uint256)\n\t\tExpression: actualDebtToLiquidate = params.debtToCover\n\t\tIRs:\n\t\t\tREF_780(uint256) -> params.debtToCover\n\t\t\tactualDebtToLiquidate(uint256) := REF_780(uint256)\n\tFunction LiquidationLogic._getConfigurationData(mapping(uint8 => DataTypes.EModeCategory),DataTypes.ReserveData,DataTypes.ExecuteLiquidationCallParams) (*)\n\t\tExpression: collateralAToken = IAToken(collateralReserve.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_781(address) -> collateralReserve.aTokenAddress\n\t\t\tTMP_747 = CONVERT REF_781 to IAToken\n\t\t\tcollateralAToken(IAToken) := TMP_747(IAToken)\n\t\tExpression: liquidationBonus = collateralReserve.configuration.getLiquidationBonus()\n\t\tIRs:\n\t\t\tREF_782(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_748(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLiquidationBonus(DataTypes.ReserveConfigurationMap), arguments:['REF_782'] \n\t\t\tliquidationBonus(uint256) := TMP_748(uint256)\n\t\tExpression: collateralPriceSource = params.collateralAsset\n\t\tIRs:\n\t\t\tREF_784(address) -> params.collateralAsset\n\t\t\tcollateralPriceSource(address) := REF_784(address)\n\t\tExpression: debtPriceSource = params.debtAsset\n\t\tIRs:\n\t\t\tREF_785(address) -> params.debtAsset\n\t\t\tdebtPriceSource(address) := REF_785(address)\n\t\tExpression: params.userEModeCategory != 0\n\t\tIRs:\n\t\t\tREF_786(uint8) -> params.userEModeCategory\n\t\t\tTMP_749(bool) = REF_786 != 0\n\t\t\tCONDITION TMP_749\n\t\tExpression: eModePriceSource = eModeCategories[params.userEModeCategory].priceSource\n\t\tIRs:\n\t\t\tREF_787(uint8) -> params.userEModeCategory\n\t\t\tREF_788(DataTypes.EModeCategory) -> eModeCategories[REF_787]\n\t\t\tREF_789(address) -> REF_788.priceSource\n\t\t\teModePriceSource(address) := REF_789(address)\n\t\tExpression: EModeLogic.isInEModeCategory(params.userEModeCategory,collateralReserve.configuration.getEModeCategory())\n\t\tIRs:\n\t\t\tREF_791(uint8) -> params.userEModeCategory\n\t\t\tREF_792(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_750(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getEModeCategory(DataTypes.ReserveConfigurationMap), arguments:['REF_792'] \n\t\t\tTMP_751(bool) = LIBRARY_CALL, dest:EModeLogic, function:EModeLogic.isInEModeCategory(uint256,uint256), arguments:['REF_791', 'TMP_750'] \n\t\t\tCONDITION TMP_751\n\t\tExpression: liquidationBonus = eModeCategories[params.userEModeCategory].liquidationBonus\n\t\tIRs:\n\t\t\tREF_794(uint8) -> params.userEModeCategory\n\t\t\tREF_795(DataTypes.EModeCategory) -> eModeCategories[REF_794]\n\t\t\tREF_796(uint16) -> REF_795.liquidationBonus\n\t\t\tliquidationBonus(uint256) := REF_796(uint16)\n\t\tExpression: eModePriceSource != address(0)\n\t\tIRs:\n\t\t\tTMP_752 = CONVERT 0 to address\n\t\t\tTMP_753(bool) = eModePriceSource != TMP_752\n\t\t\tCONDITION TMP_753\n\t\tExpression: collateralPriceSource = eModePriceSource\n\t\tIRs:\n\t\t\tcollateralPriceSource(address) := eModePriceSource(address)\n\t\tExpression: eModePriceSource != address(0)\n\t\tIRs:\n\t\t\tTMP_754 = CONVERT 0 to address\n\t\t\tTMP_755(bool) = eModePriceSource != TMP_754\n\t\t\tCONDITION TMP_755\n\t\tExpression: debtPriceSource = eModePriceSource\n\t\tIRs:\n\t\t\tdebtPriceSource(address) := eModePriceSource(address)\n\t\tExpression: (collateralAToken,collateralPriceSource,debtPriceSource,liquidationBonus)\n\t\tIRs:\n\t\t\tRETURN collateralAToken,collateralPriceSource,debtPriceSource,liquidationBonus\n\tFunction LiquidationLogic._calculateAvailableCollateralToLiquidate(DataTypes.ReserveData,DataTypes.ReserveCache,address,address,uint256,uint256,uint256,IPriceOracleGetter) (*)\n\t\tExpression: vars.collateralPrice = oracle.getAssetPrice(collateralAsset)\n\t\tIRs:\n\t\t\tREF_797(uint256) -> vars.collateralPrice\n\t\t\tTMP_756(uint256) = HIGH_LEVEL_CALL, dest:oracle(IPriceOracleGetter), function:getAssetPrice, arguments:['collateralAsset']  \n\t\t\tREF_797(uint256) (->vars) := TMP_756(uint256)\n\t\tExpression: vars.debtAssetPrice = oracle.getAssetPrice(debtAsset)\n\t\tIRs:\n\t\t\tREF_799(uint256) -> vars.debtAssetPrice\n\t\t\tTMP_757(uint256) = HIGH_LEVEL_CALL, dest:oracle(IPriceOracleGetter), function:getAssetPrice, arguments:['debtAsset']  \n\t\t\tREF_799(uint256) (->vars) := TMP_757(uint256)\n\t\tExpression: vars.collateralDecimals = collateralReserve.configuration.getDecimals()\n\t\tIRs:\n\t\t\tREF_801(uint256) -> vars.collateralDecimals\n\t\t\tREF_802(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_758(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_802'] \n\t\t\tREF_801(uint256) (->vars) := TMP_758(uint256)\n\t\tExpression: vars.debtAssetDecimals = debtReserveCache.reserveConfiguration.getDecimals()\n\t\tIRs:\n\t\t\tREF_804(uint256) -> vars.debtAssetDecimals\n\t\t\tREF_805(DataTypes.ReserveConfigurationMap) -> debtReserveCache.reserveConfiguration\n\t\t\tTMP_759(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_805'] \n\t\t\tREF_804(uint256) (->vars) := TMP_759(uint256)\n\t\tExpression: vars.collateralAssetUnit = 10 ** vars.collateralDecimals\n\t\tIRs:\n\t\t\tREF_807(uint256) -> vars.collateralAssetUnit\n\t\t\tREF_808(uint256) -> vars.collateralDecimals\n\t\t\tTMP_760(uint256) = 10 ** REF_808\n\t\t\tREF_807(uint256) (->vars) := TMP_760(uint256)\n\t\tExpression: vars.debtAssetUnit = 10 ** vars.debtAssetDecimals\n\t\tIRs:\n\t\t\tREF_809(uint256) -> vars.debtAssetUnit\n\t\t\tREF_810(uint256) -> vars.debtAssetDecimals\n\t\t\tTMP_761(uint256) = 10 ** REF_810\n\t\t\tREF_809(uint256) (->vars) := TMP_761(uint256)\n\t\tExpression: vars.liquidationProtocolFeePercentage = collateralReserve.configuration.getLiquidationProtocolFee()\n\t\tIRs:\n\t\t\tREF_811(uint256) -> vars.liquidationProtocolFeePercentage\n\t\t\tREF_812(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_762(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLiquidationProtocolFee(DataTypes.ReserveConfigurationMap), arguments:['REF_812'] \n\t\t\tREF_811(uint256) (->vars) := TMP_762(uint256)\n\t\tExpression: vars.baseCollateral = ((vars.debtAssetPrice * debtToCover * vars.collateralAssetUnit)) / (vars.collateralPrice * vars.debtAssetUnit)\n\t\tIRs:\n\t\t\tREF_814(uint256) -> vars.baseCollateral\n\t\t\tREF_815(uint256) -> vars.debtAssetPrice\n\t\t\tTMP_763(uint256) = REF_815 (c)* debtToCover\n\t\t\tREF_816(uint256) -> vars.collateralAssetUnit\n\t\t\tTMP_764(uint256) = TMP_763 (c)* REF_816\n\t\t\tREF_817(uint256) -> vars.collateralPrice\n\t\t\tREF_818(uint256) -> vars.debtAssetUnit\n\t\t\tTMP_765(uint256) = REF_817 (c)* REF_818\n\t\t\tTMP_766(uint256) = TMP_764 (c)/ TMP_765\n\t\t\tREF_814(uint256) (->vars) := TMP_766(uint256)\n\t\tExpression: vars.maxCollateralToLiquidate = vars.baseCollateral.percentMul(liquidationBonus)\n\t\tIRs:\n\t\t\tREF_819(uint256) -> vars.maxCollateralToLiquidate\n\t\t\tREF_820(uint256) -> vars.baseCollateral\n\t\t\tTMP_767(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_820', 'liquidationBonus'] \n\t\t\tREF_819(uint256) (->vars) := TMP_767(uint256)\n\t\tExpression: vars.maxCollateralToLiquidate > userCollateralBalance\n\t\tIRs:\n\t\t\tREF_822(uint256) -> vars.maxCollateralToLiquidate\n\t\t\tTMP_768(bool) = REF_822 > userCollateralBalance\n\t\t\tCONDITION TMP_768\n\t\tExpression: vars.collateralAmount = userCollateralBalance\n\t\tIRs:\n\t\t\tREF_823(uint256) -> vars.collateralAmount\n\t\t\tREF_823(uint256) (->vars) := userCollateralBalance(uint256)\n\t\tExpression: vars.debtAmountNeeded = ((vars.collateralPrice * vars.collateralAmount * vars.debtAssetUnit) / (vars.debtAssetPrice * vars.collateralAssetUnit)).percentDiv(liquidationBonus)\n\t\tIRs:\n\t\t\tREF_824(uint256) -> vars.debtAmountNeeded\n\t\t\tREF_825(uint256) -> vars.collateralPrice\n\t\t\tREF_826(uint256) -> vars.collateralAmount\n\t\t\tTMP_769(uint256) = REF_825 (c)* REF_826\n\t\t\tREF_827(uint256) -> vars.debtAssetUnit\n\t\t\tTMP_770(uint256) = TMP_769 (c)* REF_827\n\t\t\tREF_828(uint256) -> vars.debtAssetPrice\n\t\t\tREF_829(uint256) -> vars.collateralAssetUnit\n\t\t\tTMP_771(uint256) = REF_828 (c)* REF_829\n\t\t\tTMP_772(uint256) = TMP_770 (c)/ TMP_771\n\t\t\tTMP_773(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentDiv(uint256,uint256), arguments:['TMP_772', 'liquidationBonus'] \n\t\t\tREF_824(uint256) (->vars) := TMP_773(uint256)\n\t\tExpression: vars.collateralAmount = vars.maxCollateralToLiquidate\n\t\tIRs:\n\t\t\tREF_831(uint256) -> vars.collateralAmount\n\t\t\tREF_832(uint256) -> vars.maxCollateralToLiquidate\n\t\t\tREF_831(uint256) (->vars) := REF_832(uint256)\n\t\tExpression: vars.debtAmountNeeded = debtToCover\n\t\tIRs:\n\t\t\tREF_833(uint256) -> vars.debtAmountNeeded\n\t\t\tREF_833(uint256) (->vars) := debtToCover(uint256)\n\t\tExpression: vars.liquidationProtocolFeePercentage != 0\n\t\tIRs:\n\t\t\tREF_834(uint256) -> vars.liquidationProtocolFeePercentage\n\t\t\tTMP_774(bool) = REF_834 != 0\n\t\t\tCONDITION TMP_774\n\t\tExpression: vars.bonusCollateral = vars.collateralAmount - vars.collateralAmount.percentDiv(liquidationBonus)\n\t\tIRs:\n\t\t\tREF_835(uint256) -> vars.bonusCollateral\n\t\t\tREF_836(uint256) -> vars.collateralAmount\n\t\t\tREF_837(uint256) -> vars.collateralAmount\n\t\t\tTMP_775(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentDiv(uint256,uint256), arguments:['REF_837', 'liquidationBonus'] \n\t\t\tTMP_776(uint256) = REF_836 (c)- TMP_775\n\t\t\tREF_835(uint256) (->vars) := TMP_776(uint256)\n\t\tExpression: vars.liquidationProtocolFee = vars.bonusCollateral.percentMul(vars.liquidationProtocolFeePercentage)\n\t\tIRs:\n\t\t\tREF_839(uint256) -> vars.liquidationProtocolFee\n\t\t\tREF_840(uint256) -> vars.bonusCollateral\n\t\t\tREF_842(uint256) -> vars.liquidationProtocolFeePercentage\n\t\t\tTMP_777(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_840', 'REF_842'] \n\t\t\tREF_839(uint256) (->vars) := TMP_777(uint256)\n\t\tExpression: (vars.collateralAmount - vars.liquidationProtocolFee,vars.debtAmountNeeded,vars.liquidationProtocolFee)\n\t\tIRs:\n\t\t\tREF_843(uint256) -> vars.collateralAmount\n\t\t\tREF_844(uint256) -> vars.liquidationProtocolFee\n\t\t\tTMP_778(uint256) = REF_843 (c)- REF_844\n\t\t\tREF_845(uint256) -> vars.debtAmountNeeded\n\t\t\tREF_846(uint256) -> vars.liquidationProtocolFee\n\t\t\tRETURN TMP_778,REF_845,REF_846\n\t\tExpression: (vars.collateralAmount,vars.debtAmountNeeded,0)\n\t\tIRs:\n\t\t\tREF_847(uint256) -> vars.collateralAmount\n\t\t\tREF_848(uint256) -> vars.debtAmountNeeded\n\t\t\tRETURN REF_847,REF_848,0\n\tFunction LiquidationLogic.slitherConstructorConstantVariables() (*)\n\t\tExpression: DEFAULT_LIQUIDATION_CLOSE_FACTOR = 0.5e4\n\t\tIRs:\n\t\t\tDEFAULT_LIQUIDATION_CLOSE_FACTOR(uint256) := 5000(uint256)\n\t\tExpression: MAX_LIQUIDATION_CLOSE_FACTOR = 1e4\n\t\tIRs:\n\t\t\tMAX_LIQUIDATION_CLOSE_FACTOR(uint256) := 10000(uint256)\n\t\tExpression: CLOSE_FACTOR_HF_THRESHOLD = 0.95e18\n\t\tIRs:\n\t\t\tCLOSE_FACTOR_HF_THRESHOLD(uint256) := 950000000000000000(uint256)\nContract PoolLogic\n\tFunction PoolLogic.executeInitReserve(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.InitReserveParams) (*)\n\t\tExpression: require(bool,string)(Address.isContract(params.asset),Errors.NOT_CONTRACT)\n\t\tIRs:\n\t\t\tREF_850(address) -> params.asset\n\t\t\tTMP_779(bool) = LIBRARY_CALL, dest:Address, function:Address.isContract(address), arguments:['REF_850'] \n\t\t\tREF_851(string) -> Errors.NOT_CONTRACT\n\t\t\tTMP_780(None) = SOLIDITY_CALL require(bool,string)(TMP_779,REF_851)\n\t\tExpression: reservesData[params.asset].init(params.aTokenAddress,params.stableDebtAddress,params.variableDebtAddress,params.interestRateStrategyAddress)\n\t\tIRs:\n\t\t\tREF_852(address) -> params.asset\n\t\t\tREF_853(DataTypes.ReserveData) -> reservesData[REF_852]\n\t\t\tREF_855(address) -> params.aTokenAddress\n\t\t\tREF_856(address) -> params.stableDebtAddress\n\t\t\tREF_857(address) -> params.variableDebtAddress\n\t\t\tREF_858(address) -> params.interestRateStrategyAddress\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.init(DataTypes.ReserveData,address,address,address,address), arguments:['REF_853', 'REF_855', 'REF_856', 'REF_857', 'REF_858'] \n\t\tExpression: reserveAlreadyAdded = reservesData[params.asset].id != 0 || reservesList[0] == params.asset\n\t\tIRs:\n\t\t\tREF_859(address) -> params.asset\n\t\t\tREF_860(DataTypes.ReserveData) -> reservesData[REF_859]\n\t\t\tREF_861(uint16) -> REF_860.id\n\t\t\tTMP_782(bool) = REF_861 != 0\n\t\t\tREF_862(address) -> reservesList[0]\n\t\t\tREF_863(address) -> params.asset\n\t\t\tTMP_783(bool) = REF_862 == REF_863\n\t\t\tTMP_784(bool) = TMP_782 || TMP_783\n\t\t\treserveAlreadyAdded(bool) := TMP_784(bool)\n\t\tExpression: require(bool,string)(! reserveAlreadyAdded,Errors.RESERVE_ALREADY_ADDED)\n\t\tIRs:\n\t\t\tTMP_785 = UnaryType.BANG reserveAlreadyAdded \n\t\t\tREF_864(string) -> Errors.RESERVE_ALREADY_ADDED\n\t\t\tTMP_786(None) = SOLIDITY_CALL require(bool,string)(TMP_785,REF_864)\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint16) := 0(uint256)\n\t\tExpression: i < params.reservesCount\n\t\tIRs:\n\t\t\tREF_865(uint16) -> params.reservesCount\n\t\t\tTMP_787(bool) = i < REF_865\n\t\t\tCONDITION TMP_787\n\t\tExpression: reservesList[i] == address(0)\n\t\tIRs:\n\t\t\tREF_866(address) -> reservesList[i]\n\t\t\tTMP_788 = CONVERT 0 to address\n\t\t\tTMP_789(bool) = REF_866 == TMP_788\n\t\t\tCONDITION TMP_789\n\t\tExpression: reservesData[params.asset].id = i\n\t\tIRs:\n\t\t\tREF_867(address) -> params.asset\n\t\t\tREF_868(DataTypes.ReserveData) -> reservesData[REF_867]\n\t\t\tREF_869(uint16) -> REF_868.id\n\t\t\tREF_869(uint16) (->reservesData) := i(uint16)\n\t\tExpression: reservesList[i] = params.asset\n\t\tIRs:\n\t\t\tREF_870(address) -> reservesList[i]\n\t\t\tREF_871(address) -> params.asset\n\t\t\tREF_870(address) (->reservesList) := REF_871(address)\n\t\tExpression: false\n\t\tIRs:\n\t\t\tRETURN False\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_790(uint16) := i(uint16)\n\t\t\ti(uint16) = i (c)+ 1\n\t\tExpression: require(bool,string)(params.reservesCount < params.maxNumberReserves,Errors.NO_MORE_RESERVES_ALLOWED)\n\t\tIRs:\n\t\t\tREF_872(uint16) -> params.reservesCount\n\t\t\tREF_873(uint16) -> params.maxNumberReserves\n\t\t\tTMP_791(bool) = REF_872 < REF_873\n\t\t\tREF_874(string) -> Errors.NO_MORE_RESERVES_ALLOWED\n\t\t\tTMP_792(None) = SOLIDITY_CALL require(bool,string)(TMP_791,REF_874)\n\t\tExpression: reservesData[params.asset].id = params.reservesCount\n\t\tIRs:\n\t\t\tREF_875(address) -> params.asset\n\t\t\tREF_876(DataTypes.ReserveData) -> reservesData[REF_875]\n\t\t\tREF_877(uint16) -> REF_876.id\n\t\t\tREF_878(uint16) -> params.reservesCount\n\t\t\tREF_877(uint16) (->reservesData) := REF_878(uint16)\n\t\tExpression: reservesList[params.reservesCount] = params.asset\n\t\tIRs:\n\t\t\tREF_879(uint16) -> params.reservesCount\n\t\t\tREF_880(address) -> reservesList[REF_879]\n\t\t\tREF_881(address) -> params.asset\n\t\t\tREF_880(address) (->reservesList) := REF_881(address)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction PoolLogic.executeRescueTokens(address,address,uint256) (*)\n\t\tExpression: IERC20(token).safeTransfer(to,amount)\n\t\tIRs:\n\t\t\tTMP_793 = CONVERT token to IERC20\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransfer(IERC20,address,uint256), arguments:['TMP_793', 'to', 'amount'] \n\tFunction PoolLogic.executeMintToTreasury(mapping(address => DataTypes.ReserveData),address[]) (*)\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint256) := 0(uint256)\n\t\tExpression: i < assets.length\n\t\tIRs:\n\t\t\tREF_883 -> LENGTH assets\n\t\t\tTMP_795(bool) = i < REF_883\n\t\t\tCONDITION TMP_795\n\t\tExpression: assetAddress = assets[i]\n\t\tIRs:\n\t\t\tREF_884(address) -> assets[i]\n\t\t\tassetAddress(address) := REF_884(address)\n\t\tExpression: reserve = reservesData[assetAddress]\n\t\tIRs:\n\t\t\tREF_885(DataTypes.ReserveData) -> reservesData[assetAddress]\n\t\t\treserve(DataTypes.ReserveData) := REF_885(DataTypes.ReserveData)\n\t\tExpression: ! reserve.configuration.getActive()\n\t\tIRs:\n\t\t\tREF_886(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tTMP_796(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getActive(DataTypes.ReserveConfigurationMap), arguments:['REF_886'] \n\t\t\tTMP_797 = UnaryType.BANG TMP_796 \n\t\t\tCONDITION TMP_797\n\t\tExpression: accruedToTreasury = reserve.accruedToTreasury\n\t\tIRs:\n\t\t\tREF_888(uint128) -> reserve.accruedToTreasury\n\t\t\taccruedToTreasury(uint256) := REF_888(uint128)\n\t\tExpression: accruedToTreasury != 0\n\t\tIRs:\n\t\t\tTMP_798(bool) = accruedToTreasury != 0\n\t\t\tCONDITION TMP_798\n\t\tExpression: reserve.accruedToTreasury = 0\n\t\tIRs:\n\t\t\tREF_889(uint128) -> reserve.accruedToTreasury\n\t\t\tREF_889(uint128) (->reserve) := 0(uint256)\n\t\tExpression: normalizedIncome = reserve.getNormalizedIncome()\n\t\tIRs:\n\t\t\tTMP_799(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedIncome(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\tnormalizedIncome(uint256) := TMP_799(uint256)\n\t\tExpression: amountToMint = accruedToTreasury.rayMul(normalizedIncome)\n\t\tIRs:\n\t\t\tTMP_800(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['accruedToTreasury', 'normalizedIncome'] \n\t\t\tamountToMint(uint256) := TMP_800(uint256)\n\t\tExpression: IAToken(reserve.aTokenAddress).mintToTreasury(amountToMint,normalizedIncome)\n\t\tIRs:\n\t\t\tREF_892(address) -> reserve.aTokenAddress\n\t\t\tTMP_801 = CONVERT REF_892 to IAToken\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_801(IAToken), function:mintToTreasury, arguments:['amountToMint', 'normalizedIncome']  \n\t\tExpression: MintedToTreasury(assetAddress,amountToMint)\n\t\tIRs:\n\t\t\tEmit MintedToTreasury(assetAddress,amountToMint)\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_804(uint256) := i(uint256)\n\t\t\ti(uint256) = i (c)+ 1\n\tFunction PoolLogic.executeResetIsolationModeTotalDebt(mapping(address => DataTypes.ReserveData),address) (*)\n\t\tExpression: require(bool,string)(reservesData[asset].configuration.getDebtCeiling() == 0,Errors.DEBT_CEILING_NOT_ZERO)\n\t\tIRs:\n\t\t\tREF_894(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\tREF_895(DataTypes.ReserveConfigurationMap) -> REF_894.configuration\n\t\t\tTMP_805(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap), arguments:['REF_895'] \n\t\t\tTMP_806(bool) = TMP_805 == 0\n\t\t\tREF_897(string) -> Errors.DEBT_CEILING_NOT_ZERO\n\t\t\tTMP_807(None) = SOLIDITY_CALL require(bool,string)(TMP_806,REF_897)\n\t\tExpression: reservesData[asset].isolationModeTotalDebt = 0\n\t\tIRs:\n\t\t\tREF_898(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\tREF_899(uint128) -> REF_898.isolationModeTotalDebt\n\t\t\tREF_899(uint128) (->reservesData) := 0(uint256)\n\t\tExpression: IsolationModeTotalDebtUpdated(asset,0)\n\t\tIRs:\n\t\t\tEmit IsolationModeTotalDebtUpdated(asset,0)\n\tFunction PoolLogic.executeDropReserve(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),address) (*)\n\t\tExpression: reserve = reservesData[asset]\n\t\tIRs:\n\t\t\tREF_900(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treserve(DataTypes.ReserveData) := REF_900(DataTypes.ReserveData)\n\t\tExpression: ValidationLogic.validateDropReserve(reservesList,reserve,asset)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateDropReserve(mapping(uint256 => address),DataTypes.ReserveData,address), arguments:['reservesList', 'reserve', 'asset'] \n\t\tExpression: reservesList[reservesData[asset].id] = address(0)\n\t\tIRs:\n\t\t\tREF_902(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\tREF_903(uint16) -> REF_902.id\n\t\t\tREF_904(address) -> reservesList[REF_903]\n\t\t\tTMP_810 = CONVERT 0 to address\n\t\t\tREF_904(address) (->reservesList) := TMP_810(address)\n\t\tExpression: delete reservesData[asset]\n\t\tIRs:\n\t\t\tREF_905(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treservesData = delete REF_905 \n\tFunction PoolLogic.executeGetUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams) (*)\n\t\tExpression: (totalCollateralBase,totalDebtBase,ltv,currentLiquidationThreshold,healthFactor,None) = GenericLogic.calculateUserAccountData(reservesData,reservesList,eModeCategories,params)\n\t\tIRs:\n\t\t\tTUPLE_25(uint256,uint256,uint256,uint256,uint256,bool) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'params'] \n\t\t\ttotalCollateralBase(uint256)= UNPACK TUPLE_25 index: 0 \n\t\t\ttotalDebtBase(uint256)= UNPACK TUPLE_25 index: 1 \n\t\t\tltv(uint256)= UNPACK TUPLE_25 index: 2 \n\t\t\tcurrentLiquidationThreshold(uint256)= UNPACK TUPLE_25 index: 3 \n\t\t\thealthFactor(uint256)= UNPACK TUPLE_25 index: 4 \n\t\tExpression: availableBorrowsBase = GenericLogic.calculateAvailableBorrows(totalCollateralBase,totalDebtBase,ltv)\n\t\tIRs:\n\t\t\tTMP_811(uint256) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateAvailableBorrows(uint256,uint256,uint256), arguments:['totalCollateralBase', 'totalDebtBase', 'ltv'] \n\t\t\tavailableBorrowsBase(uint256) := TMP_811(uint256)\n\t\tExpression: (totalCollateralBase,totalDebtBase,availableBorrowsBase,currentLiquidationThreshold,ltv,healthFactor)\n\t\tIRs:\n\t\t\tRETURN totalCollateralBase,totalDebtBase,availableBorrowsBase,currentLiquidationThreshold,ltv,healthFactor\nContract ReserveLogic\n\tFunction ReserveLogic.getNormalizedIncome(DataTypes.ReserveData) (*)\n\t\tExpression: timestamp = reserve.lastUpdateTimestamp\n\t\tIRs:\n\t\t\tREF_908(uint40) -> reserve.lastUpdateTimestamp\n\t\t\ttimestamp(uint40) := REF_908(uint40)\n\t\tExpression: timestamp == block.timestamp\n\t\tIRs:\n\t\t\tTMP_812(bool) = timestamp == block.timestamp\n\t\t\tCONDITION TMP_812\n\t\tExpression: reserve.liquidityIndex\n\t\tIRs:\n\t\t\tREF_909(uint128) -> reserve.liquidityIndex\n\t\t\tRETURN REF_909\n\t\tExpression: MathUtils.calculateLinearInterest(reserve.currentLiquidityRate,timestamp).rayMul(reserve.liquidityIndex)\n\t\tIRs:\n\t\t\tREF_911(uint128) -> reserve.currentLiquidityRate\n\t\t\tTMP_813(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateLinearInterest(uint256,uint40), arguments:['REF_911', 'timestamp'] \n\t\t\tREF_913(uint128) -> reserve.liquidityIndex\n\t\t\tTMP_814(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_813', 'REF_913'] \n\t\t\tRETURN TMP_814\n\tFunction ReserveLogic.getNormalizedDebt(DataTypes.ReserveData) (*)\n\t\tExpression: timestamp = reserve.lastUpdateTimestamp\n\t\tIRs:\n\t\t\tREF_914(uint40) -> reserve.lastUpdateTimestamp\n\t\t\ttimestamp(uint40) := REF_914(uint40)\n\t\tExpression: timestamp == block.timestamp\n\t\tIRs:\n\t\t\tTMP_815(bool) = timestamp == block.timestamp\n\t\t\tCONDITION TMP_815\n\t\tExpression: reserve.variableBorrowIndex\n\t\tIRs:\n\t\t\tREF_915(uint128) -> reserve.variableBorrowIndex\n\t\t\tRETURN REF_915\n\t\tExpression: MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate,timestamp).rayMul(reserve.variableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_917(uint128) -> reserve.currentVariableBorrowRate\n\t\t\tTMP_816(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateCompoundedInterest(uint256,uint40), arguments:['REF_917', 'timestamp'] \n\t\t\tREF_919(uint128) -> reserve.variableBorrowIndex\n\t\t\tTMP_817(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_816', 'REF_919'] \n\t\t\tRETURN TMP_817\n\tFunction ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache) (*)\n\t\tExpression: reserve.lastUpdateTimestamp == uint40(block.timestamp)\n\t\tIRs:\n\t\t\tREF_920(uint40) -> reserve.lastUpdateTimestamp\n\t\t\tTMP_818 = CONVERT block.timestamp to uint40\n\t\t\tTMP_819(bool) = REF_920 == TMP_818\n\t\t\tCONDITION TMP_819\n\t\tExpression: _updateIndexes(reserve,reserveCache)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, ReserveLogic._updateIndexes(DataTypes.ReserveData,DataTypes.ReserveCache)(reserve,reserveCache)\n\t\tExpression: _accrueToTreasury(reserve,reserveCache)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, ReserveLogic._accrueToTreasury(DataTypes.ReserveData,DataTypes.ReserveCache)(reserve,reserveCache)\n\t\tExpression: reserve.lastUpdateTimestamp = uint40(block.timestamp)\n\t\tIRs:\n\t\t\tREF_921(uint40) -> reserve.lastUpdateTimestamp\n\t\t\tTMP_822 = CONVERT block.timestamp to uint40\n\t\t\tREF_921(uint40) (->reserve) := TMP_822(uint40)\n\tFunction ReserveLogic.cumulateToLiquidityIndex(DataTypes.ReserveData,uint256,uint256) (*)\n\t\tExpression: result = (amount.wadToRay().rayDiv(totalLiquidity.wadToRay()) + WadRayMath.RAY).rayMul(reserve.liquidityIndex)\n\t\tIRs:\n\t\t\tTMP_823(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.wadToRay(uint256), arguments:['amount'] \n\t\t\tTMP_824(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.wadToRay(uint256), arguments:['totalLiquidity'] \n\t\t\tTMP_825(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['TMP_823', 'TMP_824'] \n\t\t\tREF_925(uint256) -> WadRayMath.RAY\n\t\t\tTMP_826(uint256) = TMP_825 (c)+ REF_925\n\t\t\tREF_927(uint128) -> reserve.liquidityIndex\n\t\t\tTMP_827(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_826', 'REF_927'] \n\t\t\tresult(uint256) := TMP_827(uint256)\n\t\tExpression: reserve.liquidityIndex = result.toUint128()\n\t\tIRs:\n\t\t\tREF_928(uint128) -> reserve.liquidityIndex\n\t\t\tTMP_828(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['result'] \n\t\t\tREF_928(uint128) (->reserve) := TMP_828(uint128)\n\t\tExpression: result\n\t\tIRs:\n\t\t\tRETURN result\n\tFunction ReserveLogic.init(DataTypes.ReserveData,address,address,address,address) (*)\n\t\tExpression: require(bool,string)(reserve.aTokenAddress == address(0),Errors.RESERVE_ALREADY_INITIALIZED)\n\t\tIRs:\n\t\t\tREF_930(address) -> reserve.aTokenAddress\n\t\t\tTMP_829 = CONVERT 0 to address\n\t\t\tTMP_830(bool) = REF_930 == TMP_829\n\t\t\tREF_931(string) -> Errors.RESERVE_ALREADY_INITIALIZED\n\t\t\tTMP_831(None) = SOLIDITY_CALL require(bool,string)(TMP_830,REF_931)\n\t\tExpression: reserve.liquidityIndex = uint128(WadRayMath.RAY)\n\t\tIRs:\n\t\t\tREF_932(uint128) -> reserve.liquidityIndex\n\t\t\tREF_933(uint256) -> WadRayMath.RAY\n\t\t\tTMP_832 = CONVERT REF_933 to uint128\n\t\t\tREF_932(uint128) (->reserve) := TMP_832(uint128)\n\t\tExpression: reserve.variableBorrowIndex = uint128(WadRayMath.RAY)\n\t\tIRs:\n\t\t\tREF_934(uint128) -> reserve.variableBorrowIndex\n\t\t\tREF_935(uint256) -> WadRayMath.RAY\n\t\t\tTMP_833 = CONVERT REF_935 to uint128\n\t\t\tREF_934(uint128) (->reserve) := TMP_833(uint128)\n\t\tExpression: reserve.aTokenAddress = aTokenAddress\n\t\tIRs:\n\t\t\tREF_936(address) -> reserve.aTokenAddress\n\t\t\tREF_936(address) (->reserve) := aTokenAddress(address)\n\t\tExpression: reserve.stableDebtTokenAddress = stableDebtTokenAddress\n\t\tIRs:\n\t\t\tREF_937(address) -> reserve.stableDebtTokenAddress\n\t\t\tREF_937(address) (->reserve) := stableDebtTokenAddress(address)\n\t\tExpression: reserve.variableDebtTokenAddress = variableDebtTokenAddress\n\t\tIRs:\n\t\t\tREF_938(address) -> reserve.variableDebtTokenAddress\n\t\t\tREF_938(address) (->reserve) := variableDebtTokenAddress(address)\n\t\tExpression: reserve.interestRateStrategyAddress = interestRateStrategyAddress\n\t\tIRs:\n\t\t\tREF_939(address) -> reserve.interestRateStrategyAddress\n\t\t\tREF_939(address) (->reserve) := interestRateStrategyAddress(address)\n\tFunction ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256) (*)\n\t\tExpression: vars.totalVariableDebt = reserveCache.nextScaledVariableDebt.rayMul(reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_940(uint256) -> vars.totalVariableDebt\n\t\t\tREF_941(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_943(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_834(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_941', 'REF_943'] \n\t\t\tREF_940(uint256) (->vars) := TMP_834(uint256)\n\t\tExpression: (vars.nextLiquidityRate,vars.nextStableRate,vars.nextVariableRate) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(DataTypes.CalculateInterestRatesParams({unbacked:reserve.unbacked,liquidityAdded:liquidityAdded,liquidityTaken:liquidityTaken,totalStableDebt:reserveCache.nextTotalStableDebt,totalVariableDebt:vars.totalVariableDebt,averageStableBorrowRate:reserveCache.nextAvgStableBorrowRate,reserveFactor:reserveCache.reserveFactor,reserve:reserveAddress,aToken:reserveCache.aTokenAddress}))\n\t\tIRs:\n\t\t\tREF_944(uint256) -> vars.nextLiquidityRate\n\t\t\tREF_945(uint256) -> vars.nextStableRate\n\t\t\tREF_946(uint256) -> vars.nextVariableRate\n\t\t\tREF_947(address) -> reserve.interestRateStrategyAddress\n\t\t\tTMP_835 = CONVERT REF_947 to IReserveInterestRateStrategy\n\t\t\tREF_950(uint128) -> reserve.unbacked\n\t\t\tREF_951(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_952(uint256) -> vars.totalVariableDebt\n\t\t\tREF_953(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_954(uint256) -> reserveCache.reserveFactor\n\t\t\tREF_955(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_836(DataTypes.CalculateInterestRatesParams) = new CalculateInterestRatesParams(REF_950,liquidityAdded,liquidityTaken,REF_951,REF_952,REF_953,REF_954,reserveAddress,REF_955)\n\t\t\tTUPLE_26(uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_835(IReserveInterestRateStrategy), function:calculateInterestRates, arguments:['TMP_836']  \n\t\t\tREF_944(uint256)= UNPACK TUPLE_26 index: 0 \n\t\t\tREF_945(uint256)= UNPACK TUPLE_26 index: 1 \n\t\t\tREF_946(uint256)= UNPACK TUPLE_26 index: 2 \n\t\tExpression: reserve.currentLiquidityRate = vars.nextLiquidityRate.toUint128()\n\t\tIRs:\n\t\t\tREF_956(uint128) -> reserve.currentLiquidityRate\n\t\t\tREF_957(uint256) -> vars.nextLiquidityRate\n\t\t\tTMP_837(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_957'] \n\t\t\tREF_956(uint128) (->reserve) := TMP_837(uint128)\n\t\tExpression: reserve.currentStableBorrowRate = vars.nextStableRate.toUint128()\n\t\tIRs:\n\t\t\tREF_959(uint128) -> reserve.currentStableBorrowRate\n\t\t\tREF_960(uint256) -> vars.nextStableRate\n\t\t\tTMP_838(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_960'] \n\t\t\tREF_959(uint128) (->reserve) := TMP_838(uint128)\n\t\tExpression: reserve.currentVariableBorrowRate = vars.nextVariableRate.toUint128()\n\t\tIRs:\n\t\t\tREF_962(uint128) -> reserve.currentVariableBorrowRate\n\t\t\tREF_963(uint256) -> vars.nextVariableRate\n\t\t\tTMP_839(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_963'] \n\t\t\tREF_962(uint128) (->reserve) := TMP_839(uint128)\n\t\tExpression: ReserveDataUpdated(reserveAddress,vars.nextLiquidityRate,vars.nextStableRate,vars.nextVariableRate,reserveCache.nextLiquidityIndex,reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_965(uint256) -> vars.nextLiquidityRate\n\t\t\tREF_966(uint256) -> vars.nextStableRate\n\t\t\tREF_967(uint256) -> vars.nextVariableRate\n\t\t\tREF_968(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_969(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tEmit ReserveDataUpdated(reserveAddress,REF_965,REF_966,REF_967,REF_968,REF_969)\n\tFunction ReserveLogic._accrueToTreasury(DataTypes.ReserveData,DataTypes.ReserveCache) (*)\n\t\tExpression: reserveCache.reserveFactor == 0\n\t\tIRs:\n\t\t\tREF_970(uint256) -> reserveCache.reserveFactor\n\t\t\tTMP_841(bool) = REF_970 == 0\n\t\t\tCONDITION TMP_841\n\t\tExpression: vars.prevTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(reserveCache.currVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_971(uint256) -> vars.prevTotalVariableDebt\n\t\t\tREF_972(uint256) -> reserveCache.currScaledVariableDebt\n\t\t\tREF_974(uint256) -> reserveCache.currVariableBorrowIndex\n\t\t\tTMP_842(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_972', 'REF_974'] \n\t\t\tREF_971(uint256) (->vars) := TMP_842(uint256)\n\t\tExpression: vars.currTotalVariableDebt = reserveCache.currScaledVariableDebt.rayMul(reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_975(uint256) -> vars.currTotalVariableDebt\n\t\t\tREF_976(uint256) -> reserveCache.currScaledVariableDebt\n\t\t\tREF_978(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_843(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_976', 'REF_978'] \n\t\t\tREF_975(uint256) (->vars) := TMP_843(uint256)\n\t\tExpression: vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(reserveCache.currAvgStableBorrowRate,reserveCache.stableDebtLastUpdateTimestamp,reserveCache.reserveLastUpdateTimestamp)\n\t\tIRs:\n\t\t\tREF_979(uint256) -> vars.cumulatedStableInterest\n\t\t\tREF_981(uint256) -> reserveCache.currAvgStableBorrowRate\n\t\t\tREF_982(uint40) -> reserveCache.stableDebtLastUpdateTimestamp\n\t\t\tREF_983(uint40) -> reserveCache.reserveLastUpdateTimestamp\n\t\t\tTMP_844(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateCompoundedInterest(uint256,uint40,uint256), arguments:['REF_981', 'REF_982', 'REF_983'] \n\t\t\tREF_979(uint256) (->vars) := TMP_844(uint256)\n\t\tExpression: vars.prevTotalStableDebt = reserveCache.currPrincipalStableDebt.rayMul(vars.cumulatedStableInterest)\n\t\tIRs:\n\t\t\tREF_984(uint256) -> vars.prevTotalStableDebt\n\t\t\tREF_985(uint256) -> reserveCache.currPrincipalStableDebt\n\t\t\tREF_987(uint256) -> vars.cumulatedStableInterest\n\t\t\tTMP_845(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_985', 'REF_987'] \n\t\t\tREF_984(uint256) (->vars) := TMP_845(uint256)\n\t\tExpression: vars.totalDebtAccrued = vars.currTotalVariableDebt + reserveCache.currTotalStableDebt - vars.prevTotalVariableDebt - vars.prevTotalStableDebt\n\t\tIRs:\n\t\t\tREF_988(uint256) -> vars.totalDebtAccrued\n\t\t\tREF_989(uint256) -> vars.currTotalVariableDebt\n\t\t\tREF_990(uint256) -> reserveCache.currTotalStableDebt\n\t\t\tTMP_846(uint256) = REF_989 (c)+ REF_990\n\t\t\tREF_991(uint256) -> vars.prevTotalVariableDebt\n\t\t\tTMP_847(uint256) = TMP_846 (c)- REF_991\n\t\t\tREF_992(uint256) -> vars.prevTotalStableDebt\n\t\t\tTMP_848(uint256) = TMP_847 (c)- REF_992\n\t\t\tREF_988(uint256) (->vars) := TMP_848(uint256)\n\t\tExpression: vars.amountToMint = vars.totalDebtAccrued.percentMul(reserveCache.reserveFactor)\n\t\tIRs:\n\t\t\tREF_993(uint256) -> vars.amountToMint\n\t\t\tREF_994(uint256) -> vars.totalDebtAccrued\n\t\t\tREF_996(uint256) -> reserveCache.reserveFactor\n\t\t\tTMP_849(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_994', 'REF_996'] \n\t\t\tREF_993(uint256) (->vars) := TMP_849(uint256)\n\t\tExpression: vars.amountToMint != 0\n\t\tIRs:\n\t\t\tREF_997(uint256) -> vars.amountToMint\n\t\t\tTMP_850(bool) = REF_997 != 0\n\t\t\tCONDITION TMP_850\n\t\tExpression: reserve.accruedToTreasury += vars.amountToMint.rayDiv(reserveCache.nextLiquidityIndex).toUint128()\n\t\tIRs:\n\t\t\tREF_998(uint128) -> reserve.accruedToTreasury\n\t\t\tREF_999(uint256) -> vars.amountToMint\n\t\t\tREF_1001(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_851(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayDiv(uint256,uint256), arguments:['REF_999', 'REF_1001'] \n\t\t\tTMP_852(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_851'] \n\t\t\tREF_998(-> reserve) = REF_998 (c)+ TMP_852\n\tFunction ReserveLogic._updateIndexes(DataTypes.ReserveData,DataTypes.ReserveCache) (*)\n\t\tExpression: reserveCache.currLiquidityRate != 0\n\t\tIRs:\n\t\t\tREF_1003(uint256) -> reserveCache.currLiquidityRate\n\t\t\tTMP_853(bool) = REF_1003 != 0\n\t\t\tCONDITION TMP_853\n\t\tExpression: cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(reserveCache.currLiquidityRate,reserveCache.reserveLastUpdateTimestamp)\n\t\tIRs:\n\t\t\tREF_1005(uint256) -> reserveCache.currLiquidityRate\n\t\t\tREF_1006(uint40) -> reserveCache.reserveLastUpdateTimestamp\n\t\t\tTMP_854(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateLinearInterest(uint256,uint40), arguments:['REF_1005', 'REF_1006'] \n\t\t\tcumulatedLiquidityInterest(uint256) := TMP_854(uint256)\n\t\tExpression: reserveCache.nextLiquidityIndex = cumulatedLiquidityInterest.rayMul(reserveCache.currLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_1007(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_1009(uint256) -> reserveCache.currLiquidityIndex\n\t\t\tTMP_855(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['cumulatedLiquidityInterest', 'REF_1009'] \n\t\t\tREF_1007(uint256) (->reserveCache) := TMP_855(uint256)\n\t\tExpression: reserve.liquidityIndex = reserveCache.nextLiquidityIndex.toUint128()\n\t\tIRs:\n\t\t\tREF_1010(uint128) -> reserve.liquidityIndex\n\t\t\tREF_1011(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_856(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_1011'] \n\t\t\tREF_1010(uint128) (->reserve) := TMP_856(uint128)\n\t\tExpression: reserveCache.currScaledVariableDebt != 0\n\t\tIRs:\n\t\t\tREF_1013(uint256) -> reserveCache.currScaledVariableDebt\n\t\t\tTMP_857(bool) = REF_1013 != 0\n\t\t\tCONDITION TMP_857\n\t\tExpression: cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(reserveCache.currVariableBorrowRate,reserveCache.reserveLastUpdateTimestamp)\n\t\tIRs:\n\t\t\tREF_1015(uint256) -> reserveCache.currVariableBorrowRate\n\t\t\tREF_1016(uint40) -> reserveCache.reserveLastUpdateTimestamp\n\t\t\tTMP_858(uint256) = LIBRARY_CALL, dest:MathUtils, function:MathUtils.calculateCompoundedInterest(uint256,uint40), arguments:['REF_1015', 'REF_1016'] \n\t\t\tcumulatedVariableBorrowInterest(uint256) := TMP_858(uint256)\n\t\tExpression: reserveCache.nextVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(reserveCache.currVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_1017(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tREF_1019(uint256) -> reserveCache.currVariableBorrowIndex\n\t\t\tTMP_859(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['cumulatedVariableBorrowInterest', 'REF_1019'] \n\t\t\tREF_1017(uint256) (->reserveCache) := TMP_859(uint256)\n\t\tExpression: reserve.variableBorrowIndex = reserveCache.nextVariableBorrowIndex.toUint128()\n\t\tIRs:\n\t\t\tREF_1020(uint128) -> reserve.variableBorrowIndex\n\t\t\tREF_1021(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tTMP_860(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['REF_1021'] \n\t\t\tREF_1020(uint128) (->reserve) := TMP_860(uint128)\n\tFunction ReserveLogic.cache(DataTypes.ReserveData) (*)\n\t\tExpression: reserveCache.reserveConfiguration = reserve.configuration\n\t\tIRs:\n\t\t\tREF_1023(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tREF_1024(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tREF_1023(DataTypes.ReserveConfigurationMap) (->reserveCache) := REF_1024(DataTypes.ReserveConfigurationMap)\n\t\tExpression: reserveCache.reserveFactor = reserveCache.reserveConfiguration.getReserveFactor()\n\t\tIRs:\n\t\t\tREF_1025(uint256) -> reserveCache.reserveFactor\n\t\t\tREF_1026(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_861(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getReserveFactor(DataTypes.ReserveConfigurationMap), arguments:['REF_1026'] \n\t\t\tREF_1025(uint256) (->reserveCache) := TMP_861(uint256)\n\t\tExpression: reserveCache.currLiquidityIndex = reserveCache.nextLiquidityIndex = reserve.liquidityIndex\n\t\tIRs:\n\t\t\tREF_1028(uint256) -> reserveCache.currLiquidityIndex\n\t\t\tREF_1029(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tREF_1030(uint128) -> reserve.liquidityIndex\n\t\t\tREF_1029(uint256) (->reserveCache) := REF_1030(uint128)\n\t\t\tREF_1028(uint256) (->reserveCache) := REF_1029(uint256)\n\t\tExpression: reserveCache.currVariableBorrowIndex = reserveCache.nextVariableBorrowIndex = reserve.variableBorrowIndex\n\t\tIRs:\n\t\t\tREF_1031(uint256) -> reserveCache.currVariableBorrowIndex\n\t\t\tREF_1032(uint256) -> reserveCache.nextVariableBorrowIndex\n\t\t\tREF_1033(uint128) -> reserve.variableBorrowIndex\n\t\t\tREF_1032(uint256) (->reserveCache) := REF_1033(uint128)\n\t\t\tREF_1031(uint256) (->reserveCache) := REF_1032(uint256)\n\t\tExpression: reserveCache.currLiquidityRate = reserve.currentLiquidityRate\n\t\tIRs:\n\t\t\tREF_1034(uint256) -> reserveCache.currLiquidityRate\n\t\t\tREF_1035(uint128) -> reserve.currentLiquidityRate\n\t\t\tREF_1034(uint256) (->reserveCache) := REF_1035(uint128)\n\t\tExpression: reserveCache.currVariableBorrowRate = reserve.currentVariableBorrowRate\n\t\tIRs:\n\t\t\tREF_1036(uint256) -> reserveCache.currVariableBorrowRate\n\t\t\tREF_1037(uint128) -> reserve.currentVariableBorrowRate\n\t\t\tREF_1036(uint256) (->reserveCache) := REF_1037(uint128)\n\t\tExpression: reserveCache.aTokenAddress = reserve.aTokenAddress\n\t\tIRs:\n\t\t\tREF_1038(address) -> reserveCache.aTokenAddress\n\t\t\tREF_1039(address) -> reserve.aTokenAddress\n\t\t\tREF_1038(address) (->reserveCache) := REF_1039(address)\n\t\tExpression: reserveCache.stableDebtTokenAddress = reserve.stableDebtTokenAddress\n\t\tIRs:\n\t\t\tREF_1040(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tREF_1041(address) -> reserve.stableDebtTokenAddress\n\t\t\tREF_1040(address) (->reserveCache) := REF_1041(address)\n\t\tExpression: reserveCache.variableDebtTokenAddress = reserve.variableDebtTokenAddress\n\t\tIRs:\n\t\t\tREF_1042(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tREF_1043(address) -> reserve.variableDebtTokenAddress\n\t\t\tREF_1042(address) (->reserveCache) := REF_1043(address)\n\t\tExpression: reserveCache.reserveLastUpdateTimestamp = reserve.lastUpdateTimestamp\n\t\tIRs:\n\t\t\tREF_1044(uint40) -> reserveCache.reserveLastUpdateTimestamp\n\t\t\tREF_1045(uint40) -> reserve.lastUpdateTimestamp\n\t\t\tREF_1044(uint40) (->reserveCache) := REF_1045(uint40)\n\t\tExpression: reserveCache.currScaledVariableDebt = reserveCache.nextScaledVariableDebt = IVariableDebtToken(reserveCache.variableDebtTokenAddress).scaledTotalSupply()\n\t\tIRs:\n\t\t\tREF_1046(uint256) -> reserveCache.currScaledVariableDebt\n\t\t\tREF_1047(uint256) -> reserveCache.nextScaledVariableDebt\n\t\t\tREF_1048(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_862 = CONVERT REF_1048 to IVariableDebtToken\n\t\t\tTMP_863(uint256) = HIGH_LEVEL_CALL, dest:TMP_862(IVariableDebtToken), function:scaledTotalSupply, arguments:[]  \n\t\t\tREF_1047(uint256) (->reserveCache) := TMP_863(uint256)\n\t\t\tREF_1046(uint256) (->reserveCache) := REF_1047(uint256)\n\t\tExpression: (reserveCache.currPrincipalStableDebt,reserveCache.currTotalStableDebt,reserveCache.currAvgStableBorrowRate,reserveCache.stableDebtLastUpdateTimestamp) = IStableDebtToken(reserveCache.stableDebtTokenAddress).getSupplyData()\n\t\tIRs:\n\t\t\tREF_1050(uint256) -> reserveCache.currPrincipalStableDebt\n\t\t\tREF_1051(uint256) -> reserveCache.currTotalStableDebt\n\t\t\tREF_1052(uint256) -> reserveCache.currAvgStableBorrowRate\n\t\t\tREF_1053(uint40) -> reserveCache.stableDebtLastUpdateTimestamp\n\t\t\tREF_1054(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_864 = CONVERT REF_1054 to IStableDebtToken\n\t\t\tTUPLE_27(uint256,uint256,uint256,uint40) = HIGH_LEVEL_CALL, dest:TMP_864(IStableDebtToken), function:getSupplyData, arguments:[]  \n\t\t\tREF_1050(uint256)= UNPACK TUPLE_27 index: 0 \n\t\t\tREF_1051(uint256)= UNPACK TUPLE_27 index: 1 \n\t\t\tREF_1052(uint256)= UNPACK TUPLE_27 index: 2 \n\t\t\tREF_1053(uint40)= UNPACK TUPLE_27 index: 3 \n\t\tExpression: reserveCache.nextTotalStableDebt = reserveCache.currTotalStableDebt\n\t\tIRs:\n\t\t\tREF_1056(uint256) -> reserveCache.nextTotalStableDebt\n\t\t\tREF_1057(uint256) -> reserveCache.currTotalStableDebt\n\t\t\tREF_1056(uint256) (->reserveCache) := REF_1057(uint256)\n\t\tExpression: reserveCache.nextAvgStableBorrowRate = reserveCache.currAvgStableBorrowRate\n\t\tIRs:\n\t\t\tREF_1058(uint256) -> reserveCache.nextAvgStableBorrowRate\n\t\t\tREF_1059(uint256) -> reserveCache.currAvgStableBorrowRate\n\t\t\tREF_1058(uint256) (->reserveCache) := REF_1059(uint256)\n\t\tExpression: reserveCache\n\t\tIRs:\n\t\t\tRETURN reserveCache\nContract SupplyLogic\n\tFunction SupplyLogic.executeSupply(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteSupplyParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_1060(address) -> params.asset\n\t\t\tREF_1061(DataTypes.ReserveData) -> reservesData[REF_1060]\n\t\t\treserve(DataTypes.ReserveData) := REF_1061(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_865(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_865(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: ValidationLogic.validateSupply(reserveCache,reserve,params.amount)\n\t\tIRs:\n\t\t\tREF_1065(uint256) -> params.amount\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSupply(DataTypes.ReserveCache,DataTypes.ReserveData,uint256), arguments:['reserveCache', 'reserve', 'REF_1065'] \n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,params.amount,0)\n\t\tIRs:\n\t\t\tREF_1067(address) -> params.asset\n\t\t\tREF_1068(uint256) -> params.amount\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_1067', 'REF_1068', '0'] \n\t\tExpression: IERC20(params.asset).safeTransferFrom(msg.sender,reserveCache.aTokenAddress,params.amount)\n\t\tIRs:\n\t\t\tREF_1069(address) -> params.asset\n\t\t\tTMP_869 = CONVERT REF_1069 to IERC20\n\t\t\tREF_1071(address) -> reserveCache.aTokenAddress\n\t\t\tREF_1072(uint256) -> params.amount\n\t\t\tLIBRARY_CALL, dest:GPv2SafeERC20, function:GPv2SafeERC20.safeTransferFrom(IERC20,address,address,uint256), arguments:['TMP_869', 'msg.sender', 'REF_1071', 'REF_1072'] \n\t\tExpression: isFirstSupply = IAToken(reserveCache.aTokenAddress).mint(msg.sender,params.onBehalfOf,params.amount,reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_1073(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_871 = CONVERT REF_1073 to IAToken\n\t\t\tREF_1075(address) -> params.onBehalfOf\n\t\t\tREF_1076(uint256) -> params.amount\n\t\t\tREF_1077(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_872(bool) = HIGH_LEVEL_CALL, dest:TMP_871(IAToken), function:mint, arguments:['msg.sender', 'REF_1075', 'REF_1076', 'REF_1077']  \n\t\t\tisFirstSupply(bool) := TMP_872(bool)\n\t\tExpression: isFirstSupply\n\t\tIRs:\n\t\t\tCONDITION isFirstSupply\n\t\tExpression: ValidationLogic.validateAutomaticUseAsCollateral(reservesData,reservesList,userConfig,reserveCache.reserveConfiguration,reserveCache.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_1079(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tREF_1080(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_873(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address), arguments:['reservesData', 'reservesList', 'userConfig', 'REF_1079', 'REF_1080'] \n\t\t\tCONDITION TMP_873\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,true)\n\t\tIRs:\n\t\t\tREF_1082(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_1082', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(params.asset,params.onBehalfOf)\n\t\tIRs:\n\t\t\tREF_1083(address) -> params.asset\n\t\t\tREF_1084(address) -> params.onBehalfOf\n\t\t\tEmit ReserveUsedAsCollateralEnabled(REF_1083,REF_1084)\n\t\tExpression: Supply(params.asset,msg.sender,params.onBehalfOf,params.amount,params.referralCode)\n\t\tIRs:\n\t\t\tREF_1085(address) -> params.asset\n\t\t\tREF_1086(address) -> params.onBehalfOf\n\t\t\tREF_1087(uint256) -> params.amount\n\t\t\tREF_1088(uint16) -> params.referralCode\n\t\t\tEmit Supply(REF_1085,msg.sender,REF_1086,REF_1087,REF_1088)\n\tFunction SupplyLogic.executeWithdraw(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteWithdrawParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_1089(address) -> params.asset\n\t\t\tREF_1090(DataTypes.ReserveData) -> reservesData[REF_1089]\n\t\t\treserve(DataTypes.ReserveData) := REF_1090(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_877(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_877(DataTypes.ReserveCache)\n\t\tExpression: reserve.updateState(reserveCache)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateState(DataTypes.ReserveData,DataTypes.ReserveCache), arguments:['reserve', 'reserveCache'] \n\t\tExpression: userBalance = IAToken(reserveCache.aTokenAddress).scaledBalanceOf(msg.sender).rayMul(reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_1093(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_879 = CONVERT REF_1093 to IAToken\n\t\t\tTMP_880(uint256) = HIGH_LEVEL_CALL, dest:TMP_879(IAToken), function:scaledBalanceOf, arguments:['msg.sender']  \n\t\t\tREF_1096(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_881(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_880', 'REF_1096'] \n\t\t\tuserBalance(uint256) := TMP_881(uint256)\n\t\tExpression: amountToWithdraw = params.amount\n\t\tIRs:\n\t\t\tREF_1097(uint256) -> params.amount\n\t\t\tamountToWithdraw(uint256) := REF_1097(uint256)\n\t\tExpression: params.amount == type()(uint256).max\n\t\tIRs:\n\t\t\tREF_1098(uint256) -> params.amount\n\t\t\tTMP_883(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tTMP_884(bool) = REF_1098 == TMP_883\n\t\t\tCONDITION TMP_884\n\t\tExpression: amountToWithdraw = userBalance\n\t\tIRs:\n\t\t\tamountToWithdraw(uint256) := userBalance(uint256)\n\t\tExpression: ValidationLogic.validateWithdraw(reserveCache,amountToWithdraw,userBalance)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateWithdraw(DataTypes.ReserveCache,uint256,uint256), arguments:['reserveCache', 'amountToWithdraw', 'userBalance'] \n\t\tExpression: reserve.updateInterestRates(reserveCache,params.asset,0,amountToWithdraw)\n\t\tIRs:\n\t\t\tREF_1101(address) -> params.asset\n\t\t\tLIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.updateInterestRates(DataTypes.ReserveData,DataTypes.ReserveCache,address,uint256,uint256), arguments:['reserve', 'reserveCache', 'REF_1101', '0', 'amountToWithdraw'] \n\t\tExpression: isCollateral = userConfig.isUsingAsCollateral(reserve.id)\n\t\tIRs:\n\t\t\tREF_1103(uint16) -> reserve.id\n\t\t\tTMP_887(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'REF_1103'] \n\t\t\tisCollateral(bool) := TMP_887(bool)\n\t\tExpression: isCollateral && amountToWithdraw == userBalance\n\t\tIRs:\n\t\t\tTMP_888(bool) = amountToWithdraw == userBalance\n\t\t\tTMP_889(bool) = isCollateral && TMP_888\n\t\t\tCONDITION TMP_889\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,false)\n\t\tIRs:\n\t\t\tREF_1105(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_1105', 'False'] \n\t\tExpression: ReserveUsedAsCollateralDisabled(params.asset,msg.sender)\n\t\tIRs:\n\t\t\tREF_1106(address) -> params.asset\n\t\t\tEmit ReserveUsedAsCollateralDisabled(REF_1106,msg.sender)\n\t\tExpression: IAToken(reserveCache.aTokenAddress).burn(msg.sender,params.to,amountToWithdraw,reserveCache.nextLiquidityIndex)\n\t\tIRs:\n\t\t\tREF_1107(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_892 = CONVERT REF_1107 to IAToken\n\t\t\tREF_1109(address) -> params.to\n\t\t\tREF_1110(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_892(IAToken), function:burn, arguments:['msg.sender', 'REF_1109', 'amountToWithdraw', 'REF_1110']  \n\t\tExpression: isCollateral && userConfig.isBorrowingAny()\n\t\tIRs:\n\t\t\tTMP_894(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowingAny(DataTypes.UserConfigurationMap), arguments:['userConfig'] \n\t\t\tTMP_895(bool) = isCollateral && TMP_894\n\t\t\tCONDITION TMP_895\n\t\tExpression: ValidationLogic.validateHFAndLtv(reservesData,reservesList,eModeCategories,userConfig,params.asset,msg.sender,params.reservesCount,params.oracle,params.userEModeCategory)\n\t\tIRs:\n\t\t\tREF_1113(address) -> params.asset\n\t\t\tREF_1114(uint256) -> params.reservesCount\n\t\t\tREF_1115(address) -> params.oracle\n\t\t\tREF_1116(uint8) -> params.userEModeCategory\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateHFAndLtv(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,address,uint256,address,uint8), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'REF_1113', 'msg.sender', 'REF_1114', 'REF_1115', 'REF_1116'] \n\t\tExpression: Withdraw(params.asset,msg.sender,params.to,amountToWithdraw)\n\t\tIRs:\n\t\t\tREF_1117(address) -> params.asset\n\t\t\tREF_1118(address) -> params.to\n\t\t\tEmit Withdraw(REF_1117,msg.sender,REF_1118,amountToWithdraw)\n\t\tExpression: amountToWithdraw\n\t\tIRs:\n\t\t\tRETURN amountToWithdraw\n\tFunction SupplyLogic.executeFinalizeTransfer(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),mapping(address => DataTypes.UserConfigurationMap),DataTypes.FinalizeTransferParams) (*)\n\t\tExpression: reserve = reservesData[params.asset]\n\t\tIRs:\n\t\t\tREF_1119(address) -> params.asset\n\t\t\tREF_1120(DataTypes.ReserveData) -> reservesData[REF_1119]\n\t\t\treserve(DataTypes.ReserveData) := REF_1120(DataTypes.ReserveData)\n\t\tExpression: ValidationLogic.validateTransfer(reserve)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateTransfer(DataTypes.ReserveData), arguments:['reserve'] \n\t\tExpression: reserveId = reserve.id\n\t\tIRs:\n\t\t\tREF_1122(uint16) -> reserve.id\n\t\t\treserveId(uint256) := REF_1122(uint16)\n\t\tExpression: params.from != params.to && params.amount != 0\n\t\tIRs:\n\t\t\tREF_1123(address) -> params.from\n\t\t\tREF_1124(address) -> params.to\n\t\t\tTMP_899(bool) = REF_1123 != REF_1124\n\t\t\tREF_1125(uint256) -> params.amount\n\t\t\tTMP_900(bool) = REF_1125 != 0\n\t\t\tTMP_901(bool) = TMP_899 && TMP_900\n\t\t\tCONDITION TMP_901\n\t\tExpression: fromConfig = usersConfig[params.from]\n\t\tIRs:\n\t\t\tREF_1126(address) -> params.from\n\t\t\tREF_1127(DataTypes.UserConfigurationMap) -> usersConfig[REF_1126]\n\t\t\tfromConfig(DataTypes.UserConfigurationMap) := REF_1127(DataTypes.UserConfigurationMap)\n\t\tExpression: fromConfig.isUsingAsCollateral(reserveId)\n\t\tIRs:\n\t\t\tTMP_902(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['fromConfig', 'reserveId'] \n\t\t\tCONDITION TMP_902\n\t\tExpression: fromConfig.isBorrowingAny()\n\t\tIRs:\n\t\t\tTMP_903(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowingAny(DataTypes.UserConfigurationMap), arguments:['fromConfig'] \n\t\t\tCONDITION TMP_903\n\t\tExpression: ValidationLogic.validateHFAndLtv(reservesData,reservesList,eModeCategories,usersConfig[params.from],params.asset,params.from,params.reservesCount,params.oracle,params.fromEModeCategory)\n\t\tIRs:\n\t\t\tREF_1131(address) -> params.from\n\t\t\tREF_1132(DataTypes.UserConfigurationMap) -> usersConfig[REF_1131]\n\t\t\tREF_1133(address) -> params.asset\n\t\t\tREF_1134(address) -> params.from\n\t\t\tREF_1135(uint256) -> params.reservesCount\n\t\t\tREF_1136(address) -> params.oracle\n\t\t\tREF_1137(uint8) -> params.fromEModeCategory\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateHFAndLtv(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,address,uint256,address,uint8), arguments:['reservesData', 'reservesList', 'eModeCategories', 'REF_1132', 'REF_1133', 'REF_1134', 'REF_1135', 'REF_1136', 'REF_1137'] \n\t\tExpression: params.balanceFromBefore == params.amount\n\t\tIRs:\n\t\t\tREF_1138(uint256) -> params.balanceFromBefore\n\t\t\tREF_1139(uint256) -> params.amount\n\t\t\tTMP_905(bool) = REF_1138 == REF_1139\n\t\t\tCONDITION TMP_905\n\t\tExpression: fromConfig.setUsingAsCollateral(reserveId,false)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['fromConfig', 'reserveId', 'False'] \n\t\tExpression: ReserveUsedAsCollateralDisabled(params.asset,params.from)\n\t\tIRs:\n\t\t\tREF_1141(address) -> params.asset\n\t\t\tREF_1142(address) -> params.from\n\t\t\tEmit ReserveUsedAsCollateralDisabled(REF_1141,REF_1142)\n\t\tExpression: params.balanceToBefore == 0\n\t\tIRs:\n\t\t\tREF_1143(uint256) -> params.balanceToBefore\n\t\t\tTMP_908(bool) = REF_1143 == 0\n\t\t\tCONDITION TMP_908\n\t\tExpression: toConfig = usersConfig[params.to]\n\t\tIRs:\n\t\t\tREF_1144(address) -> params.to\n\t\t\tREF_1145(DataTypes.UserConfigurationMap) -> usersConfig[REF_1144]\n\t\t\ttoConfig(DataTypes.UserConfigurationMap) := REF_1145(DataTypes.UserConfigurationMap)\n\t\tExpression: ValidationLogic.validateAutomaticUseAsCollateral(reservesData,reservesList,toConfig,reserve.configuration,reserve.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_1147(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tREF_1148(address) -> reserve.aTokenAddress\n\t\t\tTMP_909(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address), arguments:['reservesData', 'reservesList', 'toConfig', 'REF_1147', 'REF_1148'] \n\t\t\tCONDITION TMP_909\n\t\tExpression: toConfig.setUsingAsCollateral(reserveId,true)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['toConfig', 'reserveId', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(params.asset,params.to)\n\t\tIRs:\n\t\t\tREF_1150(address) -> params.asset\n\t\t\tREF_1151(address) -> params.to\n\t\t\tEmit ReserveUsedAsCollateralEnabled(REF_1150,REF_1151)\n\tFunction SupplyLogic.executeUseReserveAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,bool,uint256,address,uint8) (*)\n\t\tExpression: reserve = reservesData[asset]\n\t\tIRs:\n\t\t\tREF_1152(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treserve(DataTypes.ReserveData) := REF_1152(DataTypes.ReserveData)\n\t\tExpression: reserveCache = reserve.cache()\n\t\tIRs:\n\t\t\tTMP_912(DataTypes.ReserveCache) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.cache(DataTypes.ReserveData), arguments:['reserve'] \n\t\t\treserveCache(DataTypes.ReserveCache) := TMP_912(DataTypes.ReserveCache)\n\t\tExpression: userBalance = IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender)\n\t\tIRs:\n\t\t\tREF_1154(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_913 = CONVERT REF_1154 to IERC20\n\t\t\tTMP_914(uint256) = HIGH_LEVEL_CALL, dest:TMP_913(IERC20), function:balanceOf, arguments:['msg.sender']  \n\t\t\tuserBalance(uint256) := TMP_914(uint256)\n\t\tExpression: ValidationLogic.validateSetUseReserveAsCollateral(reserveCache,userBalance)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateSetUseReserveAsCollateral(DataTypes.ReserveCache,uint256), arguments:['reserveCache', 'userBalance'] \n\t\tExpression: useAsCollateral == userConfig.isUsingAsCollateral(reserve.id)\n\t\tIRs:\n\t\t\tREF_1158(uint16) -> reserve.id\n\t\t\tTMP_916(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'REF_1158'] \n\t\t\tTMP_917(bool) = useAsCollateral == TMP_916\n\t\t\tCONDITION TMP_917\n\t\tExpression: useAsCollateral\n\t\tIRs:\n\t\t\tCONDITION useAsCollateral\n\t\tExpression: require(bool,string)(ValidationLogic.validateUseAsCollateral(reservesData,reservesList,userConfig,reserveCache.reserveConfiguration),Errors.USER_IN_ISOLATION_MODE_OR_LTV_ZERO)\n\t\tIRs:\n\t\t\tREF_1160(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_918(bool) = LIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap), arguments:['reservesData', 'reservesList', 'userConfig', 'REF_1160'] \n\t\t\tREF_1161(string) -> Errors.USER_IN_ISOLATION_MODE_OR_LTV_ZERO\n\t\t\tTMP_919(None) = SOLIDITY_CALL require(bool,string)(TMP_918,REF_1161)\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,true)\n\t\tIRs:\n\t\t\tREF_1163(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_1163', 'True'] \n\t\tExpression: ReserveUsedAsCollateralEnabled(asset,msg.sender)\n\t\tIRs:\n\t\t\tEmit ReserveUsedAsCollateralEnabled(asset,msg.sender)\n\t\tExpression: userConfig.setUsingAsCollateral(reserve.id,false)\n\t\tIRs:\n\t\t\tREF_1165(uint16) -> reserve.id\n\t\t\tLIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.setUsingAsCollateral(DataTypes.UserConfigurationMap,uint256,bool), arguments:['userConfig', 'REF_1165', 'False'] \n\t\tExpression: ValidationLogic.validateHFAndLtv(reservesData,reservesList,eModeCategories,userConfig,asset,msg.sender,reservesCount,priceOracle,userEModeCategory)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:ValidationLogic, function:ValidationLogic.validateHFAndLtv(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,address,uint256,address,uint8), arguments:['reservesData', 'reservesList', 'eModeCategories', 'userConfig', 'asset', 'msg.sender', 'reservesCount', 'priceOracle', 'userEModeCategory'] \n\t\tExpression: ReserveUsedAsCollateralDisabled(asset,msg.sender)\n\t\tIRs:\n\t\t\tEmit ReserveUsedAsCollateralDisabled(asset,msg.sender)\nContract ValidationLogic\n\tFunction ValidationLogic.validateSupply(DataTypes.ReserveCache,DataTypes.ReserveData,uint256) (*)\n\t\tExpression: require(bool,string)(amount != 0,Errors.INVALID_AMOUNT)\n\t\tIRs:\n\t\t\tTMP_925(bool) = amount != 0\n\t\t\tREF_1167(string) -> Errors.INVALID_AMOUNT\n\t\t\tTMP_926(None) = SOLIDITY_CALL require(bool,string)(TMP_925,REF_1167)\n\t\tExpression: (isActive,isFrozen,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1168(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_28(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1168'] \n\t\t\tisActive(bool)= UNPACK TUPLE_28 index: 0 \n\t\t\tisFrozen(bool)= UNPACK TUPLE_28 index: 1 \n\t\t\tisPaused(bool)= UNPACK TUPLE_28 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1170(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_927(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1170)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_928 = UnaryType.BANG isPaused \n\t\t\tREF_1171(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_929(None) = SOLIDITY_CALL require(bool,string)(TMP_928,REF_1171)\n\t\tExpression: require(bool,string)(! isFrozen,Errors.RESERVE_FROZEN)\n\t\tIRs:\n\t\t\tTMP_930 = UnaryType.BANG isFrozen \n\t\t\tREF_1172(string) -> Errors.RESERVE_FROZEN\n\t\t\tTMP_931(None) = SOLIDITY_CALL require(bool,string)(TMP_930,REF_1172)\n\t\tExpression: supplyCap = reserveCache.reserveConfiguration.getSupplyCap()\n\t\tIRs:\n\t\t\tREF_1173(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_932(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getSupplyCap(DataTypes.ReserveConfigurationMap), arguments:['REF_1173'] \n\t\t\tsupplyCap(uint256) := TMP_932(uint256)\n\t\tExpression: require(bool,string)(supplyCap == 0 || ((IAToken(reserveCache.aTokenAddress).scaledTotalSupply() + uint256(reserve.accruedToTreasury)).rayMul(reserveCache.nextLiquidityIndex) + amount) <= supplyCap * (10 ** reserveCache.reserveConfiguration.getDecimals()),Errors.SUPPLY_CAP_EXCEEDED)\n\t\tIRs:\n\t\t\tTMP_933(bool) = supplyCap == 0\n\t\t\tREF_1175(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_934 = CONVERT REF_1175 to IAToken\n\t\t\tTMP_935(uint256) = HIGH_LEVEL_CALL, dest:TMP_934(IAToken), function:scaledTotalSupply, arguments:[]  \n\t\t\tREF_1177(uint128) -> reserve.accruedToTreasury\n\t\t\tTMP_936 = CONVERT REF_1177 to uint256\n\t\t\tTMP_937(uint256) = TMP_935 (c)+ TMP_936\n\t\t\tREF_1179(uint256) -> reserveCache.nextLiquidityIndex\n\t\t\tTMP_938(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['TMP_937', 'REF_1179'] \n\t\t\tTMP_939(uint256) = TMP_938 (c)+ amount\n\t\t\tREF_1180(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_940(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_1180'] \n\t\t\tTMP_941(uint256) = 10 (c)** TMP_940\n\t\t\tTMP_942(uint256) = supplyCap (c)* TMP_941\n\t\t\tTMP_943(bool) = TMP_939 <= TMP_942\n\t\t\tTMP_944(bool) = TMP_933 || TMP_943\n\t\t\tREF_1182(string) -> Errors.SUPPLY_CAP_EXCEEDED\n\t\t\tTMP_945(None) = SOLIDITY_CALL require(bool,string)(TMP_944,REF_1182)\n\tFunction ValidationLogic.validateWithdraw(DataTypes.ReserveCache,uint256,uint256) (*)\n\t\tExpression: require(bool,string)(amount != 0,Errors.INVALID_AMOUNT)\n\t\tIRs:\n\t\t\tTMP_946(bool) = amount != 0\n\t\t\tREF_1183(string) -> Errors.INVALID_AMOUNT\n\t\t\tTMP_947(None) = SOLIDITY_CALL require(bool,string)(TMP_946,REF_1183)\n\t\tExpression: require(bool,string)(amount <= userBalance,Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE)\n\t\tIRs:\n\t\t\tTMP_948(bool) = amount <= userBalance\n\t\t\tREF_1184(string) -> Errors.NOT_ENOUGH_AVAILABLE_USER_BALANCE\n\t\t\tTMP_949(None) = SOLIDITY_CALL require(bool,string)(TMP_948,REF_1184)\n\t\tExpression: (isActive,None,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1185(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_29(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1185'] \n\t\t\tisActive(bool)= UNPACK TUPLE_29 index: 0 \n\t\t\tisPaused(bool)= UNPACK TUPLE_29 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1187(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_950(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1187)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_951 = UnaryType.BANG isPaused \n\t\t\tREF_1188(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_952(None) = SOLIDITY_CALL require(bool,string)(TMP_951,REF_1188)\n\tFunction ValidationLogic.validateBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.ValidateBorrowParams) (*)\n\t\tExpression: require(bool,string)(params.amount != 0,Errors.INVALID_AMOUNT)\n\t\tIRs:\n\t\t\tREF_1189(uint256) -> params.amount\n\t\t\tTMP_953(bool) = REF_1189 != 0\n\t\t\tREF_1190(string) -> Errors.INVALID_AMOUNT\n\t\t\tTMP_954(None) = SOLIDITY_CALL require(bool,string)(TMP_953,REF_1190)\n\t\tExpression: (vars.isActive,vars.isFrozen,vars.borrowingEnabled,vars.stableRateBorrowingEnabled,vars.isPaused) = params.reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1191(bool) -> vars.isActive\n\t\t\tREF_1192(bool) -> vars.isFrozen\n\t\t\tREF_1193(bool) -> vars.borrowingEnabled\n\t\t\tREF_1194(bool) -> vars.stableRateBorrowingEnabled\n\t\t\tREF_1195(bool) -> vars.isPaused\n\t\t\tREF_1196(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1197(DataTypes.ReserveConfigurationMap) -> REF_1196.reserveConfiguration\n\t\t\tTUPLE_30(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1197'] \n\t\t\tREF_1191(bool)= UNPACK TUPLE_30 index: 0 \n\t\t\tREF_1192(bool)= UNPACK TUPLE_30 index: 1 \n\t\t\tREF_1193(bool)= UNPACK TUPLE_30 index: 2 \n\t\t\tREF_1194(bool)= UNPACK TUPLE_30 index: 3 \n\t\t\tREF_1195(bool)= UNPACK TUPLE_30 index: 4 \n\t\tExpression: require(bool,string)(vars.isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1199(bool) -> vars.isActive\n\t\t\tREF_1200(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_955(None) = SOLIDITY_CALL require(bool,string)(REF_1199,REF_1200)\n\t\tExpression: require(bool,string)(! vars.isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tREF_1201(bool) -> vars.isPaused\n\t\t\tTMP_956 = UnaryType.BANG REF_1201 \n\t\t\tREF_1202(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_957(None) = SOLIDITY_CALL require(bool,string)(TMP_956,REF_1202)\n\t\tExpression: require(bool,string)(! vars.isFrozen,Errors.RESERVE_FROZEN)\n\t\tIRs:\n\t\t\tREF_1203(bool) -> vars.isFrozen\n\t\t\tTMP_958 = UnaryType.BANG REF_1203 \n\t\t\tREF_1204(string) -> Errors.RESERVE_FROZEN\n\t\t\tTMP_959(None) = SOLIDITY_CALL require(bool,string)(TMP_958,REF_1204)\n\t\tExpression: require(bool,string)(vars.borrowingEnabled,Errors.BORROWING_NOT_ENABLED)\n\t\tIRs:\n\t\t\tREF_1205(bool) -> vars.borrowingEnabled\n\t\t\tREF_1206(string) -> Errors.BORROWING_NOT_ENABLED\n\t\t\tTMP_960(None) = SOLIDITY_CALL require(bool,string)(REF_1205,REF_1206)\n\t\tExpression: require(bool,string)(params.priceOracleSentinel == address(0) || IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(),Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED)\n\t\tIRs:\n\t\t\tREF_1207(address) -> params.priceOracleSentinel\n\t\t\tTMP_961 = CONVERT 0 to address\n\t\t\tTMP_962(bool) = REF_1207 == TMP_961\n\t\t\tREF_1208(address) -> params.priceOracleSentinel\n\t\t\tTMP_963 = CONVERT REF_1208 to IPriceOracleSentinel\n\t\t\tTMP_964(bool) = HIGH_LEVEL_CALL, dest:TMP_963(IPriceOracleSentinel), function:isBorrowAllowed, arguments:[]  \n\t\t\tTMP_965(bool) = TMP_962 || TMP_964\n\t\t\tREF_1210(string) -> Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n\t\t\tTMP_966(None) = SOLIDITY_CALL require(bool,string)(TMP_965,REF_1210)\n\t\tExpression: require(bool,string)(params.interestRateMode == DataTypes.InterestRateMode.VARIABLE || params.interestRateMode == DataTypes.InterestRateMode.STABLE,Errors.INVALID_INTEREST_RATE_MODE_SELECTED)\n\t\tIRs:\n\t\t\tREF_1211(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_1212(DataTypes.InterestRateMode) -> InterestRateMode.VARIABLE\n\t\t\tTMP_967(bool) = REF_1211 == REF_1212\n\t\t\tREF_1213(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_1214(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_968(bool) = REF_1213 == REF_1214\n\t\t\tTMP_969(bool) = TMP_967 || TMP_968\n\t\t\tREF_1215(string) -> Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n\t\t\tTMP_970(None) = SOLIDITY_CALL require(bool,string)(TMP_969,REF_1215)\n\t\tExpression: vars.reserveDecimals = params.reserveCache.reserveConfiguration.getDecimals()\n\t\tIRs:\n\t\t\tREF_1216(uint256) -> vars.reserveDecimals\n\t\t\tREF_1217(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1218(DataTypes.ReserveConfigurationMap) -> REF_1217.reserveConfiguration\n\t\t\tTMP_971(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDecimals(DataTypes.ReserveConfigurationMap), arguments:['REF_1218'] \n\t\t\tREF_1216(uint256) (->vars) := TMP_971(uint256)\n\t\tExpression: vars.borrowCap = params.reserveCache.reserveConfiguration.getBorrowCap()\n\t\tIRs:\n\t\t\tREF_1220(uint256) -> vars.borrowCap\n\t\t\tREF_1221(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1222(DataTypes.ReserveConfigurationMap) -> REF_1221.reserveConfiguration\n\t\t\tTMP_972(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getBorrowCap(DataTypes.ReserveConfigurationMap), arguments:['REF_1222'] \n\t\t\tREF_1220(uint256) (->vars) := TMP_972(uint256)\n\t\tExpression: vars.assetUnit = 10 ** vars.reserveDecimals\n\t\tIRs:\n\t\t\tREF_1224(uint256) -> vars.assetUnit\n\t\t\tREF_1225(uint256) -> vars.reserveDecimals\n\t\t\tTMP_973(uint256) = 10 ** REF_1225\n\t\t\tREF_1224(uint256) (->vars) := TMP_973(uint256)\n\t\tExpression: vars.borrowCap != 0\n\t\tIRs:\n\t\t\tREF_1226(uint256) -> vars.borrowCap\n\t\t\tTMP_974(bool) = REF_1226 != 0\n\t\t\tCONDITION TMP_974\n\t\tExpression: vars.totalSupplyVariableDebt = params.reserveCache.currScaledVariableDebt.rayMul(params.reserveCache.nextVariableBorrowIndex)\n\t\tIRs:\n\t\t\tREF_1227(uint256) -> vars.totalSupplyVariableDebt\n\t\t\tREF_1228(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1229(uint256) -> REF_1228.currScaledVariableDebt\n\t\t\tREF_1231(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1232(uint256) -> REF_1231.nextVariableBorrowIndex\n\t\t\tTMP_975(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['REF_1229', 'REF_1232'] \n\t\t\tREF_1227(uint256) (->vars) := TMP_975(uint256)\n\t\tExpression: vars.totalDebt = params.reserveCache.currTotalStableDebt + vars.totalSupplyVariableDebt + params.amount\n\t\tIRs:\n\t\t\tREF_1233(uint256) -> vars.totalDebt\n\t\t\tREF_1234(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1235(uint256) -> REF_1234.currTotalStableDebt\n\t\t\tREF_1236(uint256) -> vars.totalSupplyVariableDebt\n\t\t\tTMP_976(uint256) = REF_1235 (c)+ REF_1236\n\t\t\tREF_1237(uint256) -> params.amount\n\t\t\tTMP_977(uint256) = TMP_976 (c)+ REF_1237\n\t\t\tREF_1233(uint256) (->vars) := TMP_977(uint256)\n\t\tExpression: require(bool,string)(vars.totalDebt <= vars.borrowCap * vars.assetUnit,Errors.BORROW_CAP_EXCEEDED)\n\t\tIRs:\n\t\t\tREF_1238(uint256) -> vars.totalDebt\n\t\t\tREF_1239(uint256) -> vars.borrowCap\n\t\t\tREF_1240(uint256) -> vars.assetUnit\n\t\t\tTMP_978(uint256) = REF_1239 * REF_1240\n\t\t\tTMP_979(bool) = REF_1238 <= TMP_978\n\t\t\tREF_1241(string) -> Errors.BORROW_CAP_EXCEEDED\n\t\t\tTMP_980(None) = SOLIDITY_CALL require(bool,string)(TMP_979,REF_1241)\n\t\tExpression: params.isolationModeActive\n\t\tIRs:\n\t\t\tREF_1242(bool) -> params.isolationModeActive\n\t\t\tCONDITION REF_1242\n\t\tExpression: require(bool,string)(params.reserveCache.reserveConfiguration.getBorrowableInIsolation(),Errors.ASSET_NOT_BORROWABLE_IN_ISOLATION)\n\t\tIRs:\n\t\t\tREF_1243(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1244(DataTypes.ReserveConfigurationMap) -> REF_1243.reserveConfiguration\n\t\t\tTMP_981(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getBorrowableInIsolation(DataTypes.ReserveConfigurationMap), arguments:['REF_1244'] \n\t\t\tREF_1246(string) -> Errors.ASSET_NOT_BORROWABLE_IN_ISOLATION\n\t\t\tTMP_982(None) = SOLIDITY_CALL require(bool,string)(TMP_981,REF_1246)\n\t\tExpression: require(bool,string)(reservesData[params.isolationModeCollateralAddress].isolationModeTotalDebt + (params.amount / 10 ** (vars.reserveDecimals - ReserveConfiguration.DEBT_CEILING_DECIMALS)).toUint128() <= params.isolationModeDebtCeiling,Errors.DEBT_CEILING_EXCEEDED)\n\t\tIRs:\n\t\t\tREF_1247(address) -> params.isolationModeCollateralAddress\n\t\t\tREF_1248(DataTypes.ReserveData) -> reservesData[REF_1247]\n\t\t\tREF_1249(uint128) -> REF_1248.isolationModeTotalDebt\n\t\t\tREF_1250(uint256) -> params.amount\n\t\t\tREF_1251(uint256) -> vars.reserveDecimals\n\t\t\tREF_1252(uint256) -> ReserveConfiguration.DEBT_CEILING_DECIMALS\n\t\t\tTMP_983(uint256) = REF_1251 (c)- REF_1252\n\t\t\tTMP_984(uint256) = 10 (c)** TMP_983\n\t\t\tTMP_985(uint256) = REF_1250 (c)/ TMP_984\n\t\t\tTMP_986(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['TMP_985'] \n\t\t\tTMP_987(uint128) = REF_1249 (c)+ TMP_986\n\t\t\tREF_1254(uint256) -> params.isolationModeDebtCeiling\n\t\t\tTMP_988(bool) = TMP_987 <= REF_1254\n\t\t\tREF_1255(string) -> Errors.DEBT_CEILING_EXCEEDED\n\t\t\tTMP_989(None) = SOLIDITY_CALL require(bool,string)(TMP_988,REF_1255)\n\t\tExpression: params.userEModeCategory != 0\n\t\tIRs:\n\t\t\tREF_1256(uint8) -> params.userEModeCategory\n\t\t\tTMP_990(bool) = REF_1256 != 0\n\t\t\tCONDITION TMP_990\n\t\tExpression: require(bool,string)(params.reserveCache.reserveConfiguration.getEModeCategory() == params.userEModeCategory,Errors.INCONSISTENT_EMODE_CATEGORY)\n\t\tIRs:\n\t\t\tREF_1257(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1258(DataTypes.ReserveConfigurationMap) -> REF_1257.reserveConfiguration\n\t\t\tTMP_991(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getEModeCategory(DataTypes.ReserveConfigurationMap), arguments:['REF_1258'] \n\t\t\tREF_1260(uint8) -> params.userEModeCategory\n\t\t\tTMP_992(bool) = TMP_991 == REF_1260\n\t\t\tREF_1261(string) -> Errors.INCONSISTENT_EMODE_CATEGORY\n\t\t\tTMP_993(None) = SOLIDITY_CALL require(bool,string)(TMP_992,REF_1261)\n\t\tExpression: vars.eModePriceSource = eModeCategories[params.userEModeCategory].priceSource\n\t\tIRs:\n\t\t\tREF_1262(address) -> vars.eModePriceSource\n\t\t\tREF_1263(uint8) -> params.userEModeCategory\n\t\t\tREF_1264(DataTypes.EModeCategory) -> eModeCategories[REF_1263]\n\t\t\tREF_1265(address) -> REF_1264.priceSource\n\t\t\tREF_1262(address) (->vars) := REF_1265(address)\n\t\tExpression: (vars.userCollateralInBaseCurrency,vars.userDebtInBaseCurrency,vars.currentLtv,None,vars.healthFactor,None) = GenericLogic.calculateUserAccountData(reservesData,reservesList,eModeCategories,DataTypes.CalculateUserAccountDataParams({userConfig:params.userConfig,reservesCount:params.reservesCount,user:params.userAddress,oracle:params.oracle,userEModeCategory:params.userEModeCategory}))\n\t\tIRs:\n\t\t\tREF_1266(uint256) -> vars.userCollateralInBaseCurrency\n\t\t\tREF_1267(uint256) -> vars.userDebtInBaseCurrency\n\t\t\tREF_1268(uint256) -> vars.currentLtv\n\t\t\tREF_1269(uint256) -> vars.healthFactor\n\t\t\tREF_1272(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_1273(uint256) -> params.reservesCount\n\t\t\tREF_1274(address) -> params.userAddress\n\t\t\tREF_1275(address) -> params.oracle\n\t\t\tREF_1276(uint8) -> params.userEModeCategory\n\t\t\tTMP_994(DataTypes.CalculateUserAccountDataParams) = new CalculateUserAccountDataParams(REF_1272,REF_1273,REF_1274,REF_1275,REF_1276)\n\t\t\tTUPLE_31(uint256,uint256,uint256,uint256,uint256,bool) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'TMP_994'] \n\t\t\tREF_1266(uint256)= UNPACK TUPLE_31 index: 0 \n\t\t\tREF_1267(uint256)= UNPACK TUPLE_31 index: 1 \n\t\t\tREF_1268(uint256)= UNPACK TUPLE_31 index: 2 \n\t\t\tREF_1269(uint256)= UNPACK TUPLE_31 index: 4 \n\t\tExpression: require(bool,string)(vars.userCollateralInBaseCurrency != 0,Errors.COLLATERAL_BALANCE_IS_ZERO)\n\t\tIRs:\n\t\t\tREF_1277(uint256) -> vars.userCollateralInBaseCurrency\n\t\t\tTMP_995(bool) = REF_1277 != 0\n\t\t\tREF_1278(string) -> Errors.COLLATERAL_BALANCE_IS_ZERO\n\t\t\tTMP_996(None) = SOLIDITY_CALL require(bool,string)(TMP_995,REF_1278)\n\t\tExpression: require(bool,string)(vars.currentLtv != 0,Errors.LTV_VALIDATION_FAILED)\n\t\tIRs:\n\t\t\tREF_1279(uint256) -> vars.currentLtv\n\t\t\tTMP_997(bool) = REF_1279 != 0\n\t\t\tREF_1280(string) -> Errors.LTV_VALIDATION_FAILED\n\t\t\tTMP_998(None) = SOLIDITY_CALL require(bool,string)(TMP_997,REF_1280)\n\t\tExpression: require(bool,string)(vars.healthFactor > HEALTH_FACTOR_LIQUIDATION_THRESHOLD,Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD)\n\t\tIRs:\n\t\t\tREF_1281(uint256) -> vars.healthFactor\n\t\t\tTMP_999(bool) = REF_1281 > HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n\t\t\tREF_1282(string) -> Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n\t\t\tTMP_1000(None) = SOLIDITY_CALL require(bool,string)(TMP_999,REF_1282)\n\t\tExpression: vars.amountInBaseCurrency /= vars.assetUnit\n\t\tIRs:\n\t\t\tREF_1283(uint256) -> vars.amountInBaseCurrency\n\t\t\tREF_1284(uint256) -> vars.assetUnit\n\t\t\tREF_1283(-> vars) = REF_1283 / REF_1284\n\t\tExpression: vars.collateralNeededInBaseCurrency = (vars.userDebtInBaseCurrency + vars.amountInBaseCurrency).percentDiv(vars.currentLtv)\n\t\tIRs:\n\t\t\tREF_1285(uint256) -> vars.collateralNeededInBaseCurrency\n\t\t\tREF_1286(uint256) -> vars.userDebtInBaseCurrency\n\t\t\tREF_1287(uint256) -> vars.amountInBaseCurrency\n\t\t\tTMP_1001(uint256) = REF_1286 (c)+ REF_1287\n\t\t\tREF_1289(uint256) -> vars.currentLtv\n\t\t\tTMP_1002(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentDiv(uint256,uint256), arguments:['TMP_1001', 'REF_1289'] \n\t\t\tREF_1285(uint256) (->vars) := TMP_1002(uint256)\n\t\tExpression: require(bool,string)(vars.collateralNeededInBaseCurrency <= vars.userCollateralInBaseCurrency,Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW)\n\t\tIRs:\n\t\t\tREF_1290(uint256) -> vars.collateralNeededInBaseCurrency\n\t\t\tREF_1291(uint256) -> vars.userCollateralInBaseCurrency\n\t\t\tTMP_1003(bool) = REF_1290 <= REF_1291\n\t\t\tREF_1292(string) -> Errors.COLLATERAL_CANNOT_COVER_NEW_BORROW\n\t\t\tTMP_1004(None) = SOLIDITY_CALL require(bool,string)(TMP_1003,REF_1292)\n\t\tExpression: params.interestRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_1293(DataTypes.InterestRateMode) -> params.interestRateMode\n\t\t\tREF_1294(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_1005(bool) = REF_1293 == REF_1294\n\t\t\tCONDITION TMP_1005\n\t\tExpression: require(bool,string)(vars.stableRateBorrowingEnabled,Errors.STABLE_BORROWING_NOT_ENABLED)\n\t\tIRs:\n\t\t\tREF_1295(bool) -> vars.stableRateBorrowingEnabled\n\t\t\tREF_1296(string) -> Errors.STABLE_BORROWING_NOT_ENABLED\n\t\t\tTMP_1006(None) = SOLIDITY_CALL require(bool,string)(REF_1295,REF_1296)\n\t\tExpression: require(bool,string)(! params.userConfig.isUsingAsCollateral(reservesData[params.asset].id) || params.reserveCache.reserveConfiguration.getLtv() == 0 || params.amount > IERC20(params.reserveCache.aTokenAddress).balanceOf(params.userAddress),Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY)\n\t\tIRs:\n\t\t\tREF_1297(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tREF_1299(address) -> params.asset\n\t\t\tREF_1300(DataTypes.ReserveData) -> reservesData[REF_1299]\n\t\t\tREF_1301(uint16) -> REF_1300.id\n\t\t\tTMP_1007(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['REF_1297', 'REF_1301'] \n\t\t\tTMP_1008 = UnaryType.BANG TMP_1007 \n\t\t\tREF_1302(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1303(DataTypes.ReserveConfigurationMap) -> REF_1302.reserveConfiguration\n\t\t\tTMP_1009(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap), arguments:['REF_1303'] \n\t\t\tTMP_1010(bool) = TMP_1009 == 0\n\t\t\tTMP_1011(bool) = TMP_1008 || TMP_1010\n\t\t\tREF_1305(uint256) -> params.amount\n\t\t\tREF_1306(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1307(address) -> REF_1306.aTokenAddress\n\t\t\tTMP_1012 = CONVERT REF_1307 to IERC20\n\t\t\tREF_1309(address) -> params.userAddress\n\t\t\tTMP_1013(uint256) = HIGH_LEVEL_CALL, dest:TMP_1012(IERC20), function:balanceOf, arguments:['REF_1309']  \n\t\t\tTMP_1014(bool) = REF_1305 > TMP_1013\n\t\t\tTMP_1015(bool) = TMP_1011 || TMP_1014\n\t\t\tREF_1310(string) -> Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n\t\t\tTMP_1016(None) = SOLIDITY_CALL require(bool,string)(TMP_1015,REF_1310)\n\t\tExpression: vars.availableLiquidity = IERC20(params.asset).balanceOf(params.reserveCache.aTokenAddress)\n\t\tIRs:\n\t\t\tREF_1311(uint256) -> vars.availableLiquidity\n\t\t\tREF_1312(address) -> params.asset\n\t\t\tTMP_1017 = CONVERT REF_1312 to IERC20\n\t\t\tREF_1314(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1315(address) -> REF_1314.aTokenAddress\n\t\t\tTMP_1018(uint256) = HIGH_LEVEL_CALL, dest:TMP_1017(IERC20), function:balanceOf, arguments:['REF_1315']  \n\t\t\tREF_1311(uint256) (->vars) := TMP_1018(uint256)\n\t\tExpression: maxLoanSizeStable = vars.availableLiquidity.percentMul(params.maxStableLoanPercent)\n\t\tIRs:\n\t\t\tREF_1316(uint256) -> vars.availableLiquidity\n\t\t\tREF_1318(uint256) -> params.maxStableLoanPercent\n\t\t\tTMP_1019(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['REF_1316', 'REF_1318'] \n\t\t\tmaxLoanSizeStable(uint256) := TMP_1019(uint256)\n\t\tExpression: require(bool,string)(params.amount <= maxLoanSizeStable,Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE)\n\t\tIRs:\n\t\t\tREF_1319(uint256) -> params.amount\n\t\t\tTMP_1020(bool) = REF_1319 <= maxLoanSizeStable\n\t\t\tREF_1320(string) -> Errors.AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE\n\t\t\tTMP_1021(None) = SOLIDITY_CALL require(bool,string)(TMP_1020,REF_1320)\n\t\tExpression: params.userConfig.isBorrowingAny()\n\t\tIRs:\n\t\t\tREF_1321(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tTMP_1022(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowingAny(DataTypes.UserConfigurationMap), arguments:['REF_1321'] \n\t\t\tCONDITION TMP_1022\n\t\tExpression: (vars.siloedBorrowingEnabled,vars.siloedBorrowingAddress) = params.userConfig.getSiloedBorrowingState(reservesData,reservesList)\n\t\tIRs:\n\t\t\tREF_1323(bool) -> vars.siloedBorrowingEnabled\n\t\t\tREF_1324(address) -> vars.siloedBorrowingAddress\n\t\t\tREF_1325(DataTypes.UserConfigurationMap) -> params.userConfig\n\t\t\tTUPLE_32(bool,address) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.getSiloedBorrowingState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)), arguments:['REF_1325', 'reservesData', 'reservesList'] \n\t\t\tREF_1323(bool)= UNPACK TUPLE_32 index: 0 \n\t\t\tREF_1324(address)= UNPACK TUPLE_32 index: 1 \n\t\tExpression: vars.siloedBorrowingEnabled\n\t\tIRs:\n\t\t\tREF_1327(bool) -> vars.siloedBorrowingEnabled\n\t\t\tCONDITION REF_1327\n\t\tExpression: require(bool,string)(vars.siloedBorrowingAddress == params.asset,Errors.SILOED_BORROWING_VIOLATION)\n\t\tIRs:\n\t\t\tREF_1328(address) -> vars.siloedBorrowingAddress\n\t\t\tREF_1329(address) -> params.asset\n\t\t\tTMP_1023(bool) = REF_1328 == REF_1329\n\t\t\tREF_1330(string) -> Errors.SILOED_BORROWING_VIOLATION\n\t\t\tTMP_1024(None) = SOLIDITY_CALL require(bool,string)(TMP_1023,REF_1330)\n\t\tExpression: require(bool,string)(! params.reserveCache.reserveConfiguration.getSiloedBorrowing(),Errors.SILOED_BORROWING_VIOLATION)\n\t\tIRs:\n\t\t\tREF_1331(DataTypes.ReserveCache) -> params.reserveCache\n\t\t\tREF_1332(DataTypes.ReserveConfigurationMap) -> REF_1331.reserveConfiguration\n\t\t\tTMP_1025(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getSiloedBorrowing(DataTypes.ReserveConfigurationMap), arguments:['REF_1332'] \n\t\t\tTMP_1026 = UnaryType.BANG TMP_1025 \n\t\t\tREF_1334(string) -> Errors.SILOED_BORROWING_VIOLATION\n\t\t\tTMP_1027(None) = SOLIDITY_CALL require(bool,string)(TMP_1026,REF_1334)\n\t\tExpression: vars.eModePriceSource != address(0)\n\t\tIRs:\n\t\t\tREF_1335(address) -> vars.eModePriceSource\n\t\t\tTMP_1028 = CONVERT 0 to address\n\t\t\tTMP_1029(bool) = REF_1335 != TMP_1028\n\t\t\tCONDITION TMP_1029\n\t\tExpression: vars.amountInBaseCurrency = IPriceOracleGetter(params.oracle).getAssetPrice(vars.eModePriceSource) * params.amount\n\t\tIRs:\n\t\t\tREF_1336(uint256) -> vars.amountInBaseCurrency\n\t\t\tREF_1337(address) -> params.oracle\n\t\t\tTMP_1030 = CONVERT REF_1337 to IPriceOracleGetter\n\t\t\tREF_1339(address) -> vars.eModePriceSource\n\t\t\tTMP_1031(uint256) = HIGH_LEVEL_CALL, dest:TMP_1030(IPriceOracleGetter), function:getAssetPrice, arguments:['REF_1339']  \n\t\t\tREF_1340(uint256) -> params.amount\n\t\t\tTMP_1032(uint256) = TMP_1031 (c)* REF_1340\n\t\t\tREF_1336(uint256) (->vars) := TMP_1032(uint256)\n\t\tExpression: vars.amountInBaseCurrency = IPriceOracleGetter(params.oracle).getAssetPrice(params.asset) * params.amount\n\t\tIRs:\n\t\t\tREF_1341(uint256) -> vars.amountInBaseCurrency\n\t\t\tREF_1342(address) -> params.oracle\n\t\t\tTMP_1033 = CONVERT REF_1342 to IPriceOracleGetter\n\t\t\tREF_1344(address) -> params.asset\n\t\t\tTMP_1034(uint256) = HIGH_LEVEL_CALL, dest:TMP_1033(IPriceOracleGetter), function:getAssetPrice, arguments:['REF_1344']  \n\t\t\tREF_1345(uint256) -> params.amount\n\t\t\tTMP_1035(uint256) = TMP_1034 (c)* REF_1345\n\t\t\tREF_1341(uint256) (->vars) := TMP_1035(uint256)\n\tFunction ValidationLogic.validateRepay(DataTypes.ReserveCache,uint256,DataTypes.InterestRateMode,address,uint256,uint256) (*)\n\t\tExpression: require(bool,string)(amountSent != 0,Errors.INVALID_AMOUNT)\n\t\tIRs:\n\t\t\tTMP_1036(bool) = amountSent != 0\n\t\t\tREF_1346(string) -> Errors.INVALID_AMOUNT\n\t\t\tTMP_1037(None) = SOLIDITY_CALL require(bool,string)(TMP_1036,REF_1346)\n\t\tExpression: require(bool,string)(amountSent != type()(uint256).max || msg.sender == onBehalfOf,Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF)\n\t\tIRs:\n\t\t\tTMP_1039(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129639935(uint256)\n\t\t\tTMP_1040(bool) = amountSent != TMP_1039\n\t\t\tTMP_1041(bool) = msg.sender == onBehalfOf\n\t\t\tTMP_1042(bool) = TMP_1040 || TMP_1041\n\t\t\tREF_1347(string) -> Errors.NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n\t\t\tTMP_1043(None) = SOLIDITY_CALL require(bool,string)(TMP_1042,REF_1347)\n\t\tExpression: (isActive,None,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1348(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_33(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1348'] \n\t\t\tisActive(bool)= UNPACK TUPLE_33 index: 0 \n\t\t\tisPaused(bool)= UNPACK TUPLE_33 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1350(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1044(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1350)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1045 = UnaryType.BANG isPaused \n\t\t\tREF_1351(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1046(None) = SOLIDITY_CALL require(bool,string)(TMP_1045,REF_1351)\n\t\tExpression: require(bool,string)((stableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.STABLE) || (variableDebt != 0 && interestRateMode == DataTypes.InterestRateMode.VARIABLE),Errors.NO_DEBT_OF_SELECTED_TYPE)\n\t\tIRs:\n\t\t\tTMP_1047(bool) = stableDebt != 0\n\t\t\tREF_1352(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_1048(bool) = interestRateMode == REF_1352\n\t\t\tTMP_1049(bool) = TMP_1047 && TMP_1048\n\t\t\tTMP_1050(bool) = variableDebt != 0\n\t\t\tREF_1353(DataTypes.InterestRateMode) -> InterestRateMode.VARIABLE\n\t\t\tTMP_1051(bool) = interestRateMode == REF_1353\n\t\t\tTMP_1052(bool) = TMP_1050 && TMP_1051\n\t\t\tTMP_1053(bool) = TMP_1049 || TMP_1052\n\t\t\tREF_1354(string) -> Errors.NO_DEBT_OF_SELECTED_TYPE\n\t\t\tTMP_1054(None) = SOLIDITY_CALL require(bool,string)(TMP_1053,REF_1354)\n\tFunction ValidationLogic.validateSwapRateMode(DataTypes.ReserveData,DataTypes.ReserveCache,DataTypes.UserConfigurationMap,uint256,uint256,DataTypes.InterestRateMode) (*)\n\t\tExpression: (isActive,isFrozen,None,stableRateEnabled,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1355(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_34(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1355'] \n\t\t\tisActive(bool)= UNPACK TUPLE_34 index: 0 \n\t\t\tisFrozen(bool)= UNPACK TUPLE_34 index: 1 \n\t\t\tstableRateEnabled(bool)= UNPACK TUPLE_34 index: 3 \n\t\t\tisPaused(bool)= UNPACK TUPLE_34 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1357(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1055(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1357)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1056 = UnaryType.BANG isPaused \n\t\t\tREF_1358(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1057(None) = SOLIDITY_CALL require(bool,string)(TMP_1056,REF_1358)\n\t\tExpression: require(bool,string)(! isFrozen,Errors.RESERVE_FROZEN)\n\t\tIRs:\n\t\t\tTMP_1058 = UnaryType.BANG isFrozen \n\t\t\tREF_1359(string) -> Errors.RESERVE_FROZEN\n\t\t\tTMP_1059(None) = SOLIDITY_CALL require(bool,string)(TMP_1058,REF_1359)\n\t\tExpression: currentRateMode == DataTypes.InterestRateMode.STABLE\n\t\tIRs:\n\t\t\tREF_1360(DataTypes.InterestRateMode) -> InterestRateMode.STABLE\n\t\t\tTMP_1060(bool) = currentRateMode == REF_1360\n\t\t\tCONDITION TMP_1060\n\t\tExpression: require(bool,string)(stableDebt != 0,Errors.NO_OUTSTANDING_STABLE_DEBT)\n\t\tIRs:\n\t\t\tTMP_1061(bool) = stableDebt != 0\n\t\t\tREF_1361(string) -> Errors.NO_OUTSTANDING_STABLE_DEBT\n\t\t\tTMP_1062(None) = SOLIDITY_CALL require(bool,string)(TMP_1061,REF_1361)\n\t\tExpression: currentRateMode == DataTypes.InterestRateMode.VARIABLE\n\t\tIRs:\n\t\t\tREF_1362(DataTypes.InterestRateMode) -> InterestRateMode.VARIABLE\n\t\t\tTMP_1063(bool) = currentRateMode == REF_1362\n\t\t\tCONDITION TMP_1063\n\t\tExpression: require(bool,string)(variableDebt != 0,Errors.NO_OUTSTANDING_VARIABLE_DEBT)\n\t\tIRs:\n\t\t\tTMP_1064(bool) = variableDebt != 0\n\t\t\tREF_1363(string) -> Errors.NO_OUTSTANDING_VARIABLE_DEBT\n\t\t\tTMP_1065(None) = SOLIDITY_CALL require(bool,string)(TMP_1064,REF_1363)\n\t\tExpression: require(bool,string)(stableRateEnabled,Errors.STABLE_BORROWING_NOT_ENABLED)\n\t\tIRs:\n\t\t\tREF_1364(string) -> Errors.STABLE_BORROWING_NOT_ENABLED\n\t\t\tTMP_1066(None) = SOLIDITY_CALL require(bool,string)(stableRateEnabled,REF_1364)\n\t\tExpression: require(bool,string)(! userConfig.isUsingAsCollateral(reserve.id) || reserveCache.reserveConfiguration.getLtv() == 0 || stableDebt + variableDebt > IERC20(reserveCache.aTokenAddress).balanceOf(msg.sender),Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY)\n\t\tIRs:\n\t\t\tREF_1366(uint16) -> reserve.id\n\t\t\tTMP_1067(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'REF_1366'] \n\t\t\tTMP_1068 = UnaryType.BANG TMP_1067 \n\t\t\tREF_1367(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTMP_1069(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap), arguments:['REF_1367'] \n\t\t\tTMP_1070(bool) = TMP_1069 == 0\n\t\t\tTMP_1071(bool) = TMP_1068 || TMP_1070\n\t\t\tTMP_1072(uint256) = stableDebt (c)+ variableDebt\n\t\t\tREF_1369(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_1073 = CONVERT REF_1369 to IERC20\n\t\t\tTMP_1074(uint256) = HIGH_LEVEL_CALL, dest:TMP_1073(IERC20), function:balanceOf, arguments:['msg.sender']  \n\t\t\tTMP_1075(bool) = TMP_1072 > TMP_1074\n\t\t\tTMP_1076(bool) = TMP_1071 || TMP_1075\n\t\t\tREF_1371(string) -> Errors.COLLATERAL_SAME_AS_BORROWING_CURRENCY\n\t\t\tTMP_1077(None) = SOLIDITY_CALL require(bool,string)(TMP_1076,REF_1371)\n\t\tExpression: revert(string)(Errors.INVALID_INTEREST_RATE_MODE_SELECTED)\n\t\tIRs:\n\t\t\tREF_1372(string) -> Errors.INVALID_INTEREST_RATE_MODE_SELECTED\n\t\t\tTMP_1078(None) = SOLIDITY_CALL revert(string)(REF_1372)\n\tFunction ValidationLogic.validateRebalanceStableBorrowRate(DataTypes.ReserveData,DataTypes.ReserveCache,address) (*)\n\t\tExpression: (isActive,None,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1373(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_35(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1373'] \n\t\t\tisActive(bool)= UNPACK TUPLE_35 index: 0 \n\t\t\tisPaused(bool)= UNPACK TUPLE_35 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1375(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1079(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1375)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1080 = UnaryType.BANG isPaused \n\t\t\tREF_1376(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1081(None) = SOLIDITY_CALL require(bool,string)(TMP_1080,REF_1376)\n\t\tExpression: totalDebt = IERC20(reserveCache.stableDebtTokenAddress).totalSupply() + IERC20(reserveCache.variableDebtTokenAddress).totalSupply()\n\t\tIRs:\n\t\t\tREF_1377(address) -> reserveCache.stableDebtTokenAddress\n\t\t\tTMP_1082 = CONVERT REF_1377 to IERC20\n\t\t\tTMP_1083(uint256) = HIGH_LEVEL_CALL, dest:TMP_1082(IERC20), function:totalSupply, arguments:[]  \n\t\t\tREF_1379(address) -> reserveCache.variableDebtTokenAddress\n\t\t\tTMP_1084 = CONVERT REF_1379 to IERC20\n\t\t\tTMP_1085(uint256) = HIGH_LEVEL_CALL, dest:TMP_1084(IERC20), function:totalSupply, arguments:[]  \n\t\t\tTMP_1086(uint256) = TMP_1083 (c)+ TMP_1085\n\t\t\ttotalDebt(uint256) := TMP_1086(uint256)\n\t\tExpression: (liquidityRateVariableDebtOnly,None,None) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(DataTypes.CalculateInterestRatesParams({unbacked:reserve.unbacked,liquidityAdded:0,liquidityTaken:0,totalStableDebt:0,totalVariableDebt:totalDebt,averageStableBorrowRate:0,reserveFactor:reserveCache.reserveFactor,reserve:reserveAddress,aToken:reserveCache.aTokenAddress}))\n\t\tIRs:\n\t\t\tREF_1381(address) -> reserve.interestRateStrategyAddress\n\t\t\tTMP_1087 = CONVERT REF_1381 to IReserveInterestRateStrategy\n\t\t\tREF_1384(uint128) -> reserve.unbacked\n\t\t\tREF_1385(uint256) -> reserveCache.reserveFactor\n\t\t\tREF_1386(address) -> reserveCache.aTokenAddress\n\t\t\tTMP_1088(DataTypes.CalculateInterestRatesParams) = new CalculateInterestRatesParams(REF_1384,0,0,0,totalDebt,0,REF_1385,reserveAddress,REF_1386)\n\t\t\tTUPLE_36(uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_1087(IReserveInterestRateStrategy), function:calculateInterestRates, arguments:['TMP_1088']  \n\t\t\tliquidityRateVariableDebtOnly(uint256)= UNPACK TUPLE_36 index: 0 \n\t\tExpression: require(bool,string)(reserveCache.currLiquidityRate <= liquidityRateVariableDebtOnly.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET)\n\t\tIRs:\n\t\t\tREF_1387(uint256) -> reserveCache.currLiquidityRate\n\t\t\tTMP_1089(uint256) = LIBRARY_CALL, dest:PercentageMath, function:PercentageMath.percentMul(uint256,uint256), arguments:['liquidityRateVariableDebtOnly', 'REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD'] \n\t\t\tTMP_1090(bool) = REF_1387 <= TMP_1089\n\t\t\tREF_1389(string) -> Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n\t\t\tTMP_1091(None) = SOLIDITY_CALL require(bool,string)(TMP_1090,REF_1389)\n\tFunction ValidationLogic.validateSetUseReserveAsCollateral(DataTypes.ReserveCache,uint256) (*)\n\t\tExpression: require(bool,string)(userBalance != 0,Errors.UNDERLYING_BALANCE_ZERO)\n\t\tIRs:\n\t\t\tTMP_1092(bool) = userBalance != 0\n\t\t\tREF_1390(string) -> Errors.UNDERLYING_BALANCE_ZERO\n\t\t\tTMP_1093(None) = SOLIDITY_CALL require(bool,string)(TMP_1092,REF_1390)\n\t\tExpression: (isActive,None,None,None,isPaused) = reserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1391(DataTypes.ReserveConfigurationMap) -> reserveCache.reserveConfiguration\n\t\t\tTUPLE_37(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1391'] \n\t\t\tisActive(bool)= UNPACK TUPLE_37 index: 0 \n\t\t\tisPaused(bool)= UNPACK TUPLE_37 index: 4 \n\t\tExpression: require(bool,string)(isActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1393(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1094(None) = SOLIDITY_CALL require(bool,string)(isActive,REF_1393)\n\t\tExpression: require(bool,string)(! isPaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1095 = UnaryType.BANG isPaused \n\t\t\tREF_1394(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1096(None) = SOLIDITY_CALL require(bool,string)(TMP_1095,REF_1394)\n\tFunction ValidationLogic.validateFlashloan(mapping(address => DataTypes.ReserveData),address[],uint256[]) (*)\n\t\tExpression: require(bool,string)(assets.length == amounts.length,Errors.INCONSISTENT_FLASHLOAN_PARAMS)\n\t\tIRs:\n\t\t\tREF_1395 -> LENGTH assets\n\t\t\tREF_1396 -> LENGTH amounts\n\t\t\tTMP_1097(bool) = REF_1395 == REF_1396\n\t\t\tREF_1397(string) -> Errors.INCONSISTENT_FLASHLOAN_PARAMS\n\t\t\tTMP_1098(None) = SOLIDITY_CALL require(bool,string)(TMP_1097,REF_1397)\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint256) := 0(uint256)\n\t\tExpression: i < assets.length\n\t\tIRs:\n\t\t\tREF_1398 -> LENGTH assets\n\t\t\tTMP_1099(bool) = i < REF_1398\n\t\t\tCONDITION TMP_1099\n\t\tExpression: validateFlashloanSimple(reservesData[assets[i]])\n\t\tIRs:\n\t\t\tREF_1399(address) -> assets[i]\n\t\t\tREF_1400(DataTypes.ReserveData) -> reservesData[REF_1399]\n\t\t\tINTERNAL_CALL, ValidationLogic.validateFlashloanSimple(DataTypes.ReserveData)(REF_1400)\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_1101(uint256) := i(uint256)\n\t\t\ti(uint256) = i (c)+ 1\n\tFunction ValidationLogic.validateFlashloanSimple(DataTypes.ReserveData) (*)\n\t\tExpression: configuration = reserve.configuration\n\t\tIRs:\n\t\t\tREF_1401(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tconfiguration(DataTypes.ReserveConfigurationMap) := REF_1401(DataTypes.ReserveConfigurationMap)\n\t\tExpression: require(bool,string)(! configuration.getPaused(),Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tTMP_1102(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getPaused(DataTypes.ReserveConfigurationMap), arguments:['configuration'] \n\t\t\tTMP_1103 = UnaryType.BANG TMP_1102 \n\t\t\tREF_1403(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1104(None) = SOLIDITY_CALL require(bool,string)(TMP_1103,REF_1403)\n\t\tExpression: require(bool,string)(configuration.getActive(),Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tTMP_1105(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getActive(DataTypes.ReserveConfigurationMap), arguments:['configuration'] \n\t\t\tREF_1405(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1106(None) = SOLIDITY_CALL require(bool,string)(TMP_1105,REF_1405)\n\t\tExpression: require(bool,string)(configuration.getFlashLoanEnabled(),Errors.FLASHLOAN_DISABLED)\n\t\tIRs:\n\t\t\tTMP_1107(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlashLoanEnabled(DataTypes.ReserveConfigurationMap), arguments:['configuration'] \n\t\t\tREF_1407(string) -> Errors.FLASHLOAN_DISABLED\n\t\t\tTMP_1108(None) = SOLIDITY_CALL require(bool,string)(TMP_1107,REF_1407)\n\tFunction ValidationLogic.validateLiquidationCall(DataTypes.UserConfigurationMap,DataTypes.ReserveData,DataTypes.ValidateLiquidationCallParams) (*)\n\t\tExpression: (vars.collateralReserveActive,None,None,None,vars.collateralReservePaused) = collateralReserve.configuration.getFlags()\n\t\tIRs:\n\t\t\tREF_1408(bool) -> vars.collateralReserveActive\n\t\t\tREF_1409(bool) -> vars.collateralReservePaused\n\t\t\tREF_1410(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTUPLE_38(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1410'] \n\t\t\tREF_1408(bool)= UNPACK TUPLE_38 index: 0 \n\t\t\tREF_1409(bool)= UNPACK TUPLE_38 index: 4 \n\t\tExpression: (vars.principalReserveActive,None,None,None,vars.principalReservePaused) = params.debtReserveCache.reserveConfiguration.getFlags()\n\t\tIRs:\n\t\t\tREF_1412(bool) -> vars.principalReserveActive\n\t\t\tREF_1413(bool) -> vars.principalReservePaused\n\t\t\tREF_1414(DataTypes.ReserveCache) -> params.debtReserveCache\n\t\t\tREF_1415(DataTypes.ReserveConfigurationMap) -> REF_1414.reserveConfiguration\n\t\t\tTUPLE_39(bool,bool,bool,bool,bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getFlags(DataTypes.ReserveConfigurationMap), arguments:['REF_1415'] \n\t\t\tREF_1412(bool)= UNPACK TUPLE_39 index: 0 \n\t\t\tREF_1413(bool)= UNPACK TUPLE_39 index: 4 \n\t\tExpression: require(bool,string)(vars.collateralReserveActive && vars.principalReserveActive,Errors.RESERVE_INACTIVE)\n\t\tIRs:\n\t\t\tREF_1417(bool) -> vars.collateralReserveActive\n\t\t\tREF_1418(bool) -> vars.principalReserveActive\n\t\t\tTMP_1109(bool) = REF_1417 && REF_1418\n\t\t\tREF_1419(string) -> Errors.RESERVE_INACTIVE\n\t\t\tTMP_1110(None) = SOLIDITY_CALL require(bool,string)(TMP_1109,REF_1419)\n\t\tExpression: require(bool,string)(! vars.collateralReservePaused && ! vars.principalReservePaused,Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tREF_1420(bool) -> vars.collateralReservePaused\n\t\t\tTMP_1111 = UnaryType.BANG REF_1420 \n\t\t\tREF_1421(bool) -> vars.principalReservePaused\n\t\t\tTMP_1112 = UnaryType.BANG REF_1421 \n\t\t\tTMP_1113(bool) = TMP_1111 && TMP_1112\n\t\t\tREF_1422(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1114(None) = SOLIDITY_CALL require(bool,string)(TMP_1113,REF_1422)\n\t\tExpression: require(bool,string)(params.priceOracleSentinel == address(0) || params.healthFactor < MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD || IPriceOracleSentinel(params.priceOracleSentinel).isLiquidationAllowed(),Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED)\n\t\tIRs:\n\t\t\tREF_1423(address) -> params.priceOracleSentinel\n\t\t\tTMP_1115 = CONVERT 0 to address\n\t\t\tTMP_1116(bool) = REF_1423 == TMP_1115\n\t\t\tREF_1424(uint256) -> params.healthFactor\n\t\t\tTMP_1117(bool) = REF_1424 < MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n\t\t\tTMP_1118(bool) = TMP_1116 || TMP_1117\n\t\t\tREF_1425(address) -> params.priceOracleSentinel\n\t\t\tTMP_1119 = CONVERT REF_1425 to IPriceOracleSentinel\n\t\t\tTMP_1120(bool) = HIGH_LEVEL_CALL, dest:TMP_1119(IPriceOracleSentinel), function:isLiquidationAllowed, arguments:[]  \n\t\t\tTMP_1121(bool) = TMP_1118 || TMP_1120\n\t\t\tREF_1427(string) -> Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n\t\t\tTMP_1122(None) = SOLIDITY_CALL require(bool,string)(TMP_1121,REF_1427)\n\t\tExpression: require(bool,string)(params.healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD,Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD)\n\t\tIRs:\n\t\t\tREF_1428(uint256) -> params.healthFactor\n\t\t\tTMP_1123(bool) = REF_1428 < HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n\t\t\tREF_1429(string) -> Errors.HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n\t\t\tTMP_1124(None) = SOLIDITY_CALL require(bool,string)(TMP_1123,REF_1429)\n\t\tExpression: vars.isCollateralEnabled = collateralReserve.configuration.getLiquidationThreshold() != 0 && userConfig.isUsingAsCollateral(collateralReserve.id)\n\t\tIRs:\n\t\t\tREF_1430(bool) -> vars.isCollateralEnabled\n\t\t\tREF_1431(DataTypes.ReserveConfigurationMap) -> collateralReserve.configuration\n\t\t\tTMP_1125(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLiquidationThreshold(DataTypes.ReserveConfigurationMap), arguments:['REF_1431'] \n\t\t\tTMP_1126(bool) = TMP_1125 != 0\n\t\t\tREF_1434(uint16) -> collateralReserve.id\n\t\t\tTMP_1127(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateral(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'REF_1434'] \n\t\t\tTMP_1128(bool) = TMP_1126 && TMP_1127\n\t\t\tREF_1430(bool) (->vars) := TMP_1128(bool)\n\t\tExpression: require(bool,string)(vars.isCollateralEnabled,Errors.COLLATERAL_CANNOT_BE_LIQUIDATED)\n\t\tIRs:\n\t\t\tREF_1435(bool) -> vars.isCollateralEnabled\n\t\t\tREF_1436(string) -> Errors.COLLATERAL_CANNOT_BE_LIQUIDATED\n\t\t\tTMP_1129(None) = SOLIDITY_CALL require(bool,string)(REF_1435,REF_1436)\n\t\tExpression: require(bool,string)(params.totalDebt != 0,Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER)\n\t\tIRs:\n\t\t\tREF_1437(uint256) -> params.totalDebt\n\t\t\tTMP_1130(bool) = REF_1437 != 0\n\t\t\tREF_1438(string) -> Errors.SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n\t\t\tTMP_1131(None) = SOLIDITY_CALL require(bool,string)(TMP_1130,REF_1438)\n\tFunction ValidationLogic.validateHealthFactor(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,uint8,uint256,address) (*)\n\t\tExpression: (None,None,None,None,healthFactor,hasZeroLtvCollateral) = GenericLogic.calculateUserAccountData(reservesData,reservesList,eModeCategories,DataTypes.CalculateUserAccountDataParams({userConfig:userConfig,reservesCount:reservesCount,user:user,oracle:oracle,userEModeCategory:userEModeCategory}))\n\t\tIRs:\n\t\t\tTMP_1132(DataTypes.CalculateUserAccountDataParams) = new CalculateUserAccountDataParams(userConfig,reservesCount,user,oracle,userEModeCategory)\n\t\t\tTUPLE_40(uint256,uint256,uint256,uint256,uint256,bool) = LIBRARY_CALL, dest:GenericLogic, function:GenericLogic.calculateUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['reservesData', 'reservesList', 'eModeCategories', 'TMP_1132'] \n\t\t\thealthFactor(uint256)= UNPACK TUPLE_40 index: 4 \n\t\t\thasZeroLtvCollateral(bool)= UNPACK TUPLE_40 index: 5 \n\t\tExpression: require(bool,string)(healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD,Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD)\n\t\tIRs:\n\t\t\tTMP_1133(bool) = healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD\n\t\t\tREF_1441(string) -> Errors.HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n\t\t\tTMP_1134(None) = SOLIDITY_CALL require(bool,string)(TMP_1133,REF_1441)\n\t\tExpression: (healthFactor,hasZeroLtvCollateral)\n\t\tIRs:\n\t\t\tRETURN healthFactor,hasZeroLtvCollateral\n\tFunction ValidationLogic.validateHFAndLtv(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,address,uint256,address,uint8) (*)\n\t\tExpression: reserve = reservesData[asset]\n\t\tIRs:\n\t\t\tREF_1442(DataTypes.ReserveData) -> reservesData[asset]\n\t\t\treserve(DataTypes.ReserveData) := REF_1442(DataTypes.ReserveData)\n\t\tExpression: (None,hasZeroLtvCollateral) = validateHealthFactor(reservesData,reservesList,eModeCategories,userConfig,from,userEModeCategory,reservesCount,oracle)\n\t\tIRs:\n\t\t\tTUPLE_41(uint256,bool) = INTERNAL_CALL, ValidationLogic.validateHealthFactor(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,uint8,uint256,address)(reservesData,reservesList,eModeCategories,userConfig,from,userEModeCategory,reservesCount,oracle)\n\t\t\thasZeroLtvCollateral(bool)= UNPACK TUPLE_41 index: 1 \n\t\tExpression: require(bool,string)(! hasZeroLtvCollateral || reserve.configuration.getLtv() == 0,Errors.LTV_VALIDATION_FAILED)\n\t\tIRs:\n\t\t\tTMP_1135 = UnaryType.BANG hasZeroLtvCollateral \n\t\t\tREF_1443(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tTMP_1136(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap), arguments:['REF_1443'] \n\t\t\tTMP_1137(bool) = TMP_1136 == 0\n\t\t\tTMP_1138(bool) = TMP_1135 || TMP_1137\n\t\t\tREF_1445(string) -> Errors.LTV_VALIDATION_FAILED\n\t\t\tTMP_1139(None) = SOLIDITY_CALL require(bool,string)(TMP_1138,REF_1445)\n\tFunction ValidationLogic.validateTransfer(DataTypes.ReserveData) (*)\n\t\tExpression: require(bool,string)(! reserve.configuration.getPaused(),Errors.RESERVE_PAUSED)\n\t\tIRs:\n\t\t\tREF_1446(DataTypes.ReserveConfigurationMap) -> reserve.configuration\n\t\t\tTMP_1140(bool) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getPaused(DataTypes.ReserveConfigurationMap), arguments:['REF_1446'] \n\t\t\tTMP_1141 = UnaryType.BANG TMP_1140 \n\t\t\tREF_1448(string) -> Errors.RESERVE_PAUSED\n\t\t\tTMP_1142(None) = SOLIDITY_CALL require(bool,string)(TMP_1141,REF_1448)\n\tFunction ValidationLogic.validateDropReserve(mapping(uint256 => address),DataTypes.ReserveData,address) (*)\n\t\tExpression: require(bool,string)(asset != address(0),Errors.ZERO_ADDRESS_NOT_VALID)\n\t\tIRs:\n\t\t\tTMP_1143 = CONVERT 0 to address\n\t\t\tTMP_1144(bool) = asset != TMP_1143\n\t\t\tREF_1449(string) -> Errors.ZERO_ADDRESS_NOT_VALID\n\t\t\tTMP_1145(None) = SOLIDITY_CALL require(bool,string)(TMP_1144,REF_1449)\n\t\tExpression: require(bool,string)(reserve.id != 0 || reservesList[0] == asset,Errors.ASSET_NOT_LISTED)\n\t\tIRs:\n\t\t\tREF_1450(uint16) -> reserve.id\n\t\t\tTMP_1146(bool) = REF_1450 != 0\n\t\t\tREF_1451(address) -> reservesList[0]\n\t\t\tTMP_1147(bool) = REF_1451 == asset\n\t\t\tTMP_1148(bool) = TMP_1146 || TMP_1147\n\t\t\tREF_1452(string) -> Errors.ASSET_NOT_LISTED\n\t\t\tTMP_1149(None) = SOLIDITY_CALL require(bool,string)(TMP_1148,REF_1452)\n\t\tExpression: require(bool,string)(IERC20(reserve.stableDebtTokenAddress).totalSupply() == 0,Errors.STABLE_DEBT_NOT_ZERO)\n\t\tIRs:\n\t\t\tREF_1453(address) -> reserve.stableDebtTokenAddress\n\t\t\tTMP_1150 = CONVERT REF_1453 to IERC20\n\t\t\tTMP_1151(uint256) = HIGH_LEVEL_CALL, dest:TMP_1150(IERC20), function:totalSupply, arguments:[]  \n\t\t\tTMP_1152(bool) = TMP_1151 == 0\n\t\t\tREF_1455(string) -> Errors.STABLE_DEBT_NOT_ZERO\n\t\t\tTMP_1153(None) = SOLIDITY_CALL require(bool,string)(TMP_1152,REF_1455)\n\t\tExpression: require(bool,string)(IERC20(reserve.variableDebtTokenAddress).totalSupply() == 0,Errors.VARIABLE_DEBT_SUPPLY_NOT_ZERO)\n\t\tIRs:\n\t\t\tREF_1456(address) -> reserve.variableDebtTokenAddress\n\t\t\tTMP_1154 = CONVERT REF_1456 to IERC20\n\t\t\tTMP_1155(uint256) = HIGH_LEVEL_CALL, dest:TMP_1154(IERC20), function:totalSupply, arguments:[]  \n\t\t\tTMP_1156(bool) = TMP_1155 == 0\n\t\t\tREF_1458(string) -> Errors.VARIABLE_DEBT_SUPPLY_NOT_ZERO\n\t\t\tTMP_1157(None) = SOLIDITY_CALL require(bool,string)(TMP_1156,REF_1458)\n\t\tExpression: require(bool,string)(IERC20(reserve.aTokenAddress).totalSupply() == 0 && reserve.accruedToTreasury == 0,Errors.UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO)\n\t\tIRs:\n\t\t\tREF_1459(address) -> reserve.aTokenAddress\n\t\t\tTMP_1158 = CONVERT REF_1459 to IERC20\n\t\t\tTMP_1159(uint256) = HIGH_LEVEL_CALL, dest:TMP_1158(IERC20), function:totalSupply, arguments:[]  \n\t\t\tTMP_1160(bool) = TMP_1159 == 0\n\t\t\tREF_1461(uint128) -> reserve.accruedToTreasury\n\t\t\tTMP_1161(bool) = REF_1461 == 0\n\t\t\tTMP_1162(bool) = TMP_1160 && TMP_1161\n\t\t\tREF_1462(string) -> Errors.UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO\n\t\t\tTMP_1163(None) = SOLIDITY_CALL require(bool,string)(TMP_1162,REF_1462)\n\tFunction ValidationLogic.validateSetUserEMode(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,uint256,uint8) (*)\n\t\tExpression: require(bool,string)(categoryId == 0 || eModeCategories[categoryId].liquidationThreshold != 0,Errors.INCONSISTENT_EMODE_CATEGORY)\n\t\tIRs:\n\t\t\tTMP_1164(bool) = categoryId == 0\n\t\t\tREF_1463(DataTypes.EModeCategory) -> eModeCategories[categoryId]\n\t\t\tREF_1464(uint16) -> REF_1463.liquidationThreshold\n\t\t\tTMP_1165(bool) = REF_1464 != 0\n\t\t\tTMP_1166(bool) = TMP_1164 || TMP_1165\n\t\t\tREF_1465(string) -> Errors.INCONSISTENT_EMODE_CATEGORY\n\t\t\tTMP_1167(None) = SOLIDITY_CALL require(bool,string)(TMP_1166,REF_1465)\n\t\tExpression: userConfig.isEmpty()\n\t\tIRs:\n\t\t\tTMP_1168(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isEmpty(DataTypes.UserConfigurationMap), arguments:['userConfig'] \n\t\t\tCONDITION TMP_1168\n\t\tExpression: categoryId != 0\n\t\tIRs:\n\t\t\tTMP_1169(bool) = categoryId != 0\n\t\t\tCONDITION TMP_1169\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint256) := 0(uint256)\n\t\tExpression: i < reservesCount\n\t\tIRs:\n\t\t\tTMP_1170(bool) = i < reservesCount\n\t\t\tCONDITION TMP_1170\n\t\tExpression: userConfig.isBorrowing(i)\n\t\tIRs:\n\t\t\tTMP_1171(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isBorrowing(DataTypes.UserConfigurationMap,uint256), arguments:['userConfig', 'i'] \n\t\t\tCONDITION TMP_1171\n\t\tExpression: configuration = reservesData[reservesList[i]].configuration\n\t\tIRs:\n\t\t\tREF_1468(address) -> reservesList[i]\n\t\t\tREF_1469(DataTypes.ReserveData) -> reservesData[REF_1468]\n\t\t\tREF_1470(DataTypes.ReserveConfigurationMap) -> REF_1469.configuration\n\t\t\tconfiguration(DataTypes.ReserveConfigurationMap) := REF_1470(DataTypes.ReserveConfigurationMap)\n\t\tExpression: require(bool,string)(configuration.getEModeCategory() == categoryId,Errors.INCONSISTENT_EMODE_CATEGORY)\n\t\tIRs:\n\t\t\tTMP_1172(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getEModeCategory(DataTypes.ReserveConfigurationMap), arguments:['configuration'] \n\t\t\tTMP_1173(bool) = TMP_1172 == categoryId\n\t\t\tREF_1472(string) -> Errors.INCONSISTENT_EMODE_CATEGORY\n\t\t\tTMP_1174(None) = SOLIDITY_CALL require(bool,string)(TMP_1173,REF_1472)\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_1175(uint256) := i(uint256)\n\t\t\ti(uint256) = i + 1\n\tFunction ValidationLogic.validateUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: reserveConfig.getLtv() == 0\n\t\tIRs:\n\t\t\tTMP_1176(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getLtv(DataTypes.ReserveConfigurationMap), arguments:['reserveConfig'] \n\t\t\tTMP_1177(bool) = TMP_1176 == 0\n\t\t\tCONDITION TMP_1177\n\t\tExpression: false\n\t\tIRs:\n\t\t\tRETURN False\n\t\tExpression: ! userConfig.isUsingAsCollateralAny()\n\t\tIRs:\n\t\t\tTMP_1178(bool) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.isUsingAsCollateralAny(DataTypes.UserConfigurationMap), arguments:['userConfig'] \n\t\t\tTMP_1179 = UnaryType.BANG TMP_1178 \n\t\t\tCONDITION TMP_1179\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\t\tExpression: (isolationModeActive,None,None) = userConfig.getIsolationModeState(reservesData,reservesList)\n\t\tIRs:\n\t\t\tTUPLE_42(bool,address,uint256) = LIBRARY_CALL, dest:UserConfiguration, function:UserConfiguration.getIsolationModeState(DataTypes.UserConfigurationMap,mapping(address => DataTypes.ReserveData),mapping(uint256 => address)), arguments:['userConfig', 'reservesData', 'reservesList'] \n\t\t\tisolationModeActive(bool)= UNPACK TUPLE_42 index: 0 \n\t\tExpression: (! isolationModeActive && reserveConfig.getDebtCeiling() == 0)\n\t\tIRs:\n\t\t\tTMP_1180 = UnaryType.BANG isolationModeActive \n\t\t\tTMP_1181(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap), arguments:['reserveConfig'] \n\t\t\tTMP_1182(bool) = TMP_1181 == 0\n\t\t\tTMP_1183(bool) = TMP_1180 && TMP_1182\n\t\t\tRETURN TMP_1183\n\tFunction ValidationLogic.validateAutomaticUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap,address) (*)\n\t\tExpression: reserveConfig.getDebtCeiling() != 0\n\t\tIRs:\n\t\t\tTMP_1184(uint256) = LIBRARY_CALL, dest:ReserveConfiguration, function:ReserveConfiguration.getDebtCeiling(DataTypes.ReserveConfigurationMap), arguments:['reserveConfig'] \n\t\t\tTMP_1185(bool) = TMP_1184 != 0\n\t\t\tCONDITION TMP_1185\n\t\tExpression: addressesProvider = IncentivizedERC20(aTokenAddress).POOL().ADDRESSES_PROVIDER()\n\t\tIRs:\n\t\t\tTMP_1186 = CONVERT aTokenAddress to IncentivizedERC20\n\t\t\tTMP_1187(IPool) = HIGH_LEVEL_CALL, dest:TMP_1186(IncentivizedERC20), function:POOL, arguments:[]  \n\t\t\tTMP_1188(IPoolAddressesProvider) = HIGH_LEVEL_CALL, dest:TMP_1187(IPool), function:ADDRESSES_PROVIDER, arguments:[]  \n\t\t\taddressesProvider(IPoolAddressesProvider) := TMP_1188(IPoolAddressesProvider)\n\t\tExpression: ! IAccessControl(addressesProvider.getACLManager()).hasRole(ISOLATED_COLLATERAL_SUPPLIER_ROLE,msg.sender)\n\t\tIRs:\n\t\t\tTMP_1189(address) = HIGH_LEVEL_CALL, dest:addressesProvider(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1190 = CONVERT TMP_1189 to IAccessControl\n\t\t\tTMP_1191(bool) = HIGH_LEVEL_CALL, dest:TMP_1190(IAccessControl), function:hasRole, arguments:['ISOLATED_COLLATERAL_SUPPLIER_ROLE', 'msg.sender']  \n\t\t\tTMP_1192 = UnaryType.BANG TMP_1191 \n\t\t\tCONDITION TMP_1192\n\t\tExpression: false\n\t\tIRs:\n\t\t\tRETURN False\n\t\tExpression: validateUseAsCollateral(reservesData,reservesList,userConfig,reserveConfig)\n\t\tIRs:\n\t\t\tTMP_1193(bool) = INTERNAL_CALL, ValidationLogic.validateUseAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ReserveConfigurationMap)(reservesData,reservesList,userConfig,reserveConfig)\n\t\t\tRETURN TMP_1193\n\tFunction ValidationLogic.slitherConstructorConstantVariables() (*)\n\t\tExpression: REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 0.9e4\n\t\tIRs:\n\t\t\tREBALANCE_UP_LIQUIDITY_RATE_THRESHOLD(uint256) := 9000(uint256)\n\t\tExpression: MINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 0.95e18\n\t\tIRs:\n\t\t\tMINIMUM_HEALTH_FACTOR_LIQUIDATION_THRESHOLD(uint256) := 950000000000000000(uint256)\n\t\tExpression: HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18\n\t\tIRs:\n\t\t\tHEALTH_FACTOR_LIQUIDATION_THRESHOLD(uint256) := 1000000000000000000(uint256)\n\t\tExpression: ISOLATED_COLLATERAL_SUPPLIER_ROLE = keccak256(bytes)(ISOLATED_COLLATERAL_SUPPLIER)\n\t\tIRs:\n\t\t\tTMP_1194(bytes32) = SOLIDITY_CALL keccak256(bytes)(ISOLATED_COLLATERAL_SUPPLIER)\n\t\t\tISOLATED_COLLATERAL_SUPPLIER_ROLE(bytes32) := TMP_1194(bytes32)\nContract MathUtils\n\tFunction MathUtils.calculateLinearInterest(uint256,uint40) (*)\n\t\tExpression: result = rate * (block.timestamp - uint256(lastUpdateTimestamp))\n\t\tIRs:\n\t\t\tTMP_1195 = CONVERT lastUpdateTimestamp to uint256\n\t\t\tTMP_1196(uint256) = block.timestamp (c)- TMP_1195\n\t\t\tTMP_1197(uint256) = rate (c)* TMP_1196\n\t\t\tresult(uint256) := TMP_1197(uint256)\n\t\tExpression: result = result / SECONDS_PER_YEAR\n\t\tIRs:\n\t\t\tTMP_1198(uint256) = result / SECONDS_PER_YEAR\n\t\t\tresult(uint256) := TMP_1198(uint256)\n\t\tExpression: WadRayMath.RAY + result\n\t\tIRs:\n\t\t\tREF_1482(uint256) -> WadRayMath.RAY\n\t\t\tTMP_1199(uint256) = REF_1482 (c)+ result\n\t\t\tRETURN TMP_1199\n\tFunction MathUtils.calculateCompoundedInterest(uint256,uint40,uint256) (*)\n\t\tExpression: exp = currentTimestamp - uint256(lastUpdateTimestamp)\n\t\tIRs:\n\t\t\tTMP_1200 = CONVERT lastUpdateTimestamp to uint256\n\t\t\tTMP_1201(uint256) = currentTimestamp (c)- TMP_1200\n\t\t\texp(uint256) := TMP_1201(uint256)\n\t\tExpression: exp == 0\n\t\tIRs:\n\t\t\tTMP_1202(bool) = exp == 0\n\t\t\tCONDITION TMP_1202\n\t\tExpression: WadRayMath.RAY\n\t\tIRs:\n\t\t\tREF_1483(uint256) -> WadRayMath.RAY\n\t\t\tRETURN REF_1483\n\t\tExpression: expMinusOne = exp - 1\n\t\tIRs:\n\t\t\tTMP_1203(uint256) = exp - 1\n\t\t\texpMinusOne(uint256) := TMP_1203(uint256)\n\t\tExpression: basePowerTwo = rate.rayMul(rate) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR)\n\t\tIRs:\n\t\t\tTMP_1204(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['rate', 'rate'] \n\t\t\tTMP_1205(uint256) = SECONDS_PER_YEAR * SECONDS_PER_YEAR\n\t\t\tTMP_1206(uint256) = TMP_1204 / TMP_1205\n\t\t\tbasePowerTwo(uint256) := TMP_1206(uint256)\n\t\tExpression: basePowerThree = basePowerTwo.rayMul(rate) / SECONDS_PER_YEAR\n\t\tIRs:\n\t\t\tTMP_1207(uint256) = LIBRARY_CALL, dest:WadRayMath, function:WadRayMath.rayMul(uint256,uint256), arguments:['basePowerTwo', 'rate'] \n\t\t\tTMP_1208(uint256) = TMP_1207 / SECONDS_PER_YEAR\n\t\t\tbasePowerThree(uint256) := TMP_1208(uint256)\n\t\tExpression: secondTerm = exp * expMinusOne * basePowerTwo\n\t\tIRs:\n\t\t\tTMP_1209(uint256) = exp (c)* expMinusOne\n\t\t\tTMP_1210(uint256) = TMP_1209 (c)* basePowerTwo\n\t\t\tsecondTerm(uint256) := TMP_1210(uint256)\n\t\tExpression: secondTerm /= 2\n\t\tIRs:\n\t\t\tsecondTerm(uint256) = secondTerm / 2\n\t\tExpression: thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree\n\t\tIRs:\n\t\t\tTMP_1211(uint256) = exp (c)* expMinusOne\n\t\t\tTMP_1212(uint256) = TMP_1211 (c)* expMinusTwo\n\t\t\tTMP_1213(uint256) = TMP_1212 (c)* basePowerThree\n\t\t\tthirdTerm(uint256) := TMP_1213(uint256)\n\t\tExpression: thirdTerm /= 6\n\t\tIRs:\n\t\t\tthirdTerm(uint256) = thirdTerm / 6\n\t\tExpression: WadRayMath.RAY + (rate * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm\n\t\tIRs:\n\t\t\tREF_1486(uint256) -> WadRayMath.RAY\n\t\t\tTMP_1214(uint256) = rate (c)* exp\n\t\t\tTMP_1215(uint256) = TMP_1214 (c)/ SECONDS_PER_YEAR\n\t\t\tTMP_1216(uint256) = REF_1486 (c)+ TMP_1215\n\t\t\tTMP_1217(uint256) = TMP_1216 (c)+ secondTerm\n\t\t\tTMP_1218(uint256) = TMP_1217 (c)+ thirdTerm\n\t\t\tRETURN TMP_1218\n\t\tExpression: exp > 2\n\t\tIRs:\n\t\t\tTMP_1219(bool) = exp > 2\n\t\t\tCONDITION TMP_1219\n\t\tExpression: expMinusTwo = exp - 2\n\t\tIRs:\n\t\t\tTMP_1220(uint256) = exp - 2\n\t\t\texpMinusTwo(uint256) := TMP_1220(uint256)\n\t\tExpression: expMinusTwo = 0\n\t\tIRs:\n\t\t\texpMinusTwo(uint256) := 0(uint256)\n\tFunction MathUtils.calculateCompoundedInterest(uint256,uint40) (*)\n\t\tExpression: calculateCompoundedInterest(rate,lastUpdateTimestamp,block.timestamp)\n\t\tIRs:\n\t\t\tTMP_1221(uint256) = INTERNAL_CALL, MathUtils.calculateCompoundedInterest(uint256,uint40,uint256)(rate,lastUpdateTimestamp,block.timestamp)\n\t\t\tRETURN TMP_1221\n\tFunction MathUtils.slitherConstructorConstantVariables() (*)\n\t\tExpression: SECONDS_PER_YEAR = 31536000\n\t\tIRs:\n\t\t\tSECONDS_PER_YEAR(uint256) := 31536000(uint256)\nContract PercentageMath\n\tFunction PercentageMath.percentMul(uint256,uint256) (*)\n\t\tExpression: ! ! percentage | ! value > ~ 0 - HALF_PERCENTAGE_FACTOR / percentage\n\t\tIRs:\n\t\t\tTMP_1222 = UnaryType.BANG percentage \n\t\t\tTMP_1223 = UnaryType.TILD 0 \n\t\t\tTMP_1224(uint256) = TMP_1223 - HALF_PERCENTAGE_FACTOR\n\t\t\tTMP_1225(uint256) = TMP_1224 / percentage\n\t\t\tTMP_1226(bool) = value > TMP_1225\n\t\t\tTMP_1227 = UnaryType.BANG TMP_1226 \n\t\t\tTMP_1228(uint256) = TMP_1222 | TMP_1227\n\t\t\tTMP_1229 = UnaryType.BANG TMP_1228 \n\t\t\tCONDITION TMP_1229\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1230(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: result = value * percentage + HALF_PERCENTAGE_FACTOR / PERCENTAGE_FACTOR\n\t\tIRs:\n\t\t\tTMP_1231(uint256) = value * percentage\n\t\t\tTMP_1232(uint256) = TMP_1231 + HALF_PERCENTAGE_FACTOR\n\t\t\tTMP_1233(uint256) = TMP_1232 / PERCENTAGE_FACTOR\n\t\t\tresult(uint256) := TMP_1233(uint256)\n\t\tExpression: result\n\t\tIRs:\n\t\t\tRETURN result\n\tFunction PercentageMath.percentDiv(uint256,uint256) (*)\n\t\tExpression: ! percentage | ! ! value > ~ 0 - percentage / 2 / PERCENTAGE_FACTOR\n\t\tIRs:\n\t\t\tTMP_1234 = UnaryType.BANG percentage \n\t\t\tTMP_1235 = UnaryType.TILD 0 \n\t\t\tTMP_1236(uint256) = percentage / 2\n\t\t\tTMP_1237(uint256) = TMP_1235 - TMP_1236\n\t\t\tTMP_1238(uint256) = TMP_1237 / PERCENTAGE_FACTOR\n\t\t\tTMP_1239(bool) = value > TMP_1238\n\t\t\tTMP_1240 = UnaryType.BANG TMP_1239 \n\t\t\tTMP_1241 = UnaryType.BANG TMP_1240 \n\t\t\tTMP_1242(uint256) = TMP_1234 | TMP_1241\n\t\t\tCONDITION TMP_1242\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1243(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: result = value * PERCENTAGE_FACTOR + percentage / 2 / percentage\n\t\tIRs:\n\t\t\tTMP_1244(uint256) = value * PERCENTAGE_FACTOR\n\t\t\tTMP_1245(uint256) = percentage / 2\n\t\t\tTMP_1246(uint256) = TMP_1244 + TMP_1245\n\t\t\tTMP_1247(uint256) = TMP_1246 / percentage\n\t\t\tresult(uint256) := TMP_1247(uint256)\n\t\tExpression: result\n\t\tIRs:\n\t\t\tRETURN result\n\tFunction PercentageMath.slitherConstructorConstantVariables() (*)\n\t\tExpression: PERCENTAGE_FACTOR = 1e4\n\t\tIRs:\n\t\t\tPERCENTAGE_FACTOR(uint256) := 10000(uint256)\n\t\tExpression: HALF_PERCENTAGE_FACTOR = 0.5e4\n\t\tIRs:\n\t\t\tHALF_PERCENTAGE_FACTOR(uint256) := 5000(uint256)\nContract WadRayMath\n\tFunction WadRayMath.wadMul(uint256,uint256) (*)\n\t\tExpression: ! ! b | ! a > ~ 0 - HALF_WAD / b\n\t\tIRs:\n\t\t\tTMP_1248 = UnaryType.BANG b \n\t\t\tTMP_1249 = UnaryType.TILD 0 \n\t\t\tTMP_1250(uint256) = TMP_1249 - HALF_WAD\n\t\t\tTMP_1251(uint256) = TMP_1250 / b\n\t\t\tTMP_1252(bool) = a > TMP_1251\n\t\t\tTMP_1253 = UnaryType.BANG TMP_1252 \n\t\t\tTMP_1254(uint256) = TMP_1248 | TMP_1253\n\t\t\tTMP_1255 = UnaryType.BANG TMP_1254 \n\t\t\tCONDITION TMP_1255\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1256(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: c = a * b + HALF_WAD / WAD\n\t\tIRs:\n\t\t\tTMP_1257(uint256) = a * b\n\t\t\tTMP_1258(uint256) = TMP_1257 + HALF_WAD\n\t\t\tTMP_1259(uint256) = TMP_1258 / WAD\n\t\t\tc(uint256) := TMP_1259(uint256)\n\t\tExpression: c\n\t\tIRs:\n\t\t\tRETURN c\n\tFunction WadRayMath.wadDiv(uint256,uint256) (*)\n\t\tExpression: ! b | ! ! a > ~ 0 - b / 2 / WAD\n\t\tIRs:\n\t\t\tTMP_1260 = UnaryType.BANG b \n\t\t\tTMP_1261 = UnaryType.TILD 0 \n\t\t\tTMP_1262(uint256) = b / 2\n\t\t\tTMP_1263(uint256) = TMP_1261 - TMP_1262\n\t\t\tTMP_1264(uint256) = TMP_1263 / WAD\n\t\t\tTMP_1265(bool) = a > TMP_1264\n\t\t\tTMP_1266 = UnaryType.BANG TMP_1265 \n\t\t\tTMP_1267 = UnaryType.BANG TMP_1266 \n\t\t\tTMP_1268(uint256) = TMP_1260 | TMP_1267\n\t\t\tCONDITION TMP_1268\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1269(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: c = a * WAD + b / 2 / b\n\t\tIRs:\n\t\t\tTMP_1270(uint256) = a * WAD\n\t\t\tTMP_1271(uint256) = b / 2\n\t\t\tTMP_1272(uint256) = TMP_1270 + TMP_1271\n\t\t\tTMP_1273(uint256) = TMP_1272 / b\n\t\t\tc(uint256) := TMP_1273(uint256)\n\t\tExpression: c\n\t\tIRs:\n\t\t\tRETURN c\n\tFunction WadRayMath.rayMul(uint256,uint256) (*)\n\t\tExpression: ! ! b | ! a > ~ 0 - HALF_RAY / b\n\t\tIRs:\n\t\t\tTMP_1274 = UnaryType.BANG b \n\t\t\tTMP_1275 = UnaryType.TILD 0 \n\t\t\tTMP_1276(uint256) = TMP_1275 - HALF_RAY\n\t\t\tTMP_1277(uint256) = TMP_1276 / b\n\t\t\tTMP_1278(bool) = a > TMP_1277\n\t\t\tTMP_1279 = UnaryType.BANG TMP_1278 \n\t\t\tTMP_1280(uint256) = TMP_1274 | TMP_1279\n\t\t\tTMP_1281 = UnaryType.BANG TMP_1280 \n\t\t\tCONDITION TMP_1281\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1282(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: c = a * b + HALF_RAY / RAY\n\t\tIRs:\n\t\t\tTMP_1283(uint256) = a * b\n\t\t\tTMP_1284(uint256) = TMP_1283 + HALF_RAY\n\t\t\tTMP_1285(uint256) = TMP_1284 / RAY\n\t\t\tc(uint256) := TMP_1285(uint256)\n\t\tExpression: c\n\t\tIRs:\n\t\t\tRETURN c\n\tFunction WadRayMath.rayDiv(uint256,uint256) (*)\n\t\tExpression: ! b | ! ! a > ~ 0 - b / 2 / RAY\n\t\tIRs:\n\t\t\tTMP_1286 = UnaryType.BANG b \n\t\t\tTMP_1287 = UnaryType.TILD 0 \n\t\t\tTMP_1288(uint256) = b / 2\n\t\t\tTMP_1289(uint256) = TMP_1287 - TMP_1288\n\t\t\tTMP_1290(uint256) = TMP_1289 / RAY\n\t\t\tTMP_1291(bool) = a > TMP_1290\n\t\t\tTMP_1292 = UnaryType.BANG TMP_1291 \n\t\t\tTMP_1293 = UnaryType.BANG TMP_1292 \n\t\t\tTMP_1294(uint256) = TMP_1286 | TMP_1293\n\t\t\tCONDITION TMP_1294\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1295(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: c = a * RAY + b / 2 / b\n\t\tIRs:\n\t\t\tTMP_1296(uint256) = a * RAY\n\t\t\tTMP_1297(uint256) = b / 2\n\t\t\tTMP_1298(uint256) = TMP_1296 + TMP_1297\n\t\t\tTMP_1299(uint256) = TMP_1298 / b\n\t\t\tc(uint256) := TMP_1299(uint256)\n\t\tExpression: c\n\t\tIRs:\n\t\t\tRETURN c\n\tFunction WadRayMath.rayToWad(uint256) (*)\n\t\tExpression: b = a / WAD_RAY_RATIO\n\t\tIRs:\n\t\t\tTMP_1300(uint256) = a / WAD_RAY_RATIO\n\t\t\tb(uint256) := TMP_1300(uint256)\n\t\tExpression: remainder_rayToWad_asm_0 = a % WAD_RAY_RATIO\n\t\tIRs:\n\t\t\tTMP_1301(uint256) = a % WAD_RAY_RATIO\n\t\t\tremainder_rayToWad_asm_0(uint256) := TMP_1301(uint256)\n\t\tExpression: ! remainder_rayToWad_asm_0 < WAD_RAY_RATIO / 2\n\t\tIRs:\n\t\t\tTMP_1302(uint256) = WAD_RAY_RATIO / 2\n\t\t\tTMP_1303(bool) = remainder_rayToWad_asm_0 < TMP_1302\n\t\t\tTMP_1304 = UnaryType.BANG TMP_1303 \n\t\t\tCONDITION TMP_1304\n\t\tExpression: b = b + 1\n\t\tIRs:\n\t\t\tTMP_1305(uint256) = b + 1\n\t\t\tb(uint256) := TMP_1305(uint256)\n\t\tExpression: b\n\t\tIRs:\n\t\t\tRETURN b\n\tFunction WadRayMath.wadToRay(uint256) (*)\n\t\tExpression: b = a * WAD_RAY_RATIO\n\t\tIRs:\n\t\t\tTMP_1306(uint256) = a * WAD_RAY_RATIO\n\t\t\tb(uint256) := TMP_1306(uint256)\n\t\tExpression: ! b / WAD_RAY_RATIO == a\n\t\tIRs:\n\t\t\tTMP_1307(uint256) = b / WAD_RAY_RATIO\n\t\t\tTMP_1308(bool) = TMP_1307 == a\n\t\t\tTMP_1309 = UnaryType.BANG TMP_1308 \n\t\t\tCONDITION TMP_1309\n\t\tExpression: revert(uint256,uint256)(0,0)\n\t\tIRs:\n\t\t\tTMP_1310(None) = SOLIDITY_CALL revert(uint256,uint256)(0,0)\n\t\tExpression: b\n\t\tIRs:\n\t\t\tRETURN b\n\tFunction WadRayMath.slitherConstructorConstantVariables() (*)\n\t\tExpression: WAD = 1e18\n\t\tIRs:\n\t\t\tWAD(uint256) := 1000000000000000000(uint256)\n\t\tExpression: HALF_WAD = 0.5e18\n\t\tIRs:\n\t\t\tHALF_WAD(uint256) := 500000000000000000(uint256)\n\t\tExpression: RAY = 1e27\n\t\tIRs:\n\t\t\tRAY(uint256) := 1000000000000000000000000000(uint256)\n\t\tExpression: HALF_RAY = 0.5e27\n\t\tIRs:\n\t\t\tHALF_RAY(uint256) := 500000000000000000000000000(uint256)\n\t\tExpression: WAD_RAY_RATIO = 1e9\n\t\tIRs:\n\t\t\tWAD_RAY_RATIO(uint256) := 1000000000(uint256)\nContract DataTypes\nContract Pool\n\tFunction IPool.mintUnbacked(address,uint256,address,uint16) \n\tFunction IPool.backUnbacked(address,uint256,uint256) \n\tFunction IPool.supply(address,uint256,address,uint16) \n\tFunction IPool.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) \n\tFunction IPool.withdraw(address,uint256,address) \n\tFunction IPool.borrow(address,uint256,uint256,uint16,address) \n\tFunction IPool.repay(address,uint256,uint256,address) \n\tFunction IPool.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) \n\tFunction IPool.repayWithATokens(address,uint256,uint256) \n\tFunction IPool.swapBorrowRateMode(address,uint256) \n\tFunction IPool.rebalanceStableBorrowRate(address,address) \n\tFunction IPool.setUserUseReserveAsCollateral(address,bool) \n\tFunction IPool.liquidationCall(address,address,address,uint256,bool) \n\tFunction IPool.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) \n\tFunction IPool.flashLoanSimple(address,address,uint256,bytes,uint16) \n\tFunction IPool.getUserAccountData(address) \n\tFunction IPool.initReserve(address,address,address,address,address) \n\tFunction IPool.dropReserve(address) \n\tFunction IPool.setReserveInterestRateStrategyAddress(address,address) \n\tFunction IPool.setConfiguration(address,DataTypes.ReserveConfigurationMap) \n\tFunction IPool.getConfiguration(address) \n\tFunction IPool.getUserConfiguration(address) \n\tFunction IPool.getReserveNormalizedIncome(address) \n\tFunction IPool.getReserveNormalizedVariableDebt(address) \n\tFunction IPool.getReserveData(address) \n\tFunction IPool.finalizeTransfer(address,address,address,uint256,uint256,uint256) \n\tFunction IPool.getReservesList() \n\tFunction IPool.getReserveAddressById(uint16) \n\tFunction IPool.ADDRESSES_PROVIDER() (*)\n\tFunction IPool.updateBridgeProtocolFee(uint256) \n\tFunction IPool.updateFlashloanPremiums(uint128,uint128) \n\tFunction IPool.configureEModeCategory(uint8,DataTypes.EModeCategory) \n\tFunction IPool.getEModeCategoryData(uint8) \n\tFunction IPool.setUserEMode(uint8) \n\tFunction IPool.getUserEMode(address) \n\tFunction IPool.resetIsolationModeTotalDebt(address) \n\tFunction IPool.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() \n\tFunction IPool.FLASHLOAN_PREMIUM_TOTAL() \n\tFunction IPool.BRIDGE_PROTOCOL_FEE() \n\tFunction IPool.FLASHLOAN_PREMIUM_TO_PROTOCOL() \n\tFunction IPool.MAX_NUMBER_RESERVES() \n\tFunction IPool.mintToTreasury(address[]) \n\tFunction IPool.rescueTokens(address,address,uint256) \n\tFunction IPool.deposit(address,uint256,address,uint16) \n\tFunction VersionedInitializable.getRevision() \n\tFunction VersionedInitializable.isConstructor() (*)\n\t\tExpression: cs = extcodesize(uint256)(address()())\n\t\tIRs:\n\t\t\tTMP_1311 = CONVERT this to address\n\t\t\tREF_1487 -> CODESIZE TMP_1311\n\t\t\tcs(uint256) := REF_1487(uint256)\n\t\tExpression: cs == 0\n\t\tIRs:\n\t\t\tTMP_1312(bool) = cs == 0\n\t\t\tRETURN TMP_1312\n\tFunction Pool._onlyPoolConfigurator() (*)\n\t\tExpression: require(bool,string)(ADDRESSES_PROVIDER.getPoolConfigurator() == msg.sender,Errors.CALLER_NOT_POOL_CONFIGURATOR)\n\t\tIRs:\n\t\t\tTMP_1313(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPoolConfigurator, arguments:[]  \n\t\t\tTMP_1314(bool) = TMP_1313 == msg.sender\n\t\t\tREF_1489(string) -> Errors.CALLER_NOT_POOL_CONFIGURATOR\n\t\t\tTMP_1315(None) = SOLIDITY_CALL require(bool,string)(TMP_1314,REF_1489)\n\tFunction Pool._onlyPoolAdmin() (*)\n\t\tExpression: require(bool,string)(IACLManager(ADDRESSES_PROVIDER.getACLManager()).isPoolAdmin(msg.sender),Errors.CALLER_NOT_POOL_ADMIN)\n\t\tIRs:\n\t\t\tTMP_1316(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1317 = CONVERT TMP_1316 to IACLManager\n\t\t\tTMP_1318(bool) = HIGH_LEVEL_CALL, dest:TMP_1317(IACLManager), function:isPoolAdmin, arguments:['msg.sender']  \n\t\t\tREF_1492(string) -> Errors.CALLER_NOT_POOL_ADMIN\n\t\t\tTMP_1319(None) = SOLIDITY_CALL require(bool,string)(TMP_1318,REF_1492)\n\tFunction Pool._onlyBridge() (*)\n\t\tExpression: require(bool,string)(IACLManager(ADDRESSES_PROVIDER.getACLManager()).isBridge(msg.sender),Errors.CALLER_NOT_BRIDGE)\n\t\tIRs:\n\t\t\tTMP_1320(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1321 = CONVERT TMP_1320 to IACLManager\n\t\t\tTMP_1322(bool) = HIGH_LEVEL_CALL, dest:TMP_1321(IACLManager), function:isBridge, arguments:['msg.sender']  \n\t\t\tREF_1495(string) -> Errors.CALLER_NOT_BRIDGE\n\t\t\tTMP_1323(None) = SOLIDITY_CALL require(bool,string)(TMP_1322,REF_1495)\n\tFunction Pool.getRevision() (*)\n\t\tExpression: POOL_REVISION\n\t\tIRs:\n\t\t\tRETURN POOL_REVISION\n\tFunction Pool.constructor(IPoolAddressesProvider) (*)\n\t\tExpression: ADDRESSES_PROVIDER = provider\n\t\tIRs:\n\t\t\tADDRESSES_PROVIDER(IPoolAddressesProvider) := provider(IPoolAddressesProvider)\n\tFunction Pool.initialize(IPoolAddressesProvider) (*)\n\t\tExpression: require(bool,string)(provider == ADDRESSES_PROVIDER,Errors.INVALID_ADDRESSES_PROVIDER)\n\t\tIRs:\n\t\t\tTMP_1324(bool) = provider == ADDRESSES_PROVIDER\n\t\t\tREF_1496(string) -> Errors.INVALID_ADDRESSES_PROVIDER\n\t\t\tTMP_1325(None) = SOLIDITY_CALL require(bool,string)(TMP_1324,REF_1496)\n\t\tExpression: _maxStableRateBorrowSizePercent = 0.25e4\n\t\tIRs:\n\t\t\t_maxStableRateBorrowSizePercent(uint64) := 2500(uint256)\n\t\tExpression: initializer()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, VersionedInitializable.initializer()()\n\tFunction Pool.mintUnbacked(address,uint256,address,uint16) (*)\n\t\tExpression: BridgeLogic.executeMintUnbacked(_reserves,_reservesList,_usersConfig[onBehalfOf],asset,amount,onBehalfOf,referralCode)\n\t\tIRs:\n\t\t\tREF_1498(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tLIBRARY_CALL, dest:BridgeLogic, function:BridgeLogic.executeMintUnbacked(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,address,uint256,address,uint16), arguments:['_reserves', '_reservesList', 'REF_1498', 'asset', 'amount', 'onBehalfOf', 'referralCode'] \n\t\tExpression: onlyBridge()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyBridge()()\n\tFunction Pool.backUnbacked(address,uint256,uint256) (*)\n\t\tExpression: BridgeLogic.executeBackUnbacked(_reserves[asset],asset,amount,fee,_bridgeProtocolFee)\n\t\tIRs:\n\t\t\tREF_1500(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tTMP_1329(uint256) = LIBRARY_CALL, dest:BridgeLogic, function:BridgeLogic.executeBackUnbacked(DataTypes.ReserveData,address,uint256,uint256,uint256), arguments:['REF_1500', 'asset', 'amount', 'fee', '_bridgeProtocolFee'] \n\t\t\tRETURN TMP_1329\n\t\tExpression: onlyBridge()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyBridge()()\n\tFunction Pool.supply(address,uint256,address,uint16) (*)\n\t\tExpression: SupplyLogic.executeSupply(_reserves,_reservesList,_usersConfig[onBehalfOf],DataTypes.ExecuteSupplyParams({asset:asset,amount:amount,onBehalfOf:onBehalfOf,referralCode:referralCode}))\n\t\tIRs:\n\t\t\tREF_1502(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1331(DataTypes.ExecuteSupplyParams) = new ExecuteSupplyParams(asset,amount,onBehalfOf,referralCode)\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeSupply(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteSupplyParams), arguments:['_reserves', '_reservesList', 'REF_1502', 'TMP_1331'] \n\tFunction Pool.supplyWithPermit(address,uint256,address,uint16,uint256,uint8,bytes32,bytes32) (*)\n\t\tExpression: IERC20WithPermit(asset).permit(msg.sender,address(this),amount,deadline,permitV,permitR,permitS)\n\t\tIRs:\n\t\t\tTMP_1333 = CONVERT asset to IERC20WithPermit\n\t\t\tTMP_1334 = CONVERT this to address\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_1333(IERC20WithPermit), function:permit, arguments:['msg.sender', 'TMP_1334', 'amount', 'deadline', 'permitV', 'permitR', 'permitS']  \n\t\tExpression: SupplyLogic.executeSupply(_reserves,_reservesList,_usersConfig[onBehalfOf],DataTypes.ExecuteSupplyParams({asset:asset,amount:amount,onBehalfOf:onBehalfOf,referralCode:referralCode}))\n\t\tIRs:\n\t\t\tREF_1506(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1336(DataTypes.ExecuteSupplyParams) = new ExecuteSupplyParams(asset,amount,onBehalfOf,referralCode)\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeSupply(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteSupplyParams), arguments:['_reserves', '_reservesList', 'REF_1506', 'TMP_1336'] \n\tFunction Pool.withdraw(address,uint256,address) (*)\n\t\tExpression: SupplyLogic.executeWithdraw(_reserves,_reservesList,_eModeCategories,_usersConfig[msg.sender],DataTypes.ExecuteWithdrawParams({asset:asset,amount:amount,to:to,reservesCount:_reservesCount,oracle:ADDRESSES_PROVIDER.getPriceOracle(),userEModeCategory:_usersEModeCategory[msg.sender]}))\n\t\tIRs:\n\t\t\tREF_1509(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1338(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1512(uint8) -> _usersEModeCategory[msg.sender]\n\t\t\tTMP_1339(DataTypes.ExecuteWithdrawParams) = new ExecuteWithdrawParams(asset,amount,to,_reservesCount,TMP_1338,REF_1512)\n\t\t\tTMP_1340(uint256) = LIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeWithdraw(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteWithdrawParams), arguments:['_reserves', '_reservesList', '_eModeCategories', 'REF_1509', 'TMP_1339'] \n\t\t\tRETURN TMP_1340\n\tFunction Pool.borrow(address,uint256,uint256,uint16,address) (*)\n\t\tExpression: BorrowLogic.executeBorrow(_reserves,_reservesList,_eModeCategories,_usersConfig[onBehalfOf],DataTypes.ExecuteBorrowParams({asset:asset,user:msg.sender,onBehalfOf:onBehalfOf,amount:amount,interestRateMode:DataTypes.InterestRateMode(interestRateMode),referralCode:referralCode,releaseUnderlying:true,maxStableRateBorrowSizePercent:_maxStableRateBorrowSizePercent,reservesCount:_reservesCount,oracle:ADDRESSES_PROVIDER.getPriceOracle(),userEModeCategory:_usersEModeCategory[onBehalfOf],priceOracleSentinel:ADDRESSES_PROVIDER.getPriceOracleSentinel()}))\n\t\tIRs:\n\t\t\tREF_1514(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1341 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tTMP_1342(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1517(uint8) -> _usersEModeCategory[onBehalfOf]\n\t\t\tTMP_1343(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracleSentinel, arguments:[]  \n\t\t\tTMP_1344(DataTypes.ExecuteBorrowParams) = new ExecuteBorrowParams(asset,msg.sender,onBehalfOf,amount,TMP_1341,referralCode,True,_maxStableRateBorrowSizePercent,_reservesCount,TMP_1342,REF_1517,TMP_1343)\n\t\t\tLIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeBorrow(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.ExecuteBorrowParams), arguments:['_reserves', '_reservesList', '_eModeCategories', 'REF_1514', 'TMP_1344'] \n\tFunction Pool.repay(address,uint256,uint256,address) (*)\n\t\tExpression: BorrowLogic.executeRepay(_reserves,_reservesList,_usersConfig[onBehalfOf],DataTypes.ExecuteRepayParams({asset:asset,amount:amount,interestRateMode:DataTypes.InterestRateMode(interestRateMode),onBehalfOf:onBehalfOf,useATokens:false}))\n\t\tIRs:\n\t\t\tREF_1520(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1346 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tTMP_1347(DataTypes.ExecuteRepayParams) = new ExecuteRepayParams(asset,amount,TMP_1346,onBehalfOf,False)\n\t\t\tTMP_1348(uint256) = LIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeRepay(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteRepayParams), arguments:['_reserves', '_reservesList', 'REF_1520', 'TMP_1347'] \n\t\t\tRETURN TMP_1348\n\tFunction Pool.repayWithPermit(address,uint256,uint256,address,uint256,uint8,bytes32,bytes32) (*)\n\t\tExpression: IERC20WithPermit(asset).permit(msg.sender,address(this),amount,deadline,permitV,permitR,permitS)\n\t\tIRs:\n\t\t\tTMP_1349 = CONVERT asset to IERC20WithPermit\n\t\t\tTMP_1350 = CONVERT this to address\n\t\t\tHIGH_LEVEL_CALL, dest:TMP_1349(IERC20WithPermit), function:permit, arguments:['msg.sender', 'TMP_1350', 'amount', 'deadline', 'permitV', 'permitR', 'permitS']  \n\t\tExpression: params = DataTypes.ExecuteRepayParams({asset:asset,amount:amount,interestRateMode:DataTypes.InterestRateMode(interestRateMode),onBehalfOf:onBehalfOf,useATokens:false})\n\t\tIRs:\n\t\t\tTMP_1352 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tTMP_1353(DataTypes.ExecuteRepayParams) = new ExecuteRepayParams(asset,amount,TMP_1352,onBehalfOf,False)\n\t\t\tparams(DataTypes.ExecuteRepayParams) := TMP_1353(DataTypes.ExecuteRepayParams)\n\t\tExpression: BorrowLogic.executeRepay(_reserves,_reservesList,_usersConfig[onBehalfOf],params)\n\t\tIRs:\n\t\t\tREF_1525(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1354(uint256) = LIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeRepay(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteRepayParams), arguments:['_reserves', '_reservesList', 'REF_1525', 'params'] \n\t\t\tRETURN TMP_1354\n\tFunction Pool.repayWithATokens(address,uint256,uint256) (*)\n\t\tExpression: BorrowLogic.executeRepay(_reserves,_reservesList,_usersConfig[msg.sender],DataTypes.ExecuteRepayParams({asset:asset,amount:amount,interestRateMode:DataTypes.InterestRateMode(interestRateMode),onBehalfOf:msg.sender,useATokens:true}))\n\t\tIRs:\n\t\t\tREF_1527(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1355 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tTMP_1356(DataTypes.ExecuteRepayParams) = new ExecuteRepayParams(asset,amount,TMP_1355,msg.sender,True)\n\t\t\tTMP_1357(uint256) = LIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeRepay(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteRepayParams), arguments:['_reserves', '_reservesList', 'REF_1527', 'TMP_1356'] \n\t\t\tRETURN TMP_1357\n\tFunction Pool.swapBorrowRateMode(address,uint256) (*)\n\t\tExpression: BorrowLogic.executeSwapBorrowRateMode(_reserves[asset],_usersConfig[msg.sender],asset,DataTypes.InterestRateMode(interestRateMode))\n\t\tIRs:\n\t\t\tREF_1530(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1531(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1358 = CONVERT interestRateMode to DataTypes.InterestRateMode\n\t\t\tLIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeSwapBorrowRateMode(DataTypes.ReserveData,DataTypes.UserConfigurationMap,address,DataTypes.InterestRateMode), arguments:['REF_1530', 'REF_1531', 'asset', 'TMP_1358'] \n\tFunction Pool.rebalanceStableBorrowRate(address,address) (*)\n\t\tExpression: BorrowLogic.executeRebalanceStableBorrowRate(_reserves[asset],asset,user)\n\t\tIRs:\n\t\t\tREF_1533(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tLIBRARY_CALL, dest:BorrowLogic, function:BorrowLogic.executeRebalanceStableBorrowRate(DataTypes.ReserveData,address,address), arguments:['REF_1533', 'asset', 'user'] \n\tFunction Pool.setUserUseReserveAsCollateral(address,bool) (*)\n\t\tExpression: SupplyLogic.executeUseReserveAsCollateral(_reserves,_reservesList,_eModeCategories,_usersConfig[msg.sender],asset,useAsCollateral,_reservesCount,ADDRESSES_PROVIDER.getPriceOracle(),_usersEModeCategory[msg.sender])\n\t\tIRs:\n\t\t\tREF_1535(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1361(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1537(uint8) -> _usersEModeCategory[msg.sender]\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeUseReserveAsCollateral(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,address,bool,uint256,address,uint8), arguments:['_reserves', '_reservesList', '_eModeCategories', 'REF_1535', 'asset', 'useAsCollateral', '_reservesCount', 'TMP_1361', 'REF_1537'] \n\tFunction Pool.liquidationCall(address,address,address,uint256,bool) (*)\n\t\tExpression: LiquidationLogic.executeLiquidationCall(_reserves,_reservesList,_usersConfig,_eModeCategories,DataTypes.ExecuteLiquidationCallParams({reservesCount:_reservesCount,debtToCover:debtToCover,collateralAsset:collateralAsset,debtAsset:debtAsset,user:user,receiveAToken:receiveAToken,priceOracle:ADDRESSES_PROVIDER.getPriceOracle(),userEModeCategory:_usersEModeCategory[user],priceOracleSentinel:ADDRESSES_PROVIDER.getPriceOracleSentinel()}))\n\t\tIRs:\n\t\t\tTMP_1363(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1541(uint8) -> _usersEModeCategory[user]\n\t\t\tTMP_1364(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracleSentinel, arguments:[]  \n\t\t\tTMP_1365(DataTypes.ExecuteLiquidationCallParams) = new ExecuteLiquidationCallParams(_reservesCount,debtToCover,collateralAsset,debtAsset,user,receiveAToken,TMP_1363,REF_1541,TMP_1364)\n\t\t\tLIBRARY_CALL, dest:LiquidationLogic, function:LiquidationLogic.executeLiquidationCall(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(address => DataTypes.UserConfigurationMap),mapping(uint8 => DataTypes.EModeCategory),DataTypes.ExecuteLiquidationCallParams), arguments:['_reserves', '_reservesList', '_usersConfig', '_eModeCategories', 'TMP_1365'] \n\tFunction Pool.flashLoan(address,address[],uint256[],uint256[],address,bytes,uint16) (*)\n\t\tExpression: flashParams = DataTypes.FlashloanParams({receiverAddress:receiverAddress,assets:assets,amounts:amounts,interestRateModes:interestRateModes,onBehalfOf:onBehalfOf,params:params,referralCode:referralCode,flashLoanPremiumToProtocol:_flashLoanPremiumToProtocol,flashLoanPremiumTotal:_flashLoanPremiumTotal,maxStableRateBorrowSizePercent:_maxStableRateBorrowSizePercent,reservesCount:_reservesCount,addressesProvider:address(ADDRESSES_PROVIDER),userEModeCategory:_usersEModeCategory[onBehalfOf],isAuthorizedFlashBorrower:IACLManager(ADDRESSES_PROVIDER.getACLManager()).isFlashBorrower(msg.sender)})\n\t\tIRs:\n\t\t\tTMP_1367 = CONVERT ADDRESSES_PROVIDER to address\n\t\t\tREF_1544(uint8) -> _usersEModeCategory[onBehalfOf]\n\t\t\tTMP_1368(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1369 = CONVERT TMP_1368 to IACLManager\n\t\t\tTMP_1370(bool) = HIGH_LEVEL_CALL, dest:TMP_1369(IACLManager), function:isFlashBorrower, arguments:['msg.sender']  \n\t\t\tTMP_1371(DataTypes.FlashloanParams) = new FlashloanParams(receiverAddress,assets,amounts,interestRateModes,onBehalfOf,params,referralCode,_flashLoanPremiumToProtocol,_flashLoanPremiumTotal,_maxStableRateBorrowSizePercent,_reservesCount,TMP_1367,REF_1544,TMP_1370)\n\t\t\tflashParams(DataTypes.FlashloanParams) := TMP_1371(DataTypes.FlashloanParams)\n\t\tExpression: FlashLoanLogic.executeFlashLoan(_reserves,_reservesList,_eModeCategories,_usersConfig[onBehalfOf],flashParams)\n\t\tIRs:\n\t\t\tREF_1548(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tLIBRARY_CALL, dest:FlashLoanLogic, function:FlashLoanLogic.executeFlashLoan(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.UserConfigurationMap,DataTypes.FlashloanParams), arguments:['_reserves', '_reservesList', '_eModeCategories', 'REF_1548', 'flashParams'] \n\tFunction Pool.flashLoanSimple(address,address,uint256,bytes,uint16) (*)\n\t\tExpression: flashParams = DataTypes.FlashloanSimpleParams({receiverAddress:receiverAddress,asset:asset,amount:amount,params:params,referralCode:referralCode,flashLoanPremiumToProtocol:_flashLoanPremiumToProtocol,flashLoanPremiumTotal:_flashLoanPremiumTotal})\n\t\tIRs:\n\t\t\tTMP_1373(DataTypes.FlashloanSimpleParams) = new FlashloanSimpleParams(receiverAddress,asset,amount,params,referralCode,_flashLoanPremiumToProtocol,_flashLoanPremiumTotal)\n\t\t\tflashParams(DataTypes.FlashloanSimpleParams) := TMP_1373(DataTypes.FlashloanSimpleParams)\n\t\tExpression: FlashLoanLogic.executeFlashLoanSimple(_reserves[asset],flashParams)\n\t\tIRs:\n\t\t\tREF_1551(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tLIBRARY_CALL, dest:FlashLoanLogic, function:FlashLoanLogic.executeFlashLoanSimple(DataTypes.ReserveData,DataTypes.FlashloanSimpleParams), arguments:['REF_1551', 'flashParams'] \n\tFunction Pool.mintToTreasury(address[]) (*)\n\t\tExpression: PoolLogic.executeMintToTreasury(_reserves,assets)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeMintToTreasury(mapping(address => DataTypes.ReserveData),address[]), arguments:['_reserves', 'assets'] \n\tFunction Pool.getReserveData(address) (*)\n\t\tExpression: _reserves[asset]\n\t\tIRs:\n\t\t\tREF_1553(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tRETURN REF_1553\n\tFunction Pool.getUserAccountData(address) (*)\n\t\tExpression: PoolLogic.executeGetUserAccountData(_reserves,_reservesList,_eModeCategories,DataTypes.CalculateUserAccountDataParams({userConfig:_usersConfig[user],reservesCount:_reservesCount,user:user,oracle:ADDRESSES_PROVIDER.getPriceOracle(),userEModeCategory:_usersEModeCategory[user]}))\n\t\tIRs:\n\t\t\tREF_1556(DataTypes.UserConfigurationMap) -> _usersConfig[user]\n\t\t\tTMP_1376(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1558(uint8) -> _usersEModeCategory[user]\n\t\t\tTMP_1377(DataTypes.CalculateUserAccountDataParams) = new CalculateUserAccountDataParams(REF_1556,_reservesCount,user,TMP_1376,REF_1558)\n\t\t\tTUPLE_43(uint256,uint256,uint256,uint256,uint256,uint256) = LIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeGetUserAccountData(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),DataTypes.CalculateUserAccountDataParams), arguments:['_reserves', '_reservesList', '_eModeCategories', 'TMP_1377'] \n\t\t\tRETURN TUPLE_43\n\t\tExpression: (totalCollateralBase,totalDebtBase,availableBorrowsBase,currentLiquidationThreshold,ltv,healthFactor)\n\t\tIRs:\n\t\t\tRETURN totalCollateralBase,totalDebtBase,availableBorrowsBase,currentLiquidationThreshold,ltv,healthFactor\n\tFunction Pool.getConfiguration(address) (*)\n\t\tExpression: _reserves[asset].configuration\n\t\tIRs:\n\t\t\tREF_1559(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1560(DataTypes.ReserveConfigurationMap) -> REF_1559.configuration\n\t\t\tRETURN REF_1560\n\tFunction Pool.getUserConfiguration(address) (*)\n\t\tExpression: _usersConfig[user]\n\t\tIRs:\n\t\t\tREF_1561(DataTypes.UserConfigurationMap) -> _usersConfig[user]\n\t\t\tRETURN REF_1561\n\tFunction Pool.getReserveNormalizedIncome(address) (*)\n\t\tExpression: _reserves[asset].getNormalizedIncome()\n\t\tIRs:\n\t\t\tREF_1562(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tTMP_1378(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedIncome(DataTypes.ReserveData), arguments:['REF_1562'] \n\t\t\tRETURN TMP_1378\n\tFunction Pool.getReserveNormalizedVariableDebt(address) (*)\n\t\tExpression: _reserves[asset].getNormalizedDebt()\n\t\tIRs:\n\t\t\tREF_1564(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tTMP_1379(uint256) = LIBRARY_CALL, dest:ReserveLogic, function:ReserveLogic.getNormalizedDebt(DataTypes.ReserveData), arguments:['REF_1564'] \n\t\t\tRETURN TMP_1379\n\tFunction Pool.getReservesList() (*)\n\t\tExpression: reservesListCount = _reservesCount\n\t\tIRs:\n\t\t\treservesListCount(uint256) := _reservesCount(uint16)\n\t\tExpression: droppedReservesCount = 0\n\t\tIRs:\n\t\t\tdroppedReservesCount(uint256) := 0(uint256)\n\t\tExpression: reservesList = new address[](reservesListCount)\n\t\tIRs:\n\t\t\tTMP_1381(address[])  = new address[](reservesListCount)\n\t\t\treservesList(address[]) = ['TMP_1381(address[])']\n\t\tExpression: i = 0\n\t\tIRs:\n\t\t\ti(uint256) := 0(uint256)\n\t\tExpression: i < reservesListCount\n\t\tIRs:\n\t\t\tTMP_1382(bool) = i < reservesListCount\n\t\t\tCONDITION TMP_1382\n\t\tExpression: _reservesList[i] != address(0)\n\t\tIRs:\n\t\t\tREF_1566(address) -> _reservesList[i]\n\t\t\tTMP_1383 = CONVERT 0 to address\n\t\t\tTMP_1384(bool) = REF_1566 != TMP_1383\n\t\t\tCONDITION TMP_1384\n\t\tExpression: reservesList[i - droppedReservesCount] = _reservesList[i]\n\t\tIRs:\n\t\t\tTMP_1385(uint256) = i (c)- droppedReservesCount\n\t\t\tREF_1567(address) -> reservesList[TMP_1385]\n\t\t\tREF_1568(address) -> _reservesList[i]\n\t\t\tREF_1567(address) (->reservesList) := REF_1568(address)\n\t\tExpression: droppedReservesCount ++\n\t\tIRs:\n\t\t\tTMP_1386(uint256) := droppedReservesCount(uint256)\n\t\t\tdroppedReservesCount(uint256) = droppedReservesCount (c)+ 1\n\t\tExpression: i ++\n\t\tIRs:\n\t\t\tTMP_1387(uint256) := i(uint256)\n\t\t\ti(uint256) = i (c)+ 1\n\t\tExpression: mstore(uint256,uint256)(reservesList,reservesListCount - droppedReservesCount)\n\t\tIRs:\n\t\t\tTMP_1388(uint256) = reservesListCount - droppedReservesCount\n\t\t\tTMP_1389(None) = SOLIDITY_CALL mstore(uint256,uint256)(reservesList,TMP_1388)\n\t\tExpression: reservesList\n\t\tIRs:\n\t\t\tRETURN reservesList\n\tFunction Pool.getReserveAddressById(uint16) (*)\n\t\tExpression: _reservesList[id]\n\t\tIRs:\n\t\t\tREF_1569(address) -> _reservesList[id]\n\t\t\tRETURN REF_1569\n\tFunction Pool.MAX_STABLE_RATE_BORROW_SIZE_PERCENT() (*)\n\t\tExpression: _maxStableRateBorrowSizePercent\n\t\tIRs:\n\t\t\tRETURN _maxStableRateBorrowSizePercent\n\tFunction Pool.BRIDGE_PROTOCOL_FEE() (*)\n\t\tExpression: _bridgeProtocolFee\n\t\tIRs:\n\t\t\tRETURN _bridgeProtocolFee\n\tFunction Pool.FLASHLOAN_PREMIUM_TOTAL() (*)\n\t\tExpression: _flashLoanPremiumTotal\n\t\tIRs:\n\t\t\tRETURN _flashLoanPremiumTotal\n\tFunction Pool.FLASHLOAN_PREMIUM_TO_PROTOCOL() (*)\n\t\tExpression: _flashLoanPremiumToProtocol\n\t\tIRs:\n\t\t\tRETURN _flashLoanPremiumToProtocol\n\tFunction Pool.MAX_NUMBER_RESERVES() (*)\n\t\tExpression: ReserveConfiguration.MAX_RESERVES_COUNT\n\t\tIRs:\n\t\t\tREF_1570(uint16) -> ReserveConfiguration.MAX_RESERVES_COUNT\n\t\t\tRETURN REF_1570\n\tFunction Pool.finalizeTransfer(address,address,address,uint256,uint256,uint256) (*)\n\t\tExpression: require(bool,string)(msg.sender == _reserves[asset].aTokenAddress,Errors.CALLER_NOT_ATOKEN)\n\t\tIRs:\n\t\t\tREF_1571(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1572(address) -> REF_1571.aTokenAddress\n\t\t\tTMP_1390(bool) = msg.sender == REF_1572\n\t\t\tREF_1573(string) -> Errors.CALLER_NOT_ATOKEN\n\t\t\tTMP_1391(None) = SOLIDITY_CALL require(bool,string)(TMP_1390,REF_1573)\n\t\tExpression: SupplyLogic.executeFinalizeTransfer(_reserves,_reservesList,_eModeCategories,_usersConfig,DataTypes.FinalizeTransferParams({asset:asset,from:from,to:to,amount:amount,balanceFromBefore:balanceFromBefore,balanceToBefore:balanceToBefore,reservesCount:_reservesCount,oracle:ADDRESSES_PROVIDER.getPriceOracle(),fromEModeCategory:_usersEModeCategory[from]}))\n\t\tIRs:\n\t\t\tTMP_1392(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tREF_1577(uint8) -> _usersEModeCategory[from]\n\t\t\tTMP_1393(DataTypes.FinalizeTransferParams) = new FinalizeTransferParams(asset,from,to,amount,balanceFromBefore,balanceToBefore,_reservesCount,TMP_1392,REF_1577)\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeFinalizeTransfer(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),mapping(address => DataTypes.UserConfigurationMap),DataTypes.FinalizeTransferParams), arguments:['_reserves', '_reservesList', '_eModeCategories', '_usersConfig', 'TMP_1393'] \n\tFunction Pool.initReserve(address,address,address,address,address) (*)\n\t\tExpression: PoolLogic.executeInitReserve(_reserves,_reservesList,DataTypes.InitReserveParams({asset:asset,aTokenAddress:aTokenAddress,stableDebtAddress:stableDebtAddress,variableDebtAddress:variableDebtAddress,interestRateStrategyAddress:interestRateStrategyAddress,reservesCount:_reservesCount,maxNumberReserves:MAX_NUMBER_RESERVES()}))\n\t\tIRs:\n\t\t\tTMP_1395(uint16) = INTERNAL_CALL, Pool.MAX_NUMBER_RESERVES()()\n\t\t\tTMP_1396(DataTypes.InitReserveParams) = new InitReserveParams(asset,aTokenAddress,stableDebtAddress,variableDebtAddress,interestRateStrategyAddress,_reservesCount,TMP_1395)\n\t\t\tTMP_1397(bool) = LIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeInitReserve(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.InitReserveParams), arguments:['_reserves', '_reservesList', 'TMP_1396'] \n\t\t\tCONDITION TMP_1397\n\t\tExpression: _reservesCount ++\n\t\tIRs:\n\t\t\tTMP_1398(uint16) := _reservesCount(uint16)\n\t\t\t_reservesCount(uint16) = _reservesCount (c)+ 1\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.dropReserve(address) (*)\n\t\tExpression: PoolLogic.executeDropReserve(_reserves,_reservesList,asset)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeDropReserve(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),address), arguments:['_reserves', '_reservesList', 'asset'] \n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.setReserveInterestRateStrategyAddress(address,address) (*)\n\t\tExpression: require(bool,string)(asset != address(0),Errors.ZERO_ADDRESS_NOT_VALID)\n\t\tIRs:\n\t\t\tTMP_1402 = CONVERT 0 to address\n\t\t\tTMP_1403(bool) = asset != TMP_1402\n\t\t\tREF_1581(string) -> Errors.ZERO_ADDRESS_NOT_VALID\n\t\t\tTMP_1404(None) = SOLIDITY_CALL require(bool,string)(TMP_1403,REF_1581)\n\t\tExpression: require(bool,string)(_reserves[asset].id != 0 || _reservesList[0] == asset,Errors.ASSET_NOT_LISTED)\n\t\tIRs:\n\t\t\tREF_1582(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1583(uint16) -> REF_1582.id\n\t\t\tTMP_1405(bool) = REF_1583 != 0\n\t\t\tREF_1584(address) -> _reservesList[0]\n\t\t\tTMP_1406(bool) = REF_1584 == asset\n\t\t\tTMP_1407(bool) = TMP_1405 || TMP_1406\n\t\t\tREF_1585(string) -> Errors.ASSET_NOT_LISTED\n\t\t\tTMP_1408(None) = SOLIDITY_CALL require(bool,string)(TMP_1407,REF_1585)\n\t\tExpression: _reserves[asset].interestRateStrategyAddress = rateStrategyAddress\n\t\tIRs:\n\t\t\tREF_1586(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1587(address) -> REF_1586.interestRateStrategyAddress\n\t\t\tREF_1587(address) (->_reserves) := rateStrategyAddress(address)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.setConfiguration(address,DataTypes.ReserveConfigurationMap) (*)\n\t\tExpression: require(bool,string)(asset != address(0),Errors.ZERO_ADDRESS_NOT_VALID)\n\t\tIRs:\n\t\t\tTMP_1410 = CONVERT 0 to address\n\t\t\tTMP_1411(bool) = asset != TMP_1410\n\t\t\tREF_1588(string) -> Errors.ZERO_ADDRESS_NOT_VALID\n\t\t\tTMP_1412(None) = SOLIDITY_CALL require(bool,string)(TMP_1411,REF_1588)\n\t\tExpression: require(bool,string)(_reserves[asset].id != 0 || _reservesList[0] == asset,Errors.ASSET_NOT_LISTED)\n\t\tIRs:\n\t\t\tREF_1589(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1590(uint16) -> REF_1589.id\n\t\t\tTMP_1413(bool) = REF_1590 != 0\n\t\t\tREF_1591(address) -> _reservesList[0]\n\t\t\tTMP_1414(bool) = REF_1591 == asset\n\t\t\tTMP_1415(bool) = TMP_1413 || TMP_1414\n\t\t\tREF_1592(string) -> Errors.ASSET_NOT_LISTED\n\t\t\tTMP_1416(None) = SOLIDITY_CALL require(bool,string)(TMP_1415,REF_1592)\n\t\tExpression: _reserves[asset].configuration = configuration\n\t\tIRs:\n\t\t\tREF_1593(DataTypes.ReserveData) -> _reserves[asset]\n\t\t\tREF_1594(DataTypes.ReserveConfigurationMap) -> REF_1593.configuration\n\t\t\tREF_1594(DataTypes.ReserveConfigurationMap) (->_reserves) := configuration(DataTypes.ReserveConfigurationMap)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.updateBridgeProtocolFee(uint256) (*)\n\t\tExpression: _bridgeProtocolFee = protocolFee\n\t\tIRs:\n\t\t\t_bridgeProtocolFee(uint256) := protocolFee(uint256)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.updateFlashloanPremiums(uint128,uint128) (*)\n\t\tExpression: _flashLoanPremiumTotal = flashLoanPremiumTotal\n\t\tIRs:\n\t\t\t_flashLoanPremiumTotal(uint128) := flashLoanPremiumTotal(uint128)\n\t\tExpression: _flashLoanPremiumToProtocol = flashLoanPremiumToProtocol\n\t\tIRs:\n\t\t\t_flashLoanPremiumToProtocol(uint128) := flashLoanPremiumToProtocol(uint128)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.configureEModeCategory(uint8,DataTypes.EModeCategory) (*)\n\t\tExpression: require(bool,string)(id != 0,Errors.EMODE_CATEGORY_RESERVED)\n\t\tIRs:\n\t\t\tTMP_1420(bool) = id != 0\n\t\t\tREF_1595(string) -> Errors.EMODE_CATEGORY_RESERVED\n\t\t\tTMP_1421(None) = SOLIDITY_CALL require(bool,string)(TMP_1420,REF_1595)\n\t\tExpression: _eModeCategories[id] = category\n\t\tIRs:\n\t\t\tREF_1596(DataTypes.EModeCategory) -> _eModeCategories[id]\n\t\t\tREF_1596(DataTypes.EModeCategory) (->_eModeCategories) := category(DataTypes.EModeCategory)\n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.getEModeCategoryData(uint8) (*)\n\t\tExpression: _eModeCategories[id]\n\t\tIRs:\n\t\t\tREF_1597(DataTypes.EModeCategory) -> _eModeCategories[id]\n\t\t\tRETURN REF_1597\n\tFunction Pool.setUserEMode(uint8) (*)\n\t\tExpression: EModeLogic.executeSetUserEMode(_reserves,_reservesList,_eModeCategories,_usersEModeCategory,_usersConfig[msg.sender],DataTypes.ExecuteSetUserEModeParams({reservesCount:_reservesCount,oracle:ADDRESSES_PROVIDER.getPriceOracle(),categoryId:categoryId}))\n\t\tIRs:\n\t\t\tREF_1599(DataTypes.UserConfigurationMap) -> _usersConfig[msg.sender]\n\t\t\tTMP_1423(address) = HIGH_LEVEL_CALL, dest:ADDRESSES_PROVIDER(IPoolAddressesProvider), function:getPriceOracle, arguments:[]  \n\t\t\tTMP_1424(DataTypes.ExecuteSetUserEModeParams) = new ExecuteSetUserEModeParams(_reservesCount,TMP_1423,categoryId)\n\t\t\tLIBRARY_CALL, dest:EModeLogic, function:EModeLogic.executeSetUserEMode(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),mapping(uint8 => DataTypes.EModeCategory),mapping(address => uint8),DataTypes.UserConfigurationMap,DataTypes.ExecuteSetUserEModeParams), arguments:['_reserves', '_reservesList', '_eModeCategories', '_usersEModeCategory', 'REF_1599', 'TMP_1424'] \n\tFunction Pool.getUserEMode(address) (*)\n\t\tExpression: _usersEModeCategory[user]\n\t\tIRs:\n\t\t\tREF_1602(uint8) -> _usersEModeCategory[user]\n\t\t\tRETURN REF_1602\n\tFunction Pool.resetIsolationModeTotalDebt(address) (*)\n\t\tExpression: PoolLogic.executeResetIsolationModeTotalDebt(_reserves,asset)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeResetIsolationModeTotalDebt(mapping(address => DataTypes.ReserveData),address), arguments:['_reserves', 'asset'] \n\t\tExpression: onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolConfigurator()()\n\tFunction Pool.rescueTokens(address,address,uint256) (*)\n\t\tExpression: PoolLogic.executeRescueTokens(token,to,amount)\n\t\tIRs:\n\t\t\tLIBRARY_CALL, dest:PoolLogic, function:PoolLogic.executeRescueTokens(address,address,uint256), arguments:['token', 'to', 'amount'] \n\t\tExpression: onlyPoolAdmin()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, Pool.onlyPoolAdmin()()\n\tFunction Pool.deposit(address,uint256,address,uint16) (*)\n\t\tExpression: SupplyLogic.executeSupply(_reserves,_reservesList,_usersConfig[onBehalfOf],DataTypes.ExecuteSupplyParams({asset:asset,amount:amount,onBehalfOf:onBehalfOf,referralCode:referralCode}))\n\t\tIRs:\n\t\t\tREF_1606(DataTypes.UserConfigurationMap) -> _usersConfig[onBehalfOf]\n\t\t\tTMP_1430(DataTypes.ExecuteSupplyParams) = new ExecuteSupplyParams(asset,amount,onBehalfOf,referralCode)\n\t\t\tLIBRARY_CALL, dest:SupplyLogic, function:SupplyLogic.executeSupply(mapping(address => DataTypes.ReserveData),mapping(uint256 => address),DataTypes.UserConfigurationMap,DataTypes.ExecuteSupplyParams), arguments:['_reserves', '_reservesList', 'REF_1606', 'TMP_1430'] \n\tFunction Pool.slitherConstructorConstantVariables() (*)\n\t\tExpression: POOL_REVISION = 0x1\n\t\tIRs:\n\t\t\tPOOL_REVISION(uint256) := 1(uint256)\n\tModifier VersionedInitializable.initializer()\n\t\tExpression: revision = getRevision()\n\t\tIRs:\n\t\t\tTMP_1432(uint256) = INTERNAL_CALL, Pool.getRevision()()\n\t\t\trevision(uint256) := TMP_1432(uint256)\n\t\tExpression: require(bool,string)(initializing || isConstructor() || revision > lastInitializedRevision,Contract instance has already been initialized)\n\t\tIRs:\n\t\t\tTMP_1433(bool) = INTERNAL_CALL, VersionedInitializable.isConstructor()()\n\t\t\tTMP_1434(bool) = initializing || TMP_1433\n\t\t\tTMP_1435(bool) = revision > lastInitializedRevision\n\t\t\tTMP_1436(bool) = TMP_1434 || TMP_1435\n\t\t\tTMP_1437(None) = SOLIDITY_CALL require(bool,string)(TMP_1436,Contract instance has already been initialized)\n\t\tExpression: isTopLevelCall = ! initializing\n\t\tIRs:\n\t\t\tTMP_1438 = UnaryType.BANG initializing \n\t\t\tisTopLevelCall(bool) := TMP_1438(bool)\n\t\tExpression: isTopLevelCall\n\t\tIRs:\n\t\t\tCONDITION isTopLevelCall\n\t\tExpression: initializing = true\n\t\tIRs:\n\t\t\tinitializing(bool) := True(bool)\n\t\tExpression: lastInitializedRevision = revision\n\t\tIRs:\n\t\t\tlastInitializedRevision(uint256) := revision(uint256)\n\t\tExpression: isTopLevelCall\n\t\tIRs:\n\t\t\tCONDITION isTopLevelCall\n\t\tExpression: initializing = false\n\t\tIRs:\n\t\t\tinitializing(bool) := False(bool)\n\tModifier Pool.onlyPoolConfigurator()\n\t\tExpression: _onlyPoolConfigurator()\n\t\tIRs:\n\t\t\tINTERNAL_CALL, Pool._onlyPoolConfigurator()()\n\tModifier Pool.onlyPoolAdmin()\n\t\tExpression: _onlyPoolAdmin()\n\t\tIRs:\n\t\t\tINTERNAL_CALL, Pool._onlyPoolAdmin()()\n\tModifier Pool.onlyBridge()\n\t\tExpression: _onlyBridge()\n\t\tIRs:\n\t\t\tINTERNAL_CALL, Pool._onlyBridge()()\nContract PoolStorage\nContract IncentivizedERC20\n\tFunction IERC20Detailed.name() \n\tFunction IERC20Detailed.symbol() \n\tFunction IERC20Detailed.decimals() \n\tFunction IERC20.totalSupply() \n\tFunction IERC20.balanceOf(address) \n\tFunction IERC20.transfer(address,uint256) \n\tFunction IERC20.allowance(address,address) \n\tFunction IERC20.approve(address,uint256) \n\tFunction IERC20.transferFrom(address,address,uint256) \n\tFunction Context._msgSender() (*)\n\t\tExpression: address(msg.sender)\n\t\tIRs:\n\t\t\tTMP_1442 = CONVERT msg.sender to address\n\t\t\tRETURN TMP_1442\n\tFunction Context._msgData() (*)\n\t\tExpression: this\n\t\tIRs:\n\t\tExpression: msg.data\n\t\tIRs:\n\t\t\tRETURN msg.data\n\tFunction IncentivizedERC20.constructor(IPool,string,string,uint8) (*)\n\t\tExpression: _addressesProvider = pool.ADDRESSES_PROVIDER()\n\t\tIRs:\n\t\t\tTMP_1443(IPoolAddressesProvider) = HIGH_LEVEL_CALL, dest:pool(IPool), function:ADDRESSES_PROVIDER, arguments:[]  \n\t\t\t_addressesProvider(IPoolAddressesProvider) := TMP_1443(IPoolAddressesProvider)\n\t\tExpression: _name = name\n\t\tIRs:\n\t\t\t_name(string) := name(string)\n\t\tExpression: _symbol = symbol\n\t\tIRs:\n\t\t\t_symbol(string) := symbol(string)\n\t\tExpression: _decimals = decimals\n\t\tIRs:\n\t\t\t_decimals(uint8) := decimals(uint8)\n\t\tExpression: POOL = pool\n\t\tIRs:\n\t\t\tPOOL(IPool) := pool(IPool)\n\tFunction IncentivizedERC20.name() (*)\n\t\tExpression: _name\n\t\tIRs:\n\t\t\tRETURN _name\n\tFunction IncentivizedERC20.symbol() (*)\n\t\tExpression: _symbol\n\t\tIRs:\n\t\t\tRETURN _symbol\n\tFunction IncentivizedERC20.decimals() (*)\n\t\tExpression: _decimals\n\t\tIRs:\n\t\t\tRETURN _decimals\n\tFunction IncentivizedERC20.totalSupply() (*)\n\t\tExpression: _totalSupply\n\t\tIRs:\n\t\t\tRETURN _totalSupply\n\tFunction IncentivizedERC20.balanceOf(address) (*)\n\t\tExpression: _userState[account].balance\n\t\tIRs:\n\t\t\tREF_1609(IncentivizedERC20.UserState) -> _userState[account]\n\t\t\tREF_1610(uint128) -> REF_1609.balance\n\t\t\tRETURN REF_1610\n\tFunction IncentivizedERC20.getIncentivesController() (*)\n\t\tExpression: _incentivesController\n\t\tIRs:\n\t\t\tRETURN _incentivesController\n\tFunction IncentivizedERC20.setIncentivesController(IAaveIncentivesController) (*)\n\t\tExpression: _incentivesController = controller\n\t\tIRs:\n\t\t\t_incentivesController(IAaveIncentivesController) := controller(IAaveIncentivesController)\n\t\tExpression: onlyPoolAdmin()\n\t\tIRs:\n\t\t\tMODIFIER_CALL, IncentivizedERC20.onlyPoolAdmin()()\n\tFunction IncentivizedERC20.transfer(address,uint256) (*)\n\t\tExpression: castAmount = amount.toUint128()\n\t\tIRs:\n\t\t\tTMP_1445(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['amount'] \n\t\t\tcastAmount(uint128) := TMP_1445(uint128)\n\t\tExpression: _transfer(_msgSender(),recipient,castAmount)\n\t\tIRs:\n\t\t\tTMP_1446(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tINTERNAL_CALL, IncentivizedERC20._transfer(address,address,uint128)(TMP_1446,recipient,castAmount)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20.allowance(address,address) (*)\n\t\tExpression: _allowances[owner][spender]\n\t\tIRs:\n\t\t\tREF_1612(mapping(address => uint256)) -> _allowances[owner]\n\t\t\tREF_1613(uint256) -> REF_1612[spender]\n\t\t\tRETURN REF_1613\n\tFunction IncentivizedERC20.approve(address,uint256) (*)\n\t\tExpression: _approve(_msgSender(),spender,amount)\n\t\tIRs:\n\t\t\tTMP_1448(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tINTERNAL_CALL, IncentivizedERC20._approve(address,address,uint256)(TMP_1448,spender,amount)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20.transferFrom(address,address,uint256) (*)\n\t\tExpression: castAmount = amount.toUint128()\n\t\tIRs:\n\t\t\tTMP_1450(uint128) = LIBRARY_CALL, dest:SafeCast, function:SafeCast.toUint128(uint256), arguments:['amount'] \n\t\t\tcastAmount(uint128) := TMP_1450(uint128)\n\t\tExpression: _approve(sender,_msgSender(),_allowances[sender][_msgSender()] - castAmount)\n\t\tIRs:\n\t\t\tTMP_1451(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tREF_1615(mapping(address => uint256)) -> _allowances[sender]\n\t\t\tTMP_1452(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tREF_1616(uint256) -> REF_1615[TMP_1452]\n\t\t\tTMP_1453(uint256) = REF_1616 (c)- castAmount\n\t\t\tINTERNAL_CALL, IncentivizedERC20._approve(address,address,uint256)(sender,TMP_1451,TMP_1453)\n\t\tExpression: _transfer(sender,recipient,castAmount)\n\t\tIRs:\n\t\t\tINTERNAL_CALL, IncentivizedERC20._transfer(address,address,uint128)(sender,recipient,castAmount)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20.increaseAllowance(address,uint256) (*)\n\t\tExpression: _approve(_msgSender(),spender,_allowances[_msgSender()][spender] + addedValue)\n\t\tIRs:\n\t\t\tTMP_1456(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tTMP_1457(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tREF_1617(mapping(address => uint256)) -> _allowances[TMP_1457]\n\t\t\tREF_1618(uint256) -> REF_1617[spender]\n\t\t\tTMP_1458(uint256) = REF_1618 (c)+ addedValue\n\t\t\tINTERNAL_CALL, IncentivizedERC20._approve(address,address,uint256)(TMP_1456,spender,TMP_1458)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20.decreaseAllowance(address,uint256) (*)\n\t\tExpression: _approve(_msgSender(),spender,_allowances[_msgSender()][spender] - subtractedValue)\n\t\tIRs:\n\t\t\tTMP_1460(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tTMP_1461(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tREF_1619(mapping(address => uint256)) -> _allowances[TMP_1461]\n\t\t\tREF_1620(uint256) -> REF_1619[spender]\n\t\t\tTMP_1462(uint256) = REF_1620 (c)- subtractedValue\n\t\t\tINTERNAL_CALL, IncentivizedERC20._approve(address,address,uint256)(TMP_1460,spender,TMP_1462)\n\t\tExpression: true\n\t\tIRs:\n\t\t\tRETURN True\n\tFunction IncentivizedERC20._transfer(address,address,uint128) (*)\n\t\tExpression: oldSenderBalance = _userState[sender].balance\n\t\tIRs:\n\t\t\tREF_1621(IncentivizedERC20.UserState) -> _userState[sender]\n\t\t\tREF_1622(uint128) -> REF_1621.balance\n\t\t\toldSenderBalance(uint128) := REF_1622(uint128)\n\t\tExpression: _userState[sender].balance = oldSenderBalance - amount\n\t\tIRs:\n\t\t\tREF_1623(IncentivizedERC20.UserState) -> _userState[sender]\n\t\t\tREF_1624(uint128) -> REF_1623.balance\n\t\t\tTMP_1464(uint128) = oldSenderBalance (c)- amount\n\t\t\tREF_1624(uint128) (->_userState) := TMP_1464(uint128)\n\t\tExpression: oldRecipientBalance = _userState[recipient].balance\n\t\tIRs:\n\t\t\tREF_1625(IncentivizedERC20.UserState) -> _userState[recipient]\n\t\t\tREF_1626(uint128) -> REF_1625.balance\n\t\t\toldRecipientBalance(uint128) := REF_1626(uint128)\n\t\tExpression: _userState[recipient].balance = oldRecipientBalance + amount\n\t\tIRs:\n\t\t\tREF_1627(IncentivizedERC20.UserState) -> _userState[recipient]\n\t\t\tREF_1628(uint128) -> REF_1627.balance\n\t\t\tTMP_1465(uint128) = oldRecipientBalance (c)+ amount\n\t\t\tREF_1628(uint128) (->_userState) := TMP_1465(uint128)\n\t\tExpression: incentivesControllerLocal = _incentivesController\n\t\tIRs:\n\t\t\tincentivesControllerLocal(IAaveIncentivesController) := _incentivesController(IAaveIncentivesController)\n\t\tExpression: address(incentivesControllerLocal) != address(0)\n\t\tIRs:\n\t\t\tTMP_1466 = CONVERT incentivesControllerLocal to address\n\t\t\tTMP_1467 = CONVERT 0 to address\n\t\t\tTMP_1468(bool) = TMP_1466 != TMP_1467\n\t\t\tCONDITION TMP_1468\n\t\tExpression: currentTotalSupply = _totalSupply\n\t\tIRs:\n\t\t\tcurrentTotalSupply(uint256) := _totalSupply(uint256)\n\t\tExpression: incentivesControllerLocal.handleAction(sender,currentTotalSupply,oldSenderBalance)\n\t\tIRs:\n\t\t\tHIGH_LEVEL_CALL, dest:incentivesControllerLocal(IAaveIncentivesController), function:handleAction, arguments:['sender', 'currentTotalSupply', 'oldSenderBalance']  \n\t\tExpression: sender != recipient\n\t\tIRs:\n\t\t\tTMP_1470(bool) = sender != recipient\n\t\t\tCONDITION TMP_1470\n\t\tExpression: incentivesControllerLocal.handleAction(recipient,currentTotalSupply,oldRecipientBalance)\n\t\tIRs:\n\t\t\tHIGH_LEVEL_CALL, dest:incentivesControllerLocal(IAaveIncentivesController), function:handleAction, arguments:['recipient', 'currentTotalSupply', 'oldRecipientBalance']  \n\tFunction IncentivizedERC20._approve(address,address,uint256) (*)\n\t\tExpression: _allowances[owner][spender] = amount\n\t\tIRs:\n\t\t\tREF_1631(mapping(address => uint256)) -> _allowances[owner]\n\t\t\tREF_1632(uint256) -> REF_1631[spender]\n\t\t\tREF_1632(uint256) (->_allowances) := amount(uint256)\n\t\tExpression: Approval(owner,spender,amount)\n\t\tIRs:\n\t\t\tEmit Approval(owner,spender,amount)\n\tFunction IncentivizedERC20._setName(string) (*)\n\t\tExpression: _name = newName\n\t\tIRs:\n\t\t\t_name(string) := newName(string)\n\tFunction IncentivizedERC20._setSymbol(string) (*)\n\t\tExpression: _symbol = newSymbol\n\t\tIRs:\n\t\t\t_symbol(string) := newSymbol(string)\n\tFunction IncentivizedERC20._setDecimals(uint8) (*)\n\t\tExpression: _decimals = newDecimals\n\t\tIRs:\n\t\t\t_decimals(uint8) := newDecimals(uint8)\n\tModifier IncentivizedERC20.onlyPoolAdmin()\n\t\tExpression: aclManager = IACLManager(_addressesProvider.getACLManager())\n\t\tIRs:\n\t\t\tTMP_1473(address) = HIGH_LEVEL_CALL, dest:_addressesProvider(IPoolAddressesProvider), function:getACLManager, arguments:[]  \n\t\t\tTMP_1474 = CONVERT TMP_1473 to IACLManager\n\t\t\taclManager(IACLManager) := TMP_1474(IACLManager)\n\t\tExpression: require(bool,string)(aclManager.isPoolAdmin(msg.sender),Errors.CALLER_NOT_POOL_ADMIN)\n\t\tIRs:\n\t\t\tTMP_1475(bool) = HIGH_LEVEL_CALL, dest:aclManager(IACLManager), function:isPoolAdmin, arguments:['msg.sender']  \n\t\t\tREF_1635(string) -> Errors.CALLER_NOT_POOL_ADMIN\n\t\t\tTMP_1476(None) = SOLIDITY_CALL require(bool,string)(TMP_1475,REF_1635)\n\tModifier IncentivizedERC20.onlyPool()\n\t\tExpression: require(bool,string)(_msgSender() == address(POOL),Errors.CALLER_MUST_BE_POOL)\n\t\tIRs:\n\t\t\tTMP_1477(address) = INTERNAL_CALL, Context._msgSender()()\n\t\t\tTMP_1478 = CONVERT POOL to address\n\t\t\tTMP_1479(bool) = TMP_1477 == TMP_1478\n\t\t\tREF_1636(string) -> Errors.CALLER_MUST_BE_POOL\n\t\t\tTMP_1480(None) = SOLIDITY_CALL require(bool,string)(TMP_1479,REF_1636)\n",
        "first_markdown_element": "",
        "id": "e8ae103f0d0bbafad6e30dcd303f91c8f6ee205f629003d2c87144e25d598f95",
        "printer": "slithir"
      }
    ]
  }
}